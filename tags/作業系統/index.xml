<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>作業系統 on Hoxton</title>
        <link>https://hoxtonhsu.com/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/</link>
        <description>Recent content in 作業系統 on Hoxton</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Sat, 08 Oct 2022 03:02:43 +0800</lastBuildDate><atom:link href="https://hoxtonhsu.com/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>作業系統筆記</title>
        <link>https://hoxtonhsu.com/p/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98/</link>
        <pubDate>Sat, 08 Oct 2022 03:02:43 +0800</pubDate>
        
        <guid>https://hoxtonhsu.com/p/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;img src="https://i.imgur.com/HJLk11O.png" alt="Featured image of post 作業系統筆記" /&gt;&lt;h1 id=&#34;operating-system&#34;&gt;Operating-System&lt;/h1&gt;
&lt;h1 id=&#34;第一節-總覽&#34;&gt;第一節 總覽&lt;/h1&gt;
&lt;h2 id=&#34;第一章-序言&#34;&gt;第一章 序言&lt;/h2&gt;
&lt;p&gt;管理硬體的軟體就是作業系統，硬體包含CPU，Memory，I/O設備等等…作業系統就是負責管理這些硬體的系統。一個電腦系統可以被粗略的劃分成下面四個組件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬體(hardware)&lt;/li&gt;
&lt;li&gt;作業系統(operating system)&lt;/li&gt;
&lt;li&gt;應用程式(application programs)&lt;/li&gt;
&lt;li&gt;使用者(user)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PZiePn0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220918222340597&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;硬體hardware&#34;&gt;硬體(hardware)&lt;/h3&gt;
&lt;p&gt;包括CPU(Central Processing Unit)，記憶體(Memory)，Input/output設備…提供給系統基本的計算資源&lt;/p&gt;
&lt;h3 id=&#34;作業系統operating-system&#34;&gt;作業系統(operating system)&lt;/h3&gt;
&lt;p&gt;負責協調硬體與應用程式，給不同的使用者&lt;/p&gt;
&lt;h3 id=&#34;應用程式application-programs&#34;&gt;應用程式(application programs)&lt;/h3&gt;
&lt;p&gt;例如Word，Excel，Chrome之類的應用程式，來處理使用者的計算問題(Computing Problems)&lt;/p&gt;
&lt;p&gt;補充：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bare Machine(裸機): 純粹只有硬體組成，沒有OS及System Programs&lt;/li&gt;
&lt;li&gt;Extended Machine: Bare Machine加上OS/system programs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/inlIZJo.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221029143145761&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In Memory
&lt;ul&gt;
&lt;li&gt;Command Interpreter(命令解譯器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multiprogramming-system&#34;&gt;Multiprogramming System&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定義：系統允許多個Jobs(Process)同時執行，即是Multiprogramming&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主要目的：提高CPU Utilization&lt;/li&gt;
&lt;li&gt;作法：透過Job Scheduling or CPU Scheduling技術達成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example：當執行中的process  waiting for I/O completed, 則OS可將CPU切換給另一個process執行，避免CPU idle 。&lt;/p&gt;
&lt;p&gt;即只要系統內有夠多的工作存在，則CPU IDLE的機會就下降&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Mulitiprogramming Degree之定義&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;系統內的Process的數目：一般而言，Degree越高，CPU利用率就越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(Note：Virtual Memory Thrashing狀況除外)&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;多個Process的定義、以及如何執行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Concurrent execution(並行)：一顆CPU，大家一起輪番使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JUSKW04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102220045970&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Parallel execution(平行)：多顆CPU或是Multi-core(多核)，各自執行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CELncNq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102220202298&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;time-sharing-system分時系統&#34;&gt;Time-Sharing System(分時系統)&lt;/h3&gt;
&lt;p&gt;定義：又叫Multitasking[恐龍本如是說]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a logical extension of Multiprogeamming system&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;與Multiprogramming的最大差異：&lt;strong&gt;CPU的切換頻率極高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Time-Sharing System features
&lt;ul&gt;
&lt;li&gt;強調對&lt;strong&gt;User Response的時間&lt;/strong&gt;要&lt;strong&gt;短&lt;/strong&gt;(&amp;lt;1秒)&lt;/li&gt;
&lt;li&gt;適用於user interactive的Computing/ Environment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Main Frame(主機)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dHbi3Pr.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102223550343&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU Scheduling採取RR的排班法則(第四章會介紹)&lt;/li&gt;
&lt;li&gt;使用Virtual Memory的技術，擴展Logical Memory Space&lt;/li&gt;
&lt;li&gt;使用Spooling的技術(不太會考)實現I/O Device的共用，類似現代的Buffering技術，讓每個user，皆以為自己有專屬的的Computer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multiprocessors-system&#34;&gt;Multiprocessors System&lt;/h3&gt;
&lt;p&gt;定義：又叫Multiprocessing or Paraller or Tightly-coupled system(緊密耦合系統)&lt;/p&gt;
&lt;p&gt;faeture：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一個機器(or MotherBoard)內，有多個Processors(or CPUs)&lt;/li&gt;
&lt;li&gt;這些CPUs彼此共享此機器的Memory,Bus,I/O-Device, power-supplier etc&amp;hellip;&lt;/li&gt;
&lt;li&gt;通常受同一Clock之時脈控制&lt;/li&gt;
&lt;li&gt;由同一個OS管理&lt;/li&gt;
&lt;li&gt;processors之間的溝通大都採shared Memory方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hvugyDq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221106193948248&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Benefits(好處)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Increased Throughput：產能增加&lt;/li&gt;
&lt;li&gt;Increased Reliability：可靠度的提升&lt;/li&gt;
&lt;li&gt;Economy Of Scale：運算能力的擴充比較好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　分析如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Increased Throughput：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可支持多個工作在不同CPU上平行執行(paraller Computing)，&lt;strong&gt;注意，N顆CPU之產能絕對小於1顆CPU產能xN倍&lt;/strong&gt;，意即CPU數量的提升與產能的提升並非線性成長。原因是因為&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Resource Contetion(資源的競爭)&lt;/li&gt;
&lt;li&gt;Processors間的Communication會抵消產能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Increased Reliability:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某一顆CPU壞了，則System不會因此而停頓，因為其他CPU仍可運作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graceful degradation(漸進式的滅亡)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;System不至因為某些Hardward/Software之元件故障而停頓，仍然保有持續運作的能力，這性質就稱為fail-soft&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Fault-Tolerant system(容錯系統)&lt;strong&gt;考試不太會考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有graceful degradation性質之系統就叫做Fault-Tolerant system，想要達成容錯的技術需要有兩件事情的支援&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;要有backup的系統，切換也要流暢&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Economy of Scale:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;運算能力擴充符合經濟效益&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;∵N顆CPU在一部機器內，與N部機器相比，成本較便宜∵這些CPUs共享同一機器之Memory, Bus, I/O-Device, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;multiprocessors-system可以再拆分成兩種subtypes&#34;&gt;Multiprocessors System可以再拆分成&lt;strong&gt;兩種&lt;/strong&gt;subTypes&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;SMP(Symmetric MultiProcessors) 對稱的&lt;/li&gt;
&lt;li&gt;ASMP(Asymmetric MultiProcessors) 非對稱的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;SMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定義：每個Processor的工作能力是相同的(Identical)，且每個CPU都有對等、平等的權利來存取資源&lt;/p&gt;
&lt;p&gt;優點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可靠度較ASMP高，因工作能力相同，即使其中一個cpu掛了也可以被立刻取代&lt;/li&gt;
&lt;li&gt;效能較高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SMP的OS設計開發較為複雜(互斥存取的機制設計,資源的競爭)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;ASMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定義：每個Processor之工作能力&lt;strong&gt;不盡相同&lt;/strong&gt;，通常是採取&lt;strong&gt;Master-Slave&lt;/strong&gt;的架構(恐龍本有時候會寫成Boss-Employee&lt;/p&gt;
&lt;p&gt;Master-Processor負責工作分派及資源分配，監督Slaves等管理工作&lt;/p&gt;
&lt;p&gt;Slave Processors負責執行工作&lt;/p&gt;
&lt;p&gt;優點：ASMP的OS設計開發較為Simple，∵與Simple-Cpu Os版類似&lt;/p&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可靠度低，Master CPU如果壞了，就會停擺，直到另一顆CPU被Train接手&lt;/li&gt;
&lt;li&gt;效能較低∵Master CPU是瓶頸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wo1RhWy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108212149764&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;multiprocessors-system-vs-multicores-cpu&#34;&gt;Multiprocessors System VS MultiCores CPU&lt;/h4&gt;
&lt;p&gt;從作業系統來看差異不大，主要差異是&lt;strong&gt;硬體的差異(主要)&lt;/strong&gt;，以OS來看，你裝了一顆兩核的CPU，OS會視作兩顆CPU；裝四核的視作四顆CPU&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MultiProcessors&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BhjZbvk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108214627937&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;MultiCores CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HNuJgLM.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108214639509&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;優點&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Power Saving：相較MultiProcessor，在一個CPU上提供兩個Core的能源耗損會比在一張板子上提供兩顆CPU的能源耗損還來得低。&lt;/li&gt;
&lt;li&gt;Speed比較快(∵處在同一個晶片內資料傳輸速度較快)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;distribute-system&#34;&gt;Distribute System&lt;/h3&gt;
&lt;p&gt;定義：又叫Loosely-Coupled system(鬆散耦合系統)，主要的Feature如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;多部機器彼此透過Network(or Bus)相互串連&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每部機器之CPU有各自私有的Memory, Bus, I/O-Device, etc 並非共享&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各CPU之Clock時脈控制不一定相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各CPU上之OS也不一定相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各Processors之間的溝通大都採**&amp;ldquo;Message Passing&amp;rdquo;**方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Message Passing (類似講電話)&lt;/p&gt;
&lt;p&gt;Step&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立Communication Link&lt;/li&gt;
&lt;li&gt;Message 相互傳輸&lt;/li&gt;
&lt;li&gt;釋放Link&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6gSkGlg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221110232152377&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;建構distribute-system之理由好處&#34;&gt;建構Distribute-System之理由(好處)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Increased Throughput(支持Paraller Computing)&lt;/li&gt;
&lt;li&gt;Increased Reliability(一個掛掉，還有其他可以擋)&lt;/li&gt;
&lt;li&gt;Resource Sharing(資源共享因此成本降低)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;支持&amp;quot;Client-Server&amp;quot; Computing Model之實施&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Server(伺服器)：提供某些服務的機器 example: mail server, file server ,DNS,printer server, computing server &amp;hellip;&lt;/li&gt;
&lt;li&gt;Client：本身不提供服務，且它需要某些服務時，則發請求至Server, Server服務完再將結果回傳Client&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第二章-operating-system-strucutures作業系統架構&#34;&gt;第二章 Operating-System Strucutures(作業系統架構)&lt;/h2&gt;
&lt;h3 id=&#34;os-service&#34;&gt;OS Service&lt;/h3&gt;
&lt;p&gt;透過System Code去呼叫這些Service&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RIMvaGk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221008173129040&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;os-application-interface最重要的&#34;&gt;OS-Application Interface(最重要的)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;System call (使用組合語言撰寫)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operating System本身就是一個提供Service的Software，提供Process conmtrol, FIle management, Device management, Information maintenance, Communications。而System Call則是OS的Interface，透過System Call去進行Software的Interrupt。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於System call是使用組合語言來寫的，較不貼近人類，因此在多加一層API，來調用System call。這些API有些會使用到多個System Call，有些則連一個System Call都沒有，因為API本身就只是為了方面Programing，提供一個Interface去調用更底層的System call&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qKgR7ax.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221008225805849&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;System Call傳送參數的三種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透過Rigisters&lt;/li&gt;
&lt;li&gt;透過Pointer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/L0RUgJ9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009135803193&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;透過Stack&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;os-structure-operating-system&#34;&gt;OS Structure Operating-System&lt;/h3&gt;
&lt;h4 id=&#34;simple-os-architecture&#34;&gt;Simple OS Architecture&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GtaKA9x.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009193532801&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;MS-DOS device driver和ROM BIOS device driver其實都是Driver，大部分的東西都還是塞在Resident system program裡面，也就是沒再分。&lt;/p&gt;
&lt;h4 id=&#34;layer-os-architecture&#34;&gt;Layer Os Architecture&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SXR7S2w.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009193909302&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;基於Simple OS Architecture對於維護上的不便（所有東西都寫在一起），所以有人提出了分層的概念，在kerel依照subsystem的概念去劃分各個職責。外層的layer可以call裡面的layer，裡面的layer不能call外面的layer，概念有點像Mvc架構，這樣方便工程師去維護，但相對的也會帶來一些&lt;strong&gt;困難&lt;/strong&gt;，比如說&lt;strong&gt;效能降低&lt;/strong&gt;，因為需要由外面一層一層呼叫，因此效能會降低。另一方面，要去定義&lt;strong&gt;各個Layer&lt;/strong&gt;也不是一件容易的事情。&lt;/p&gt;
&lt;h4 id=&#34;microkernel-os&#34;&gt;Microkernel OS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lVO8ERV.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009200319941&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;kernel的程式碼應該要越少越好，越少越小代表越Reliable。&lt;/p&gt;
&lt;p&gt;引入Modularize的概念，把Subsystem變成各種modular，中間的kernel是負責去溝通各種不同的Modular。&lt;/p&gt;
&lt;p&gt;kernel只負責去溝通和定義，但因為這個架構的每一個subsystem要溝通都要透過kernel，去interrupt它，效能又會在更低&lt;/p&gt;
&lt;h4 id=&#34;modular-os-structure&#34;&gt;Modular OS Structure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MQWMMPO.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009203643586&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;現在常見的作業系統大部分都遵循這個架構（linux），有點像OO的概念，把功能&lt;strong&gt;寫成各個在kernel&lt;/strong&gt;裡面的Subsystem，可以去這張投影片下面的網址，會手把手教你怎麼撰寫kernel&lt;/p&gt;
&lt;h4 id=&#34;virtual-machine&#34;&gt;Virtual Machine&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nwp4ACJ.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009214443781&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yqh2tao.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009214705990&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://youtu.be/7pAiJeldUfk?t=700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://youtu.be/7pAiJeldUfk?t=700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以多看幾次。&lt;/p&gt;
&lt;p&gt;critical instruction：一個instruction在user mode跟kernel mode執行的結果會不一樣，比如說user mode可能是a+b，但在kernel mode執行的結果是a+b+b&lt;/p&gt;
&lt;p&gt;VM的好處&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔離各個使用著，保護system resouce&lt;/li&gt;
&lt;li&gt;透過VM，可以在一台電腦因應不同的程式需求，建立不同的VM（window 98，windowXP）&lt;/li&gt;
&lt;li&gt;幫助R&amp;amp;D測試開發，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VM的技術&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full Virtualization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UEXmsCg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009224922016&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;一個guest的作業系統，可以不用做任何修改就可以直接安裝在一個作業系統，VM不知道自己是個VM，以為自己就是一個完整的作業系統&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para-virtualization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/62vkO74.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010131253990&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;會有一個Global zone，負責去調度、協調各個VM，Guest的作業系統需要被修改&lt;/p&gt;
&lt;h4 id=&#34;java-virtual-machine&#34;&gt;Java Virtual Machine&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H4YbXj1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010132400382&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;第二節-process-management-進程管理&#34;&gt;第二節 Process Management (進程管理)&lt;/h1&gt;
&lt;h2 id=&#34;第三章-processes-進程&#34;&gt;第三章 Processes (進程)&lt;/h2&gt;
&lt;h4 id=&#34;process-concept&#34;&gt;Process Concept&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/46QhD4h.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010162753190&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program：被動的，可被執行的程式就叫Program，存在硬碟裡面&lt;/li&gt;
&lt;li&gt;Process：主動的，一個程式正在執行就叫Process，是存在Memory裡面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;code segment&lt;/code&gt;：把程式碼放到memory裡面的動作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data section&lt;/code&gt;：globla variable存放的區域&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt;：區域變數及function存放的地方&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Heap&lt;/code&gt;：(待補)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/67apr7c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010170803581&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;又稱做Lightweight process，是CPU的最小執行單位，它跟Process有八成像，Process可以被拆分成很多個Thread，許多Thread&lt;strong&gt;可以共用同一塊Memory Space&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同一個Process下面的Thread，它的Code section，Data section，OS resource ，這三塊的memory空間是共用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/P3yDybT.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010172926249&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;管理Thread的方式跟管理Process的方式都大同小異，區別不大，像Linux就沒有Process的概念。都只有Thread而已，當一個Process被執行起來時，會有下面這五個狀態&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oPCYLp0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010175047577&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;New：當這個Process被created出來，把Program load 進 Memory裡面，然後initialization。&lt;/li&gt;
&lt;li&gt;Ready：把Process放進一個quoue裡面，等著被OS排程，放進CPU做使用。&lt;/li&gt;
&lt;li&gt;Running：送instructions到CPU裡面做使用&lt;/li&gt;
&lt;li&gt;Ｗating：有些instruction不需要CPU來做，例如IO，而等待其他事件執行完畢的這個過程就叫wating&lt;/li&gt;
&lt;li&gt;Terminated：釋放資源，把資源給其他的Process&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/A9jcaOI.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010180531411&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;管理Process的方式，就是會為每一個Process去建立一個&lt;strong&gt;Process Control Block&lt;/strong&gt;，在Memory裡面紀錄這些Information，在Ready狀態的意思，就是只把PCB放進quoue的動作，這個PCB會存放下列資訊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Process State&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Program counter（CPU中的Register，用於指示電腦在其程式序列中的位置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU Register（CPU中，用來暫存指令、數據和記憶體位址的電腦記憶體，暫存器的容量有限，但讀寫速度快的飛起）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU Scheduling Information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory-management information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O status information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accounting Information&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/s2ZFuvE.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010182705266&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lOawJ5v.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010183709101&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU被interrupt之後，把CPU上執行的Process切換成另一個Process的動作，就叫Context Switch，實際上就是在做PCB的Save還有Load的動作。&lt;/p&gt;
&lt;p&gt;Context Switch是一個overhead（浪費）的行為，但卻無可避免，因為我們要Share CPU 給所有的Process。&lt;/p&gt;
&lt;p&gt;提升Context Switch的速度有幾種方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提升momory的速度&lt;/li&gt;
&lt;li&gt;減少Register的數量，數量減少了，需要存儲的資料也少了，但這件事情在現代很難做到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面兩種都不是主流的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware Support，有好幾個set的Register，可以在hardware裡面紀錄好幾個程式的狀態，所以在做Context Switch的時候，只是從一個Register切換到另一個Register，減少對memory的access&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;process-scheduling&#34;&gt;Process Scheduling&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zvU98FQ.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010185905554&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Process 也能產生 Process （parent跟child）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9GsCQX3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010230406358&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU的數量很少，可能只有個位數或十幾個，但在Memory要執行的程式卻很多(multiProgram)，因此需要Scheduler，有分為三種Scheduler&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Short-term**(CPU Scheduler)**：選擇哪個Process要被執行，以及分配CPU&lt;/li&gt;
&lt;li&gt;Long-term**(Job Scheduler)**：決定哪些Processes能被Load進Memory，以及進入queue等待&lt;/li&gt;
&lt;li&gt;Medium-term：決定哪個Processes被丟回Memory（從Ready state 變成 Wait state）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XyXSPVP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010232740246&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;long-term-scheduler&#34;&gt;Long-Term Scheduler&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制 degree of multiprogramming：目前電腦上有幾個程式在Memory裡面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行的頻率相較Short-term來講較低（只在process離開系統，或是每隔幾分鐘執行一次）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇什麼Processes也很重要，因為我們希望CPU跟I/O可以overlap，不要完全偏向CPU或是I/O，而讓另一方沒事情做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在現在的OS裡面，因為Memory已經足夠，因此Job Schduler的功能逐漸淡化，直接先load進memory再說，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;short-term-scheduler&#34;&gt;Short-Term Scheduler&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uzdlYWX.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010234018932&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頻率極短(100ms)&lt;/li&gt;
&lt;li&gt;要非常有效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;medium-term-scheduler&#34;&gt;Medium-Term Scheduler&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nYV5B7I.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221011010707793&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;負責在DisK及Memory之間切換的Scheduler&lt;/p&gt;
&lt;p&gt;Swap Out：把Processes移出記憶體&lt;/p&gt;
&lt;p&gt;Swap In：把Processes移入記憶體&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PYbB6CD.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012001702454&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每個Processor都有自己的ID(Processor identifier &lt;strong&gt;pid&lt;/strong&gt;)，&lt;strong&gt;整台電腦一開始在執行的時候只會有一個Process&lt;/strong&gt;，這個Process再去Create其他的Process&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個指令可以列出所有啟動的Processes&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps-ael 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tdzYGmL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012003309571&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;process-creation&#34;&gt;Process Creation&lt;/h5&gt;
&lt;p&gt;Parent和Child雖然是兩隻不一樣的程式，但還是有某種程度上的關聯，這個關聯性的定義，分成下面三個比較重要的部分，&lt;strong&gt;這個關聯性是由OS的設計者去決定的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Resource Sharing之間的關聯性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parent跟Child分享所有資源&lt;/li&gt;
&lt;li&gt;Global共享，但Dynamic的不共享&lt;/li&gt;
&lt;li&gt;全部都不分享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Processes執行的順序，當Child被創建後，哪個Process有優先執行的權力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讓OS自己來決定&lt;/li&gt;
&lt;li&gt;Chidren擁有較高的執行權&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process Address Space的狀態&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Child複製Parent的過去（連Code Counter，程式執行到哪一行都會複製過去，比如說Parent執行到第三行，那複製過去的Child就會從第三開始啟動。行為都一樣，但Address會不一樣）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Child重新去Load Parent的程式碼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OygMp9G.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012215807520&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;unixlinux-process-creation&#34;&gt;UNIX/Linux Process Creation&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fork&lt;/strong&gt; system Call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;創建新的Child Process&lt;/li&gt;
&lt;li&gt;是用複製(duplicates)的方式創建的&lt;/li&gt;
&lt;li&gt;執行無先後順序之分&lt;/li&gt;
&lt;li&gt;Fork的這個Code也是個System code，會return 一個 value，return的value會是它children的PID，若底下無children則return 0 （父母一定知道小孩是誰，但小孩不一定知道父母是誰）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;execlp&lt;/strong&gt; system call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parent跟Child是dupulicate，裡面的內容完完全全一模一樣，但今天create 一個新的process的目的不是為了做同樣的事情，因此execlp這個system call的目的，就是塞一個binary file（也就是program），就會把把child的process全部清空。**那為什麼不直接創造一個新的process？**因為需要跟OS註冊一個PID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wait&lt;/strong&gt; system call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為執行順序是concurrently，因此需要用wait來做順序的控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/a5oWtwq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012222041627&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這只是UNIX系統對Process的策略，不代表所有，實際還是要參照[Process Creation](# Process Creation)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從A複製一份到A&amp;rsquo;s child，之所以A&amp;rsquo;s child會比較小的原因，主要是因為，如果是完整複製的話，其實大小是會一樣的，父Process有100 MB，子Process 就會有100MB，但這樣的事情很沒意義，因此現在會採用Copy-on-write，保存重要的資訊就好，其他的就不複製過去，比如說code counter，或是Local Variable都沒有變的話，則子Process會用一個Pointer指到父Process，但如果Runtime後發現不一樣，OS才真的會複製一份到子process。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W3myj7Q.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012225909520&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tH3YUq6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012231835420&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;恩，這邊不太清楚，要再回頭看 不懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;interprocess-communicationipc&#34;&gt;Interprocess Communication(IPC)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/b6dna1d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012233401342&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在OS的世界裡，有時候Process跟Thread是不分的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPC：不同或相同的Process裡面的thread要互相溝通&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EfY6Ymz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012234603052&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;讀投影片就是完整的筆記了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;溝通的方式有兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shared Memory&lt;/p&gt;
&lt;p&gt;有一塊Memoryd空間是share的，兩個人都可以用pointer去access它(會有synchronization的問題)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Message Passing&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​      跨電腦的訊息溝通是Message Passing&lt;/p&gt;
&lt;p&gt;資料量小的話用Shared memory，資料量大的話用Message passing（避免synchronization問題），&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/getfXBb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012235849010&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如何Message Passing呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Socket：透過IP和Port來辨認使用者，&lt;strong&gt;Port Number(8080,5432)就是Process&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Process ID是一個Process獨一無二的ID，用來辨認不同Process&lt;/p&gt;
&lt;p&gt;Port Number是作為網路連線的一部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Socket是個比較low level的傳遞方式，只能傳遞stream of bytes。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remote Procedure Calls&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;shared-memory&#34;&gt;Shared Memory&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vVFc3gA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221013223320680&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pwAp55s.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015144503008&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VX7VTFL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015144924661&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完全看不懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;message-passing&#34;&gt;Message Passing&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zEPTisH.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015151426143&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GjTgnUy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015152045607&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用Memory copy的方式，溝通的方式有一點像打電話，有一個人要打電話(Send)另一個人要接電話(Receive)，訊息才可以交流，這一部分也隱含了同步化的操作，意即Message Passing雖然速度比較慢，但它其實幫你做了同步化這件事情。&lt;/p&gt;
&lt;p&gt;為了要溝通，所以需要先建立一個communication link，並提供一個Send跟receive的function code，實作一個communication link有分成physical跟logical兩個部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Physical&lt;/p&gt;
&lt;p&gt;例如Shared memory, HW bus 或是 network的部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Logical(Program 在乎的事情)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;溝通的方向性(單向還是雙向)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;symmetric and asymmetric 對稱與非對稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Blocking or non-blocking&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;blocking：呼叫一個function，除非這個function全部做完才會做下一件事情，循序漸進的方法去執行程式&lt;/p&gt;
&lt;p&gt;Non-Blocking：呼叫一個function，如果有資料就回傳資料，如果沒有資料回傳就會得到一個Error，並執行下一個程式（大概啦）&lt;/p&gt;
&lt;p&gt;參考資料：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;淺談I/O Model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;hellip;. 參閱上面投影片&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5xOl2Ks.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015154148903&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DlWQ645.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015192600656&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bq56vJz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015192823026&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;傳遞訊息的時候，不是把訊息直接傳給一個人，而是放到一個Mail Box裡面，想要這個message的人自己到mailbox裡面拿，這種不知道雙方是誰的Communication就叫做indirect communication&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AOImSIi.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015231131458&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;MailBox所遇到的問題&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果很多人同時連線到MailBox該怎麼辦?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限制這個communication只能有兩個人同時使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一時間只能有一個Receiver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;mailbox不做限制要幾個人來都可以但當有人同時access的時候會有其中一方先被delay&#34;&gt;MailBox不做限制，要幾個人來都可以，但當有人同時Access的時候，會有其中一方先被Delay&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;synchronization&#34;&gt;Synchronization&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cuNUaxt.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015232822207&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不懂，Buffer是啥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Message在傳遞的時候一定是blocking或是non-blocking的狀態，要特別注意，Blcoking Send 不一定要對到Blocking Receive，它們之間沒有相對關係&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Blocking&lt;/th&gt;
&lt;th&gt;NonBlock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Send&lt;/td&gt;
&lt;td&gt;在Message被收到之前，Sender都是被blocked住的&lt;/td&gt;
&lt;td&gt;Sender送出Messager，不管有沒有人收到訊息，都直接去做自己的事&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Receive&lt;/td&gt;
&lt;td&gt;Receiver被blocked住，直到收到訊息&lt;/td&gt;
&lt;td&gt;Receiver收到一個valid Message或null(因為是nonBlock)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;sockets&#34;&gt;Sockets&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yxrK8Tu.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015234703436&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Accept之後會產生一個thread，所以這整體是一個MultiThread的架構&lt;/p&gt;
&lt;h4 id=&#34;remote-procedure-callsrpc&#34;&gt;Remote Procedure Calls：RPC&lt;/h4&gt;
&lt;h2 id=&#34;第四章-thread--concurrency-執行序與併發&#34;&gt;第四章 Thread &amp;amp; Concurrency (執行序與併發)&lt;/h2&gt;
&lt;h2 id=&#34;第五章-cpu-scheduling-cpu-行程&#34;&gt;第五章 CPU Scheduling (CPU 行程)&lt;/h2&gt;
&lt;h1 id=&#34;第三節-process-synchronization-進程同步&#34;&gt;第三節 Process Synchronization (進程同步)&lt;/h1&gt;
&lt;h2 id=&#34;第六章-synchronization-tools-同步工具&#34;&gt;第六章 Synchronization Tools (同步工具)&lt;/h2&gt;
&lt;h2 id=&#34;第七章-synchronization-examples-同步範例&#34;&gt;第七章 Synchronization Examples (同步範例)&lt;/h2&gt;
&lt;h2 id=&#34;第八章-deadlocks死鎖&#34;&gt;第八章 Deadlocks(死鎖)&lt;/h2&gt;
&lt;h1 id=&#34;第四節-memory-management記憶體管理&#34;&gt;第四節 Memory Management(記憶體管理)&lt;/h1&gt;
&lt;h2 id=&#34;第九章-main-memory主記憶體&#34;&gt;第九章 Main Memory(主記憶體)&lt;/h2&gt;
&lt;h2 id=&#34;第十章-virtual-memory虛擬記憶體&#34;&gt;第十章 Virtual Memory(虛擬記憶體)&lt;/h2&gt;
&lt;h1 id=&#34;第五節-storage-management儲存空間管理&#34;&gt;第五節 Storage Management(儲存空間管理)&lt;/h1&gt;
&lt;h2 id=&#34;第十一章-mass-storage-structure-大型儲存架構&#34;&gt;第十一章 Mass-Storage Structure (大型儲存架構)&lt;/h2&gt;
&lt;h2 id=&#34;第十二章-io-system-輸入輸出系統&#34;&gt;第十二章 I/O System (輸入/輸出系統)&lt;/h2&gt;
&lt;h1 id=&#34;第六節-file-system-檔案系統&#34;&gt;第六節 File System (檔案系統)&lt;/h1&gt;
&lt;h2 id=&#34;第十三章-file-system-interface-檔案系統介面&#34;&gt;第十三章 File-System Interface (檔案系統介面)&lt;/h2&gt;
&lt;h2 id=&#34;第十四章-file-system-implementation-檔案系統實作&#34;&gt;第十四章 File-System Implementation (檔案系統實作)&lt;/h2&gt;
&lt;h2 id=&#34;第十五章-file-system-internals-檔案系統內部&#34;&gt;第十五章 File-System Internals (檔案系統內部)&lt;/h2&gt;
&lt;h1 id=&#34;第七節-security-and-protected-安全性及保護&#34;&gt;第七節 Security And Protected (安全性及保護)&lt;/h1&gt;
&lt;h2 id=&#34;第十六章-security-安全性&#34;&gt;第十六章 Security 安全性&lt;/h2&gt;
&lt;h2 id=&#34;第十七章-protection-保護&#34;&gt;第十七章 Protection 保護&lt;/h2&gt;
&lt;h1 id=&#34;第八節-advenced-topics-進階主題&#34;&gt;第八節 Advenced Topics (進階主題)&lt;/h1&gt;
&lt;h2 id=&#34;第十八章-vitual-machines-虛擬機&#34;&gt;第十八章 Vitual Machines (虛擬機)&lt;/h2&gt;
&lt;h2 id=&#34;第十九章-networds-and-distributed-systems-網路與分配系統&#34;&gt;第十九章 Networds and Distributed Systems (網路與分配系統)&lt;/h2&gt;
&lt;h1 id=&#34;第九節-case-studies-案例學習&#34;&gt;第九節 Case Studies (案例學習)&lt;/h1&gt;
&lt;h2 id=&#34;第二十章-the-linux-system-linux系統&#34;&gt;第二十章 The Linux System (Linux系統)&lt;/h2&gt;
&lt;h2 id=&#34;第二十一章-windowswindows&#34;&gt;第二十一章 Windows(Windows)&lt;/h2&gt;
&lt;h1 id=&#34;第十節-appendices-附錄&#34;&gt;第十節 Appendices (附錄)&lt;/h1&gt;
&lt;h2 id=&#34;附錄a-influential-operating-system-有影響力的作業系統&#34;&gt;附錄A Influential Operating System (有影響力的作業系統)&lt;/h2&gt;
&lt;h2 id=&#34;附錄b-windowswindows&#34;&gt;附錄B Windows(Windows)&lt;/h2&gt;
&lt;h2 id=&#34;附錄c-bsd-unix&#34;&gt;附錄C BSD UNIX&lt;/h2&gt;
&lt;h2 id=&#34;附錄d-the-mach-system&#34;&gt;附錄D The Mach System&lt;/h2&gt;
&lt;h2 id=&#34;附錄a-influential-operating-system-有影響力的作業系統-1&#34;&gt;附錄A Influential Operating System (有影響力的作業系統)&lt;/h2&gt;
&lt;h2 id=&#34;附錄b-windowswindows-1&#34;&gt;附錄B Windows(Windows)&lt;/h2&gt;
&lt;h2 id=&#34;附錄c-bsd-unix-1&#34;&gt;附錄C BSD UNIX&lt;/h2&gt;
&lt;h2 id=&#34;附錄d-the-mach-system-1&#34;&gt;附錄D The Mach System&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
