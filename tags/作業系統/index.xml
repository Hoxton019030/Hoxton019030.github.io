<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>作業系統 on Hoxton</title>
        <link>https://hoxtonhsu.com/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/</link>
        <description>Recent content in 作業系統 on Hoxton</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Sat, 08 Oct 2022 03:02:43 +0800</lastBuildDate><atom:link href="https://hoxtonhsu.com/tags/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>作業系統筆記</title>
        <link>https://hoxtonhsu.com/p/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98/</link>
        <pubDate>Sat, 08 Oct 2022 03:02:43 +0800</pubDate>
        
        <guid>https://hoxtonhsu.com/p/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;img src="https://i.imgur.com/HJLk11O.png" alt="Featured image of post 作業系統筆記" /&gt;&lt;h1 id=&#34;operating-system&#34;&gt;Operating-System&lt;/h1&gt;
&lt;h1 id=&#34;洪毅作業系統筆記區&#34;&gt;洪毅作業系統筆記區&lt;/h1&gt;
&lt;h2 id=&#34;chapter1-intruduction&#34;&gt;Chapter1 Intruduction&lt;/h2&gt;
&lt;p&gt;管理硬體的軟體就是作業系統，硬體包含CPU，Memory，I/O設備等等…作業系統就是負責管理這些硬體的系統。一個電腦系統可以被粗略的劃分成下面四個組件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬體(hardware)&lt;/li&gt;
&lt;li&gt;作業系統(operating system)&lt;/li&gt;
&lt;li&gt;應用程式(application programs)&lt;/li&gt;
&lt;li&gt;使用者(user)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PZiePn0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220918222340597&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;hardware&#34;&gt;Hardware&lt;/h3&gt;
&lt;p&gt;包括CPU(Central Processing Unit)，記憶體(Memory)，Input/output設備…提供給系統基本的計算資源&lt;/p&gt;
&lt;h3 id=&#34;operating-system-1&#34;&gt;Operating System&lt;/h3&gt;
&lt;p&gt;負責協調硬體與應用程式，給不同的使用者&lt;/p&gt;
&lt;h3 id=&#34;application-programs&#34;&gt;Application Programs&lt;/h3&gt;
&lt;p&gt;例如Word，Excel，Chrome之類的應用程式，來處理使用者的計算問題(Computing Problems)&lt;/p&gt;
&lt;p&gt;補充：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bare Machine(裸機): 純粹只有硬體組成，沒有OS及System Programs&lt;/li&gt;
&lt;li&gt;Extended Machine: Bare Machine加上OS/system programs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/inlIZJo.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221029143145761&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In Memory
&lt;ul&gt;
&lt;li&gt;Command Interpreter(命令解譯器)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multiprogramming-system&#34;&gt;Multiprogramming System&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定義：系統允許多個Jobs(Process)同時執行，即是Multiprogramming&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主要目的：提高CPU Utilization&lt;/li&gt;
&lt;li&gt;作法：透過Job Scheduling or CPU Scheduling技術達成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;example：當執行中的process  waiting for I/O completed, 則OS可將CPU切換給另一個process執行，避免CPU idle 。&lt;/p&gt;
&lt;p&gt;即只要系統內有夠多的工作存在，則CPU IDLE的機會就下降&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Mulitiprogramming Degree之定義&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;系統內的Process的數目：一般而言，Degree越高，CPU利用率就越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(Note：Virtual Memory Thrashing狀況除外)&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;多個Process的定義、以及如何執行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Concurrent execution(並行)：一顆CPU，大家一起輪番使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/JUSKW04.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102220045970&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Parallel execution(平行)：多顆CPU或是Multi-core(多核)，各自執行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CELncNq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102220202298&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;time-sharing-system&#34;&gt;Time-Sharing System&lt;/h3&gt;
&lt;p&gt;分時系統&lt;/p&gt;
&lt;p&gt;定義：又叫Multitasking[恐龍本如是說]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a logical extension of Multiprogeamming system&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;與Multiprogramming的最大差異：&lt;strong&gt;CPU的切換頻率極高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Time-Sharing System features&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;強調對&lt;strong&gt;User Response的時間&lt;/strong&gt;要&lt;strong&gt;短&lt;/strong&gt;(&amp;lt;1秒)&lt;/li&gt;
&lt;li&gt;適用於user interactive的Computing/ Environment&lt;/li&gt;
&lt;li&gt;對每一個process都公平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Main Frame(主機)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dHbi3Pr.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102223550343&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU Scheduling採取RR的排班法則(第四章會介紹)&lt;/li&gt;
&lt;li&gt;使用Virtual Memory的技術，擴展Logical Memory Space&lt;/li&gt;
&lt;li&gt;使用Spooling的技術(不太會考)實現I/O Device的共用，類似現代的Buffering技術，讓每個user，皆以為自己有專屬的的Computer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multiprocessors-system&#34;&gt;Multiprocessors System&lt;/h3&gt;
&lt;p&gt;定義：又叫Multiprocessing or Paraller or Tightly-coupled system(緊密耦合系統)&lt;/p&gt;
&lt;p&gt;faeture：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一個機器(or MotherBoard)內，有多個Processors(or CPUs)&lt;/li&gt;
&lt;li&gt;這些CPUs彼此共享此機器的Memory,Bus,I/O-Device, power-supplier etc&amp;hellip;&lt;/li&gt;
&lt;li&gt;通常受同一Clock之時脈控制&lt;/li&gt;
&lt;li&gt;由同一個OS管理&lt;/li&gt;
&lt;li&gt;processors之間的溝通大都採shared Memory方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hvugyDq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221106193948248&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Benefits(好處)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Increased Throughput：產能增加&lt;/li&gt;
&lt;li&gt;Increased Reliability：可靠度的提升&lt;/li&gt;
&lt;li&gt;Economy Of Scale：運算能力的擴充比較好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　分析如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Increased Throughput：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可支持多個工作在不同CPU上平行執行(paraller Computing)，&lt;strong&gt;注意，N顆CPU之產能絕對小於1顆CPU產能xN倍&lt;/strong&gt;，意即CPU數量的提升與產能的提升並非線性成長。原因是因為&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Resource Contetion(資源的競爭)&lt;/li&gt;
&lt;li&gt;Processors間的Communication會抵消產能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Increased Reliability:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某一顆CPU壞了，則System不會因此而停頓，因為其他CPU仍可運作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graceful degradation(漸進式的滅亡)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;System不至因為某些Hardward/Software之元件故障而停頓，仍然保有持續運作的能力，這性質就稱為fail-soft&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Fault-Tolerant system(容錯系統)&lt;strong&gt;考試不太會考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有graceful degradation性質之系統就叫做Fault-Tolerant system，想要達成容錯的技術需要有兩件事情的支援&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;要有backup的系統，切換也要流暢&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Economy of Scale:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;運算能力擴充符合經濟效益&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;∵N顆CPU在一部機器內，與N部機器相比，成本較便宜∵這些CPUs共享同一機器之Memory, Bus, I/O-Device, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;two-subtype-in-multiprocessors-system&#34;&gt;Two SubType in Multiprocessors System&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;SMP(Symmetric MultiProcessors) 對稱的&lt;/li&gt;
&lt;li&gt;ASMP(Asymmetric MultiProcessors) 非對稱的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;SMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定義：每個Processor的工作能力是相同的(Identical)，且每個CPU都有對等、平等的權利來存取資源&lt;/p&gt;
&lt;p&gt;優點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可靠度較ASMP高，因工作能力相同，即使其中一個cpu掛了也可以被立刻取代&lt;/li&gt;
&lt;li&gt;效能較高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SMP的OS設計開發較為複雜(互斥存取的機制設計,資源的競爭)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;ASMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定義：每個Processor之工作能力&lt;strong&gt;不盡相同&lt;/strong&gt;，通常是採取&lt;strong&gt;Master-Slave&lt;/strong&gt;的架構(恐龍本有時候會寫成Boss-Employee&lt;/p&gt;
&lt;p&gt;Master-Processor負責工作分派及資源分配，監督Slaves等管理工作&lt;/p&gt;
&lt;p&gt;Slave Processors負責執行工作&lt;/p&gt;
&lt;p&gt;優點：ASMP的OS設計開發較為Simple，∵與Simple-Cpu Os版類似&lt;/p&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可靠度低，Master CPU如果壞了，就會停擺，直到另一顆CPU被Train接手&lt;/li&gt;
&lt;li&gt;效能較低∵Master CPU是瓶頸&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wo1RhWy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108212149764&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;multiprocessors-system-vs-multicores-cpu&#34;&gt;Multiprocessors System VS MultiCores CPU&lt;/h4&gt;
&lt;p&gt;從作業系統來看差異不大，主要差異是&lt;strong&gt;硬體的差異(主要)&lt;/strong&gt;，以OS來看，你裝了一顆兩核的CPU，OS會視作兩顆CPU；裝四核的視作四顆CPU&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MultiProcessors&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BhjZbvk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108214627937&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;MultiCores CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HNuJgLM.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221108214639509&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;優點&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Power Saving：相較MultiProcessor，在一個CPU上提供兩個Core的能源耗損會比在一張板子上提供兩顆CPU的能源耗損還來得低。&lt;/li&gt;
&lt;li&gt;Speed比較快(∵處在同一個晶片內資料傳輸速度較快)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;distribute-system&#34;&gt;Distribute System&lt;/h3&gt;
&lt;p&gt;定義：又叫Loosely-Coupled system(鬆散耦合系統)，主要的Feature如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;多部機器彼此透過Network(or Bus)相互串連&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每部機器之CPU有各自私有的Memory, Bus, I/O-Device, etc 並非共享&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各CPU之Clock時脈控制不一定相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各CPU上之OS也不一定相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各Processors之間的溝通大都採**&amp;ldquo;Message Passing&amp;rdquo;**方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Message Passing (類似講電話)&lt;/p&gt;
&lt;p&gt;Step&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立Communication Link&lt;/li&gt;
&lt;li&gt;Message 相互傳輸&lt;/li&gt;
&lt;li&gt;釋放Link&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/6gSkGlg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221110232152377&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;advantage-of-distribute-system&#34;&gt;Advantage of Distribute-System&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Increased Throughput(支持Paraller Computing)&lt;/li&gt;
&lt;li&gt;Increased Reliability(一個掛掉，還有其他可以擋)&lt;/li&gt;
&lt;li&gt;Resource Sharing(資源共享因此成本降低)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;支持&amp;quot;Client-Server&amp;quot; Computing Model之實施&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Server(伺服器)：提供某些服務的機器 example: mail server, file server ,DNS,printer server, computing server &amp;hellip;&lt;/li&gt;
&lt;li&gt;Client：本身不提供服務，且它需要某些服務時，則發請求至Server, Server服務完再將結果回傳Client&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;p&gt;Peer-to-Peer model：peer意指同時具有server及Client的角色，英文意思是同等的、對等的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Remote sites Communication的需求被滿足 example：email, FTP via Internet&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;real-time-system&#34;&gt;Real-Time System&lt;/h3&gt;
&lt;p&gt;(即時系統)&lt;/p&gt;
&lt;p&gt;分成兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hard real-time System&lt;/li&gt;
&lt;li&gt;Soft real-time System&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;hard-real-time-system&#34;&gt;Hard real-time system&lt;/h4&gt;
&lt;p&gt;定義：This system must ensure the critical tasks complete on time，即工作必須在規定的時間限制內完成，否則即算失敗&lt;/p&gt;
&lt;p&gt;舉例：軍事防衛系統、核能安控系統、工廠自動化生產&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cPuSbro.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221114224122357&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;設計考量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;所有時間延遲之因素皆須納入考量&lt;/strong&gt; eg：sensor data 傳輸速度、運算速度、Signal的傳輸 etc，確保這些時間的加總能夠滿足時間deadline的要求&lt;/li&gt;
&lt;li&gt;所有會造成處理時間過久或無法預測之設備或機制，盡量少採用或不用 eg：&lt;strong&gt;Disk&lt;/strong&gt;不用或少用、&lt;strong&gt;Virtual Memory 絕對不採用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;就CPU Scheduling設計(Ch4)而言，需先考量Schedulable與否，再進行排程(eg rate-monotonic, EDF scheduling)，確定CPU能負荷再進行排程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time Sharing system 無法與之並存(Time sharing是屬於Multitasking，可以同時執行多個程序，並透過一些風勢去優先執行某些程序，而Hard real-time比較像單運算系統，要求在指定時間內完成，因此更專注於單一程序的執行，由於這兩個系統有這樣的差異，因此無法共榮)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS所造成的Dispatch latency etc. 宜降低(interrupt的處理, system call的請求)，一般實務上，hard-real-time system，鮮少有OS的存在(幾乎不存在)，尤其是embedded real-time system，因需要&lt;strong&gt;及時的響應&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;現行的商用OS&lt;u&gt;不支援&lt;/u&gt;Hard real-time features 通常都是客製化的特殊設計eg : Linux, Unix, Window, Apple Os, Solaris etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h4 id=&#34;soft-real-time-system&#34;&gt;Soft real-time system&lt;/h4&gt;
&lt;p&gt;定義：&lt;strong&gt;This system must ensure the real-time process get the hightest priority than the others and retain(維持) this priority level unit it completed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舉例：Multimedia System, Simulation system, VR system, etc&lt;/p&gt;
&lt;p&gt;設計考量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就 CPU Scheduling 設計(ch4)而言，
&lt;ol&gt;
&lt;li&gt;必須支持preemptive priority scheduling&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可提供Aging技術&lt;/strong&gt;(活得越久，priority越高)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;盡量降低kernel的Dispatch latency time&lt;/li&gt;
&lt;li&gt;可支援virtual memory 並存，但前提是real-time-process的全部pages必須皆待在memory中，直到完工，高優先權的Process不要使用virtual memory&lt;/li&gt;
&lt;li&gt;與Time-sharing system 可以並存，eg：solaris&lt;/li&gt;
&lt;li&gt;一般商用OS都支援Soft-real-time system&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;batch-system&#34;&gt;Batch System&lt;/h4&gt;
&lt;p&gt;定義：將一些較不緊急，定期性、非交談互動性的Job，累積成堆，再分批次，送入系統處理&lt;/p&gt;
&lt;p&gt;舉例：庫存系統、報稅系統、掃毒、磁碟重組、清算系統&amp;hellip;&lt;/p&gt;
&lt;p&gt;主要目的：提高resource utilization，&lt;strong&gt;尤其是在冷門時段&lt;/strong&gt;，不適合用在real-time-system, user-interactive application eg：電腦遊戲&lt;/p&gt;
&lt;h4 id=&#34;hand-held--system&#34;&gt;Hand Held  system&lt;/h4&gt;
&lt;p&gt;定義：單手可掌握操作的系統&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware 天生之限制，帶來software必須配合之處&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Hardware天生限制&lt;/th&gt;
&lt;th&gt;Software必須配合之設計&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;u&gt;Slower&lt;/u&gt; processor&lt;br /&gt;(背後之限制)&lt;br /&gt;1. power 供應的問題，電供不足&lt;br /&gt;2. 散熱系統的設計&lt;/td&gt;
&lt;td&gt;運算不能太複雜，要簡單&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory空間有限&lt;/td&gt;
&lt;td&gt;程式的Size要小，不用的記憶體要立刻釋放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DisplayMonitor很小&lt;/td&gt;
&lt;td&gt;顯示的內容要有所刪減&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;chapter2-computer-system-architecture&#34;&gt;Chapter2 Computer System Architecture&lt;/h2&gt;
&lt;h3 id=&#34;io-operating-and-hardware-resources-protection&#34;&gt;I/O Operating And Hardware Resources Protection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;學習路線&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;I/O運作方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Polling I/O&lt;/p&gt;
&lt;p&gt;Interrupted I/O&lt;/p&gt;
&lt;p&gt;DMA&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Interrupt機制處理與種類&lt;/p&gt;
&lt;p&gt;HW Resource Protection&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基礎建設&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dual Model Operation&lt;/p&gt;
&lt;p&gt;Privileged Instruction&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I/O&lt;/p&gt;
&lt;p&gt;Memory Protection&lt;/p&gt;
&lt;p&gt;CPU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;io-operating&#34;&gt;I/O Operating&lt;/h3&gt;
&lt;h4 id=&#34;polling-io-io&#34;&gt;Polling I/O I/O&lt;/h4&gt;
&lt;p&gt;Polling(輪巡,詢問式) I/O&lt;/p&gt;
&lt;p&gt;定義：又叫Busy_waiting I/O or Programmed I/O&lt;/p&gt;
&lt;p&gt;步驟如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I/O Request 給 OS (執行中的Process不會自己做I/O)&lt;/li&gt;
&lt;li&gt;OS收到請求後，(可能)會暫停此Process執行，並執行對應的System Calls.&lt;/li&gt;
&lt;li&gt;Kernel 的 &lt;u&gt;I/O-subsystem&lt;/u&gt;(專門用來處理I/O的請求，只是個過水而已)會Pass此請求給&lt;u&gt;Device driver&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;Divice Driver 依此請求，設定對應的I/O Commands參數給&lt;u&gt;Device Controller&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;Device Controller 啟動監督I/O-Device之I/O運作進行&lt;/li&gt;
&lt;li&gt;在這段時間內，OS(可能)將CPU切給另一個process執行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;然而，沒人主動去告訴CPU I/O的執行狀況，因此CPU在執行process工作過程中，卻要不斷去Polling Device Controller，已確定I/O運作是否完成或有I/O error&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PrvPBLP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221116231017998&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU耗費大量時間用於polling I/O Device Controller上，並未全用於process execute上，故&lt;u&gt;CPU utilization低&lt;/u&gt;、&lt;u&gt;throughput不高&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;interrupted-io&#34;&gt;Interrupted I/O&lt;/h4&gt;
&lt;p&gt;Interrupted (中斷,中斷式)I/O I/O&lt;/p&gt;
&lt;p&gt;定義：&lt;/p&gt;
&lt;p&gt;步驟如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I/O Request 給 OS (執行中的Process不會自己做I/O)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS收到請求後，(可能)會暫停此Process執行，並執行對應的System Calls.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kernel 的 &lt;u&gt;I/O-subsystem&lt;/u&gt;(專門用來處理I/O的請求，只是個過水而已)會Pass此請求給&lt;u&gt;Device driver&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Divice Driver 依此請求，設定對應的I/O Commands參數給&lt;u&gt;Device Controller&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Device Controller 啟動監督I/O-Device之I/O運作進行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在這段時間內，OS(可能)將CPU切給另一個process執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;當I/O運作完成，Device Controller 會發出 I/O-Completed Interrupt 通知OS(CPU)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OS收到中斷後(可能)會暫停目前Process的執行(因有些Interrupt優先權可能很低，可以先暫時不處理)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OS必須查詢 &lt;u&gt;Interrupt Vector&lt;/u&gt;，確認何種中斷發生，同時也要找到該中斷的服務處理程式(ISR：Interrupt Service Routine)的位址(每一個中斷都有一個對應的中斷處理服務程式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Jump to ISR位址 執行ISR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISR完成後，return control to &lt;u&gt;kernel&lt;/u&gt;，kernel也許做一些通知工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢復(resume)原先中斷前的工作執行或交由CPU Scheduler決定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;優點：CPU&lt;u&gt;不須&lt;/u&gt;耗費時間用於Polling I/O-Device，而是可以用於Process execute上，CPU utilization提升，throughout提高，improve the system performance&lt;/p&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Interrupt之處理仍需耗費CPU time，如果 I/O運作時間 &lt;strong&gt;小於&lt;/strong&gt; Interrupt處理時間，則使用Interrupt I/O就不划算，不如使用polling I/O&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;中斷的頻率過高&lt;/strong&gt;，則大量的中斷處理會占用幾乎全部的CPU Time，則&lt;strong&gt;系統效能會很差&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CPU仍需耗費一些時間用於監督I/O-Divice與Memory之間的Data Transfer過程&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;dma-direct-memory-access-io&#34;&gt;DMA (Direct Memory Access) I/O&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;定義：DMA Controller 負責 I/O-Device(設備)與Memory 之間的Data transfer(傳輸)工作，&lt;strong&gt;過程中不需CPU之參與監督，因此CPU有更多時間用於Process execute上&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;優點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU Utilization更高&lt;/li&gt;
&lt;li&gt;適合用在&lt;strong&gt;Block-Transfer oriented &lt;strong&gt;I/O-Device上(代表中斷發生的頻率不致於過高 eg:Disk, 磁碟的控制器會和DMA的控制器兩個會相互合作，磁碟控制器會去指揮磁碟的運作，讀出來的資料會通知DMA的控制器，DMA會把資料輸進Memory裡) 不是用於&lt;/strong&gt;Byte-transger oriented I/O-Device&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引進DMA Controller會增加HW設計複雜度(Complicated the HW design)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;原因：DMA的Controller會跟CPU競爭爭奪Memory(記憶體)、Bus(匯流排)的使用權，若DMC Controller 占用了memory , Bus 時，CPU要被迫等待&lt;/p&gt;
&lt;p&gt;補充：DMA Controller通常採用&amp;quot;Cycle Stealing&amp;quot;技術 (or Interleaving)與CPU 輪番(交替)使用memory跟Bus，如果CPU與DMA Controller發生conflict(同時要用Memory 與 bus)，則會&lt;strong&gt;給DMA較高的的優先權&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;通常系統會給予「對該資源需求量、頻率等較&lt;strong&gt;小&lt;/strong&gt;」的對象有較高的優先權，這樣會獲得&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平均等待時間較小&lt;/li&gt;
&lt;li&gt;平均產能較高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;的好處&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機器指令的Stages (CPU執行的幾個階段)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IF&lt;/th&gt;
&lt;th&gt;DE&lt;/th&gt;
&lt;th&gt;FO&lt;/th&gt;
&lt;th&gt;EX&lt;/th&gt;
&lt;th&gt;WM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;IF：Instruction Fetch &lt;code&gt;抓指令：根據Programming Counter的值，到記憶體去把指令抓出來  &lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DE：Decode &lt;code&gt;解碼：知道這條指令到底做什麼事情&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FO：Fetch Operands &lt;code&gt;抓取運算元：運算元可能來自記憶體、也可能來自暫存器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ex：Execution　&lt;code&gt;執行&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WM：Write Result to Memory　&lt;code&gt;將結果寫入記憶體&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;CPU會不會Memory Access（到記憶體抓東西）&lt;/th&gt;
&lt;th&gt;DMA要用Memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IF&lt;/td&gt;
&lt;td&gt;會&lt;/td&gt;
&lt;td&gt;衝突(Conflict)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DE&lt;/td&gt;
&lt;td&gt;不會（指令已經拿出來放到IR&lt;code&gt;instructor registor&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;OK，歡迎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FO&lt;/td&gt;
&lt;td&gt;可能  (運算元有可能在Registor，也有可能放在Memory)&lt;/td&gt;
&lt;td&gt;OK，或有衝突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EX&lt;/td&gt;
&lt;td&gt;不會 (ALU去做了)&lt;/td&gt;
&lt;td&gt;OK，歡迎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WM&lt;/td&gt;
&lt;td&gt;可能 (結果有可能寫回Memory也有可能是暫存器)&lt;/td&gt;
&lt;td&gt;OK，或有衝突&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Cycle Stealing：當CPU會使用或不會使用Memory Access時，DMA都會去爭奪Memory的使用權，亦為Stealing(偷)，因為DMA擁有最高使用權。&lt;/p&gt;
&lt;h4 id=&#34;dma-six-steps&#34;&gt;DMA Six Steps&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;(早:中央、清華、交大)&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Device Driver &lt;code&gt;User Process 告訴 I/O subsystem(kernel)告訴 Device Driver&lt;/code&gt;is told to transfer Disk data to Buffer address X&lt;/li&gt;
&lt;li&gt;Device Driver tells disk controller to transfer C bytes from disk to Buffer at address X&lt;code&gt;從磁碟讀C byte的量，分配到記憶體位址X的地方&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Disk controller initiates DMA Transfer&lt;/li&gt;
&lt;li&gt;Disk controller sends each byte to DMA controller&lt;/li&gt;
&lt;li&gt;DMA transfer bytes to Buffer X in creasing memory address and decreasing Counter utill Counter =0&lt;/li&gt;
&lt;li&gt;When C=0, DMA interrupts CPU to signal transfer compeletion&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0T7eX0t.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221119122438718&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;life-cycle-of-io-request-via-interrupted-io&#34;&gt;Life cycle of I/O-request via Interrupted I/O&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nDEmUKK.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221119161000584&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;blocking-and-non-blocking-io&#34;&gt;Blocking and Non-Blocking I/O&lt;/h4&gt;
&lt;p&gt;Blocking(會暫停的) and Non-Blocking(不會暫停的)I/O&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所謂的Blocking的意思是，當User process發出I/O請求之後，接下來這個prcess就會suspend，直到這個I/O被完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;blocking-io&#34;&gt;Blocking-I/O:&lt;/h5&gt;
&lt;p&gt;(等於Synchronous)：Process suspended until I/O completeed&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;優：Easy to use and understand, process在waiting的時候，可以把CPU放出去給其他process做使用&lt;/li&gt;
&lt;li&gt;缺：Insufficient for some needs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WXgFJ0f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221119221052160&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;non-blocking-io&#34;&gt;Non-Blocking I/O：&lt;/h5&gt;
&lt;p&gt;I/O calls returns as much as available &lt;strong&gt;I/O請求發出去後，控制權立刻返回給user process&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example：user interface, data copy&lt;/li&gt;
&lt;li&gt;Implemented via multi-threading&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Returns quickly with count of Bytes read or written&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;asynchronous-io&#34;&gt;Asynchronous-I/O:&lt;/h5&gt;
&lt;p&gt;(屬於Non-blocking)：Process runs while, I/O executes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Difficult to use&lt;/li&gt;
&lt;li&gt;I/O subsystem signals process when I/O-completed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Z3p4rBK.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221119221104281&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;asynchronous與non-blocking的小差異&#34;&gt;Asynchronous與Non-Blocking的小差異&lt;/h5&gt;
&lt;p&gt;Asynchronous I/O：整個I/O完成，才通知Process&lt;/p&gt;
&lt;p&gt;Non-Blocking I/O：I/O完成Data return as much as possible (能回傳就回傳， 少量即可回傳)&lt;/p&gt;
&lt;p&gt;舉例說明：userProcess發出100 byte的I/O請求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Asynchronous的方式，會將100byte的I/O做完後，才告訴Process做完了&lt;/li&gt;
&lt;li&gt;Non-Blocking的方式，每讀25Byte就通知一次， 逐步回報給Process，會發出比較多次的Interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;interrupt-policy-and&#34;&gt;Interrupt Policy and&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;當Interrupt發生，OS之處理Steps如下：
&lt;ol&gt;
&lt;li&gt;OS收到中斷後(若此中斷要被立即處理，則OS會暫停目前Process之執行，且保存其Status and Registers Contents)&lt;/li&gt;
&lt;li&gt;OS會依照Interrupt ID(No.)查詢Interrupt Vector中斷向量表，確認何種Interrupt發生，且找出其ISR的位址&lt;/li&gt;
&lt;li&gt;Jump to ISR 位址，執行ISR&lt;/li&gt;
&lt;li&gt;ISR完成後，控制權返回Kernel&lt;/li&gt;
&lt;li&gt;OS會恢復(resume)中斷之前Process之執行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fWGVXob.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221121000410540&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Interrupt種類&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;早期恐龍分為三種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;External Interrupt：CPU以外的周邊設備、控制卡、etc，所發出的中斷&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：I/O-Completed, I/O-error, Machine-check,&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Internal Interrupt：CPU在執行Process過程中，遭遇重大錯誤而引發&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：Divide-by-zero除以零、執行非法的特權指令、etc&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Software Interrupt：user process 在執行中，若須要OS提供服務時，發出此類型的中斷，目的是&lt;strong&gt;通知作業系統&lt;/strong&gt;，請它執行對應的服務請求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：I/O-request &lt;code&gt;好比是KTV的服務鈕，按下去就會有人過來問你要幹嘛&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;現在恐龍分為兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Interrupt：硬體所產生就叫Interrupt&lt;/li&gt;
&lt;li&gt;Trap：軟體所產生的就叫Trap&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gw1lwWA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221121003713007&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例：設備發出I/O-Completed,I/O-Error,Machine-check,etc及Time-out by Timer&lt;/p&gt;
&lt;p&gt;用途主要有二&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Catch the arithematic  error&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：Divide-by-zero, 執行非法特權指令, illegal memory access&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user process 執行需要OS提供服務時，也會發trap通知OS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：I/O　Request&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分成兩類&lt;code&gt;背後哲學：中斷之間也有優先權高低之分&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;Maskable Interrupt遮罩：此類中斷發生後，可被Ignored或&lt;strong&gt;延後處理不一定要馬上處理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;例如：Software-interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-Maskable不可遮罩：此類中斷必須立刻處理
&lt;ul&gt;
&lt;li&gt;Internal interrupt(重大error), I/O-error,etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hardware-resources-protection&#34;&gt;Hardware Resources Protection&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基礎建設
&lt;ul&gt;
&lt;li&gt;Dual-modes operation(雙重模式)&lt;/li&gt;
&lt;li&gt;Privilege instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dual-modes-operation&#34;&gt;Dual-modes operation&lt;/h4&gt;
&lt;p&gt;定義：System之運作模式&lt;strong&gt;至少&lt;/strong&gt;(可再往下分，依照系統設計的必要性)可被區分為2種modes&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;kernel mode&lt;/li&gt;
&lt;li&gt;user mode&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;kernel mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又叫做system mode, supervisor mode, privileged mode, monitor mode(早期有，現移除)，代表此刻是kernel取得系統控制(取得CPU執行權)，&lt;strong&gt;允許&lt;/strong&gt;privilege instructions(特權指令)在此mode下執行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;user mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代表user process取得CPU執行，在此mode,&lt;strong&gt;不允許&lt;/strong&gt;執行privilege instructions(特權指令)，若執行則會發生trap的重大錯誤&lt;/p&gt;
&lt;p&gt;此外，&lt;strong&gt;Dual-modes必須要有HW的支持&lt;/strong&gt;，才可實現&lt;/p&gt;
&lt;p&gt;例如：CPU內會有Mode Bit，用以區分現在是哪個mode&lt;code&gt;當CPU在執行機器指令時，IF、DE...之類的階段，若解碼完發現是個特權指令，這時候Control unit就要檢查目前的mode bit，判斷是否可不可以執行，若不行就丟出一個interrupt，不允許執行&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;priveleged-instruction特權指令&#34;&gt;Priveleged instruction(特權指令)&lt;/h4&gt;
&lt;p&gt;定義：任何可能會造成系統重大危害的指令，可設為特權指令(端看工程師如何設計)，&lt;strong&gt;只可以&lt;/strong&gt;在Kernel Mode去執行，不可以再User mode下執行，一旦在User Mode下執行，會發&lt;strong&gt;Trap&lt;/strong&gt;通知OS，將此user process terminates.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果把所有的指令設為特權指令，好處就只有超級安全，因為這些指令都只有OS可以做，如果user想做就只能委託OS執行，但這樣performance會很差，因為所有事情都要給OS處理&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Turn-off(Disable) interrupt, clear memory, I/O instruction(for I/O protection),Timer值 set/change (for CPU protect)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Base/Limit register 修改/set (for memory protection)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Change mode from user mode to kernel mode&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1). Set value of Timer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2). Read the clock
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3). Claer memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4). Turn-off interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5). Switch from user to monitor mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;哪些是特權指令?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1,3,4,5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. Change to user mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. Change to monitor mode
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. Read from monitor memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4. Write into monitor memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5. Fetch an instruction from memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6. Turn on timer interrupt 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7. Turn off timer interrupt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;哪些是特權指令?
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2,4,7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;詳解：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6. 本身就是打開的，因為要做CPU的保護
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7. 但關掉不是
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;有爭議的部分
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. user process去讀kernel process的資料，恐龍認為是，因為kernel裡面掌管所有Process的information，而process間不應該各個process的狀態
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5. 從Monitor memory(Kernel)裡面去讀指令出來，恐龍認為不是，因為就算抓了，但你的mode不是Privilege instruction就會把你擋掉
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;為什麼dual-mode跟privilege-isntruction可以構成保護基礎&#34;&gt;為什麼Dual-mode跟Privilege Isntruction可以構成保護基礎&lt;/h4&gt;
&lt;p&gt;所有會危害OS的操作都是在Kernel 發生，因此不可以放任user可以直接操作Kernel&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ouBgLdK.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221122221832833&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;io-protection&#34;&gt;I/O-Protection&lt;/h4&gt;
&lt;p&gt;目的：由於I/O運作較為繁瑣複雜，為了&lt;strong&gt;降低user processes 操控I/O之複雜度&lt;/strong&gt;`，讓user processes去處理應用的問題，I/O則交由OS去處理；及避免user process對I/O-Devices之不當操作，胡搞瞎搞，因此才有I/O protection。簡單來講就是不要讓user processes去操作I/O&lt;/p&gt;
&lt;p&gt;作法：把所有I/O指令皆設為privileged instruction配合Dual-modes, 一律讓user process委託 kernel執行I/O運作&lt;/p&gt;
&lt;h4 id=&#34;memory-protection&#34;&gt;Memory Protection&lt;/h4&gt;
&lt;p&gt;目的：防止user process 存取其他user processes 之 memory area 及 kernel memory area&lt;/p&gt;
&lt;p&gt;作法：(以 contiguous Memory Allocatation 為例) 針對每個Process, kernel會提供一套Registers：叫base/limit register, 其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base register紀錄Process之&lt;strong&gt;起始位址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Limit register紀錄Process之&lt;strong&gt;大小&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;將來Process執行，會進行下列的Checking&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Ys8xRSh.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221122234041249&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;為什麼Address的判斷是由Hardware來做而不是OS來做呢？&lt;/p&gt;
&lt;p&gt;因為交給OS來做就會產生中斷interrupt，又因程式在執行的時候對記憶體的存取是很頻繁的，兩個影響之下會導致你的CPU一直被interrupt打擾，因此交給Hardware來做會比較符合成本一點。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;並且，還要將 Base與Limit register 值之set/change須設為&amp;quot;Privilege Code(特權指令)&amp;quot;，避免user Process把Base跟Limit的位址直接改成無限，這樣就完成了Memory的&lt;strong&gt;Protection&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;cpu-protection&#34;&gt;CPU Protection&lt;/h4&gt;
&lt;p&gt;目的：防止user process無限期/長期佔用CPU而不釋放&lt;/p&gt;
&lt;p&gt;作法：利用&lt;strong&gt;Timer&lt;/strong&gt;實施，同時OS會規定Process使用CPU time之最大配額值(MAX. Time Quantum)&lt;/p&gt;
&lt;p&gt;當process 取得CPU後，Timer初值即設為Max Time Qauntum值，隨著Process執行 time增加, &lt;strong&gt;Timer值會逐步遞減&lt;/strong&gt;，直到Timer值為0,  Timer會發出 &lt;strong&gt;Time-out&lt;/strong&gt;的interrupt通知OS，OS便可強迫此process放掉CPU，此外，Timer值之set/change 也須設為特權指令&lt;/p&gt;
&lt;h3 id=&#34;os-structure-operating-system&#34;&gt;OS Structure Operating-System&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;OS之Development&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OS應提供的服務項目&lt;/p&gt;
&lt;p&gt;OS之&lt;strong&gt;服務元件&lt;/strong&gt;種類&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Calls之介紹&lt;/strong&gt;(使用者程式跟OS之間溝通的介面)&lt;/p&gt;
&lt;p&gt;OS之Structure種類&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simple&lt;/p&gt;
&lt;p&gt;More Complex than simple&lt;/p&gt;
&lt;p&gt;Layered Approach&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Microkernel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Module&lt;/p&gt;
&lt;p&gt;Hybrid(混合?)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;設計原則：Policy與Mechanism &lt;code&gt;policy管行為,比較常變，例如數值的變動; mechanism負責處理how,比較不會變,例如邏輯的判斷 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Virtual Machine介紹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;system-call&#34;&gt;System Call&lt;/h4&gt;
&lt;p&gt;定義：作為執行中user process與kernel之間的溝通界面，當user process需要OS提供某種服務時，會先trap通知OS，並帶入&lt;strong&gt;System call&lt;/strong&gt; ID(No)及&lt;strong&gt;所需參數&lt;/strong&gt;，然後OS執行對應的System call&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a programming Interface to the services privided by the OS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用舉例來講的話&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trap = 服務紐&lt;/li&gt;
&lt;li&gt;System call = 服務項目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;System Call的種類(中央考過類似的題目)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Process Control eg：建立、終止、暫停、恢復執行process, set/read attribute&lt;/li&gt;
&lt;li&gt;File Management eg：建立、read, write, open, close, delete &amp;hellip;&lt;/li&gt;
&lt;li&gt;Device Management eg：建立、read, write, open, close, delete &amp;hellip;&lt;/li&gt;
&lt;li&gt;Information of Maintenance eg：取得系統日期/時間、取得Process屬性 etc&lt;/li&gt;
&lt;li&gt;Communications eg: Processes之間的通訊而且只針對Message Processing方式提供服務&lt;/li&gt;
&lt;li&gt;Protection　eg: Hw resources protection, File access contorller, etc&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VvdLNs0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221124224120796&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;System Call的參數(Parameters)傳遞方式：3種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用暫存器(&lt;strong&gt;Registers&lt;/strong&gt;)保存參數
&lt;ul&gt;
&lt;li&gt;優點：
&lt;ol&gt;
&lt;li&gt;最簡單&lt;/li&gt;
&lt;li&gt;存取速度最快( without memory access)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺點:
&lt;ol&gt;
&lt;li&gt;不適用於大量參數之情況&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用&lt;strong&gt;Memory&lt;/strong&gt;，以一個Block(Table)儲存這些參數，並將這些表格的起始位址置於1個Register中，Pass給OS
&lt;ul&gt;
&lt;li&gt;優點:
&lt;ol&gt;
&lt;li&gt;適用於大量參數&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺點:
&lt;ol&gt;
&lt;li&gt;存取速度較慢，且操作較為麻煩&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用&lt;strong&gt;Stack&lt;/strong&gt;將參數push入此Stack, OS再pop from stack, 以取得參數
&lt;ul&gt;
&lt;li&gt;優點:
&lt;ol&gt;
&lt;li&gt;適用於大量參數之情況&lt;/li&gt;
&lt;li&gt;也很簡單&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺點:
&lt;ol&gt;
&lt;li&gt;Stack的空間須要預先準備，避免stackoverflow&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;os之系統架構分類&#34;&gt;OS之系統架構分類&lt;/h4&gt;
&lt;p&gt;OS之Structure種類&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simple: MS-DOS系統&lt;/p&gt;
&lt;p&gt;More Complex than simple: UNIX系統&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Limited by Hardware functionality&lt;/li&gt;
&lt;li&gt;The original UNIX had limited structuring&lt;/li&gt;
&lt;li&gt;The UNIX 包含兩個Separate parts
&lt;ol&gt;
&lt;li&gt;System Programs&lt;/li&gt;
&lt;li&gt;The Kernel&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/luyuYF4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221125013311284&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Beyond simple but not fully layered&lt;/strong&gt;(分層)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Layered Approach&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：採取&lt;strong&gt;Top-Down&lt;/strong&gt;方式，切割系統功能/元件，以降低複雜度。元件/模組之間呼叫關係分層&lt;/p&gt;
&lt;p&gt;即&lt;strong&gt;上層可以使用下層的功能，但下層不可以使用上層的功能&lt;/strong&gt;。完成後要使用&lt;strong&gt;Bottom-up&lt;/strong&gt;方式進行測試，debugging(由底層一路往外測)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;層次的劃分沒有明確規定&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/dkCQyVV.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221125014733544&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;優點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低設計複雜度&lt;/li&gt;
&lt;li&gt;有助於分工&lt;/li&gt;
&lt;li&gt;測試、除錯、維護容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很難做到精準的分層劃分&lt;/li&gt;
&lt;li&gt;若Layer數太多，則System performance is very poor( 切到四層剛好、五層太多，極限中的極限是七層)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Microkernel&lt;/strong&gt;(微核心)：由CMU(卡內基-美隆大學)率先提出，代表產品：&lt;strong&gt;Mach o.s&lt;/strong&gt;。它們認為UNIX的服務項目太多、太龐大，不利移植&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義：將Kernel中一些Non-essential services&lt;code&gt;(比較不是那麼基本、重要、必要)&lt;/code&gt;，自Kernel當中移除，改成在User Mode(Site)提供這些服務，以System programs方式存在，如此一來，可以得到一個比較小的kernel，稱之為microkernel, 一般而言，Microkernel提供下列三個minimum service：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Porcess Controll&lt;/li&gt;
&lt;li&gt;Memory Management(不包括Virtual memory)&lt;/li&gt;
&lt;li&gt;Process Communications(提供message Processing服務而已)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/R7XWIb1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221126165547853&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Benefits(好處)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Easier to extend a microkernel
&lt;ul&gt;
&lt;li&gt;服務的增加/刪除是容易的，&lt;strong&gt;因為這些服務是在user site執行&lt;/strong&gt;，所以服務的增、刪不需要牽扯到Kernel也要變更，即使要，也是少量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Easier to port the OS to new architectures
&lt;ul&gt;
&lt;li&gt;因為Kernel很小，所以移植到新的硬體平台之更改幅度不大(因為只有三個服務run在kernel)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;More Reliable
&lt;ul&gt;
&lt;li&gt;萬一某一個服務在執行中掛掉了，充其量只是相當於一個user process死掉而已，所以對HW, kernel, 其他user process沒有不良影響，因為把大部分的服務移到user mode去做了，因此更加安全、可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;More secure
&lt;ul&gt;
&lt;li&gt;萬一某一個服務在執行中掛掉了，充其量只是相當於一個user process死掉而已，所以對HW, kernel, 其他user process沒有不良影響，因為把大部分的服務移到user mode去做了，因此更加安全、可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;缺點&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Performance overhead of user space to kernel space communication(效能較差)，因為process Communication充斥大量訊息傳遞&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Note：microkernel的&lt;strong&gt;相反詞&lt;/strong&gt;：&lt;strong&gt;Monolithic kernel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定義：所有的Services皆須Run in kernel mode，大部分的商用OS幾乎都是Monolithic kernel，因為如果把所有的service移到user site去做，那它的控制就會很低。當這個控制力很低的時候，user或program就可以自己去Inhence一些東西，影響OS&lt;/p&gt;
&lt;p&gt;優點、缺點：和microkernel相反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Module&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Many OS implement &lt;strong&gt;loadable&lt;/strong&gt;(有需要才載入) kernel modules&lt;/li&gt;
&lt;li&gt;use Object-oriented approach&lt;/li&gt;
&lt;li&gt;Each core  component is &lt;strong&gt;separate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Each talks to the others over known interface&lt;/li&gt;
&lt;li&gt;Each is  loadable as heeded within the Kernel&lt;/li&gt;
&lt;li&gt;簡而言之：similar to Layers but with &lt;strong&gt;more flexible, 效能更好&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/epQ0WDz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221126173047816&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例如：Linux, solaris, etc &amp;hellip;&lt;/p&gt;
&lt;p&gt;Hybrid(混合?)：現在作業系統很難純粹歸屬於某一型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;(中央考過) and Solaris 是 Monolithic (所有東西都run在kernel mode)，且也是&lt;strong&gt;Modular for dynamic loading&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例：windows mostly monolithic，有時針對不同客戶需求，會再加上microkernel for subsystem&lt;/li&gt;
&lt;li&gt;例：Apple Mac Os 也是混合的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kernel 包含&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mach microkernel&lt;/p&gt;
&lt;p&gt;部分的BSD UNIX&lt;/p&gt;
&lt;p&gt;I/O Kit&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dynamic Loadable module(叫做 kernel extension)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5JwG18g.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221126175630716&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;virtual-machine&#34;&gt;Virtual Machine&lt;/h4&gt;
&lt;p&gt;定義：利用sofeware技術模擬出一份與底層HW一模一樣的功能介面之抽象代理器(abstract machine)，稱之Virtual Machine&lt;code&gt;模擬的方式類似於CPU schdueling &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;名詞解析：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;：undelying hardware system, os&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VMM(Virtual Machine Manage)或Hypervisor&lt;/strong&gt;：creates and managing/ runs virtual machines&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guest&lt;/strong&gt;：process provided with virtual copy of the host&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;恐龍本之其他英文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstract hardware of a single computer into several different execution environments&lt;/li&gt;
&lt;li&gt;Similar to layered approach, But layer crates virtual machine(VM)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;優點&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作為測試開發中的OS，提供一個良好的負載平台，具有下列好處：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其他user, user processes工作，仍可持續運作，不須暫停&lt;/li&gt;
&lt;li&gt;萬一測試中的OS不穩定、掛掉/失敗了，也不會影響host Hw, OS, 其他user  processes 之工作，因為只是相當於一個user process fails而已，不會對system有重大危害&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cxdDMTi.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221126221141028&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;同一部Host Hardware上可以執行多個OS running on 多個virtual machines，&lt;strong&gt;這樣可以節省成本&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consolidation(合併)&lt;/strong&gt;：在 Cloud computing environment，我們會用&lt;strong&gt;有限的&lt;/strong&gt;機器，建立為數注眾多的virtual machines，我們可以依VM上的Applications之執行負擔輕重，&lt;strong&gt;調用Host machines資源，做因應的支援&lt;/strong&gt;，有需要就在加開，沒需要就關掉，做資源的合併與調度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VM較為安全(如果VM被病毒入侵，不致擴散，因為各VM之間是相互獨立的)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以Freeze, suspend, running VM, 及Clone(複製) VM&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wQovoui.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221126223550540&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;VMM的Implementation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hypervisor : 虛擬機管理程式&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Type0 Hypervisor(硬體層次)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Hardware&lt;/strong&gt;-based solutions via firmware
&lt;ul&gt;
&lt;li&gt;例如：IBM LPARS and Oracle LDOMs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type1 Hypervisor(Kernel Mode層次)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OS-like software&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例：&lt;strong&gt;VMware ESX&lt;/strong&gt;, Joyent SmartOS, Crtrix XenServer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;general purpose OS that provide VMM  functions (services)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如Microsoft Window Server with HyperV, Redhat Linux with KVM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type2  Hypervisor(user mode層次)：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Applications&lt;/strong&gt; level provides VMM functionality&lt;/p&gt;
&lt;p&gt;eg. &lt;strong&gt;Paraller&lt;/strong&gt; &lt;strong&gt;Desktop&lt;/strong&gt;, Oracle VirtualBox&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;還有一些其他的&lt;strong&gt;變形&lt;/strong&gt;&lt;code&gt;上面那三類都是要創造跟底層硬體(Host HW)一樣的Virtual Machine，但下面這些卻不是&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paravirtualization☆考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The guest OS need modify to work in cooperation with VMM to optimize performance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;presents guest(run 在virtual Machine上的都叫guest) with similar but Not identical to Host Hardware&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Guest &lt;strong&gt;must be modified(必須要被修改才可以用)&lt;/strong&gt; to Run ON Paravirtualization virtual hardware&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Programming-environment virtualization&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VMMs do not virtualize, HW but instead &lt;strong&gt;create on optimized virtual system .&lt;/strong&gt;(創造全新的Virtual Machine)&lt;/p&gt;
&lt;p&gt;eg. Java virtual machine(JVM), Microsoft .NET&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM is a SPECification(規格), not an implementation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;規範&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Class Loader(把bype code load下來)&lt;/li&gt;
&lt;li&gt;Class verifier(驗證器，驗證byte Code安不安全，比如是否包含pointer)&lt;/li&gt;
&lt;li&gt;Java interpreter(執行byte code)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gZivz4w.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221128233907844&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Emulators&lt;/strong&gt;：Allow application written for one HW to run on a very different HW such as different  type of CPU。例：PS4模擬器、3DS模擬器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Application containment (底層沒有Virtual Machine，而是 創造執行環境，而不是模擬)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eg. Oracle Solaris Zones BSD Jails, IBM AIX WPARs application&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EVk8fjP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221127130242062&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Policy(政策、策略 ) 與 Mechanism&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Policy定義&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;What&amp;rdquo; to be proovided&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;經常改變、朝令夕改&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mechanism定義&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;How to do that&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The underlying(基本的) mechanism甚少改變或不變&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設計原則：&lt;/p&gt;
&lt;p&gt;Policy與Mechanism宜separate，以增進system flexibility&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;舉例&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;     + 運用Timer作為CPU protection &amp;gt; Mechanism 
     + Max.Time Quantum大小制定 &amp;gt; Policy

  2. 

     + CPU排版採Priority Scheduling 排班 &amp;gt; Mechanism
     + Priority大小之定義 &amp;gt; Policy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chapter4--process-management-and-thread-management&#34;&gt;Chapter4  Process Management And Thread Management&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Process 定義與Progeam比較&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCB內容 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process State Transition Diagram (S.T.D)考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scheduler的種類(解釋名詞)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;長期&lt;/p&gt;
&lt;p&gt;短期&lt;/p&gt;
&lt;p&gt;中期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Context Switching (解釋名詞)&lt;/p&gt;
&lt;p&gt;Dispatcher, Dispatch latency(較少考)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process Controller Operations(UNIX, System Call為主的程式追蹤) 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;評估CPU Scheduling 效能的好或不好的5個Criteria(清大喜歡考)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各種CPU 排班法則(7個)介紹及相關名詞(Starvation,Aging,Preemptive,Non-preemptive,Convoy effect) 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特定System的排班設計&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MultiProcessors System&lt;/p&gt;
&lt;p&gt;Real-time System&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Soft (考申論題)&lt;/p&gt;
&lt;p&gt;Hard(考計算題)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thread Management&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;process-definition&#34;&gt;Process Definition&lt;/h3&gt;
&lt;p&gt;定義：A program in execution[恐]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Process 建立後，其主要組成有：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Process No(ID)&lt;/strong&gt;: Process被生成出來時，會有一個Process Id，作為識別&lt;/li&gt;
&lt;li&gt;Process State&lt;/li&gt;
&lt;li&gt;Code Section, Data Section：Process占用的 Memory Space&lt;/li&gt;
&lt;li&gt;Programming Counter(PC)：程式計數器，告訴我們現在這個Process執行到哪裡，裡面放下一條指令的位址&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;CPU Register value&lt;/li&gt;
&lt;li&gt;是OS 分配 **Resource(CPU,I/O-Divice, Memory) **之對象單位：跟Thread的差別&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;與Program(程式)的比較&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;Program&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;執行中的程式&lt;/td&gt;
&lt;td&gt;Just a &lt;strong&gt;File&lt;/strong&gt; stored in storage device&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ldquo;Active&amp;rdquo; entity(活動中、執行中)&lt;/td&gt;
&lt;td&gt;&amp;ldquo;Passive&amp;rdquo; entity(沒有活動的)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;process-control-block&#34;&gt;Process Control Block&lt;/h3&gt;
&lt;p&gt;(PCB內容)&lt;/p&gt;
&lt;p&gt;定義：OS為了管理所有Processes，會在Kernel memory中，替每個Process，各自準備一個Block(Table, 表格)，用來記錄Process之所有相關資訊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCB的主要內容有(要背，考選擇)：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Process No(ID)：是Unique(唯一的)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Process state：eg. ready, running, wait, etc&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Programming Counter：內放 the next instruction&amp;rsquo;s address&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**CPU Registers：eg. 紀錄使用到的暫存器的值 eq. Accumulator, PSW(Process Status Word), Stack  Top ,etc **&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU Scheduling Info：eg. Process 的優先權，First-In First-Out(FIFO)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Memory Management Info(隨OS的記憶體管理方法不同，紀錄不同資訊)：eg. Base/Limit register或 Page Table 或 Segment Table&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Accounting Info：eg. Process已使用了多少CPU Time, 哪些資源, 還剩多少資源,多少CPU Time可以用&lt;/strong&gt;
Note：目的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;計算使用量，記帳、收＄&lt;/p&gt;
&lt;p&gt;Administrator 調教Performance的依據&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;I/O Status Info：eg. process已經發出多少I/O-Request, 完成 狀況如何，占用那些I/O Resource(目前還沒釋放的)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;process-state-transition-diagram&#34;&gt;Process State Transition Diagram&lt;/h3&gt;
&lt;p&gt;狀態轉換圖(S.T.D)&lt;/p&gt;
&lt;p&gt;目的：描述Process之Life Cycle，用來記錄Process建立，到它被終止之間，所發生的事&lt;/p&gt;
&lt;p&gt;各個版本的STD定義都不太一樣&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;[恐] 5個State的STD&lt;/li&gt;
&lt;li&gt;[Stalling]7個State STD (比恐龍多兩個狀態)&lt;/li&gt;
&lt;li&gt;[Stalling] UNIX的STD&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;5-steps-of-state-transition-diagram&#34;&gt;5 Steps of State Transition Diagram&lt;/h4&gt;
&lt;p&gt;要會畫，會說明，超基礎，考出來是送分題&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WlbrMCp.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221204010203958&#34;
	
	
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;New(Create)&lt;/td&gt;
&lt;td&gt;Process被建立，已分得PCB的空間，&lt;strong&gt;尚未載入記憶體、未取得記憶體資源&lt;/strong&gt;，因應Batch的系統&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ready&lt;/td&gt;
&lt;td&gt;Process在記憶體了，且OS已經把它&lt;strong&gt;放到Ready Queue內，且具有資格爭奪CPU&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Running&lt;/td&gt;
&lt;td&gt;Process取得CPU 執行中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Wait(Block)&lt;/td&gt;
&lt;td&gt;表示Process待在waiting Queue中，Waiting For I/O-Completed or event occurs, &lt;strong&gt;不會與其他Processes 競爭CPU&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exit(Terminate)(Zombie)(Abort)&lt;/td&gt;
&lt;td&gt;Process完成工作，&lt;strong&gt;正常結束&lt;/strong&gt;或&lt;strong&gt;異常終止&lt;/strong&gt;，可能其PCB尚未回收，因為要等其&lt;strong&gt;父親(Parent Process)Collect 該子process之成果後&lt;/strong&gt;，才會回收PCB Space其他資源(Memory, CPU, I/O-Devices)已回收&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transition&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;也叫Admit，當Memory Space足夠時，可由&lt;strong&gt;Long-term Scheduler(in Batch System，因為放在Job Queue裡頭)，決定將此Job載入到Memory中&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;也叫&lt;strong&gt;Dispatch&lt;/strong&gt;,由short-term scheduler(CPU Scheduler)決定，讓高優先權的Process取得CPU控制權&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;也叫&lt;strong&gt;Time-Out/Interrupt&lt;/strong&gt;，執行中的Process會因某些事件發生而&lt;strong&gt;被迫放棄(不是自願的)CPU，回去Ready Queue, eg. Time-Out, Interrupt發生,更高優先權的Process到達，插隊&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;叫wait for I/O-Completed or event occurs(自願放棄CPU)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;I/O-Completed 或 Event occurs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;Process完工或異常終止 (自願放棄CPU)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;7-steps-of-state-transition-diagramstalling&#34;&gt;7 Steps of State Transition Diagram[Stalling]&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;補上Middel Term Scheduler&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;為了解決一個問題&lt;/p&gt;
&lt;p&gt;&lt;code&gt;當記憶體被占滿了，有一個更高優先權的Process近來，該如何處理？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把wait狀態的process踢出去，放到磁碟去保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3fqSWLb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221204120509402&#34;
	
	
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;State&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Blocked/Suspend&lt;/td&gt;
&lt;td&gt;Process被Swap Out到 Disk中暫存，即Blocked(asleep) in Disk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ready/Suspend&lt;/td&gt;
&lt;td&gt;event occurs or I/O-Completed, &lt;strong&gt;READY IN DISK&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transition&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Suspend(Swap Out)&lt;/td&gt;
&lt;td&gt;當Memory空間不足，又有其他高優先度的Process需更多Memory空間時，會由Medium-Term Scheduler決定將Blocked Process或低優先權的Process Swap out到Disk，以空出Memory Space&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Activate(Swap In)&lt;/td&gt;
&lt;td&gt;當Memory space有空，Medium-term scheduler可將它們Swap In回memory中，Ready for execution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Suspend(Swap Out)&lt;/td&gt;
&lt;td&gt;支持此Transition之理由有二&lt;br /&gt;1.所有Blocked Processes皆Swap out後，Memory Space仍不足時&lt;br /&gt;2. 所有Blocked State Processes之優先權，皆高於Ready State Process時&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/t6Albzn.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221204120421430&#34;
	
	
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transition&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;把從在磁碟睡覺的process拉到記憶體裡面睡覺，&lt;code&gt;This is a poor design，但仍可支持，理由如下：若所有&lt;/code&gt;Blocked/suspend` state之Processes優先權皆高於ready/ suspend processes, 且OS believes them will become ready soon&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;It&amp;rsquo;s also a poor design 但可支持之理由如下：若有一個高優先權的process從blocked/suspend變成ready/suspend時，則OS可以強迫低優先權但已執行的process放棄CPU的使用以及Memory的空間，供高優先權使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;unix-stdstalling&#34;&gt;UNIX STD[Stalling]&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OWW8dof.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221204131334041&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;scheduler-typeimportant&#34;&gt;Scheduler Type(Important)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Long-term Scheduler&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義：又叫Job Scheduler，目的是從Job Queue中挑選一些Jobs載入到Memory中&lt;/li&gt;
&lt;li&gt;特色：
&lt;ol&gt;
&lt;li&gt;執行頻率最低，所以才叫長期&lt;/li&gt;
&lt;li&gt;可以調控Multiprogramming Degree&lt;/li&gt;
&lt;li&gt;可以調控 I/O-Bound Job與CPU-Bound Job之混合比例(下面有解釋)&lt;/li&gt;
&lt;li&gt;Batch System採用，但是real-time system以及time-sharing不會採用這種機制。因為real-time系統處理的process都是比較緊急的，因此就需要直接丟進memory去執行。而time-sharing系統要求對每一個user公平，沒有優先度需要處理，如果memory不夠則調用virtual memory，因此time-sharing系統只存在medium-term以及short-term&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Short-term Scheduler：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義：又叫&lt;strong&gt;CPU Schduler&lt;/strong&gt;或&lt;strong&gt;Process Scheduler&lt;/strong&gt;，目的是從&lt;strong&gt;Ready Queue&lt;/strong&gt;中挑出一個高優先權的process，分派CPU，給CPU執行&lt;/li&gt;
&lt;li&gt;特色：
&lt;ol&gt;
&lt;li&gt;執行速度是三者裡面最高的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;無法調控Multiprogramming Degree，因為它不是負責將程式load進memory與Swap out出去的人&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;無法調控I/O-Bound Job與CPU-Bound Job之混合比例，頂多決定誰要先做，不能決定比例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的 System採用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Medium-term Scheduler(最常被考)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：&lt;strong&gt;Time-Sharing System採用&lt;/strong&gt;，當&lt;strong&gt;Memory空間不足&lt;/strong&gt;，且&lt;strong&gt;又有其他高優先權Processes需要Memory Space時&lt;/strong&gt;，此Scheduler會啟動，它會挑選一些Processes(eg. Blocked Process, 低優先Process) 將其Swap Out到Disk中，保存，以空出Memory Space，供其他Process使用，將來等到有足夠的Memory Space released後，此Scheduler可再將它們Swap In 回Memory, ready for execution&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特色：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;執行速度是三者裡面居中的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可以調控Multiprogramming Degree，因為它不是負責將程式load進memory與Swap out出去的人&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可以法調控I/O-Bound Job與CPU-Bound Job之混合比例，頂多決定誰要先做，不能決定比例&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Time-Sharing System採用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Multiprogramming Degree：系統內的Process的數目：一般而言，Degree越高，CPU利用率就越高。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;io-bound-job與cpu-bound-job&#34;&gt;I/O-Bound Job與CPU-Bound Job&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I/O-Bound(受限) Job&lt;/p&gt;
&lt;p&gt;定義：此類型工作大都是需要大量的I/O operation(resource)，但對於CPU Time(Computation)需求很少，&lt;strong&gt;因為其工作效能受限於I/O-Device之速度，稱之I/O-Bound&lt;/strong&gt;，對CPU有最高優先權，因為它占用CPU的時間最短&lt;/p&gt;
&lt;p&gt;例如：Data Base Management, 財報的處理列印&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU-Bound(受限) Job&lt;/p&gt;
&lt;p&gt;定義：需要大量的CPU計算，產生數筆資料，對I/O有最高優先權，因為它占用CPU的時間最短&lt;/p&gt;
&lt;p&gt;例如：氣象預估、科學模擬&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如果OS發現I/O-Bound過多，則會透過Schduler來調控兩者之間的比例&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;context-switching&#34;&gt;Context Switching&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：當CPU要從Running Process切給另一個Process使用之前，Kernel必須**保存(Store) Running Process的目前狀態資訊(eg. Programming Counter的值，Stack的值，CPU Register的值，etc)，即存回此Process之PCB **。且要載入(restore)另一個Process之狀態資訊from此Process PCB，&lt;strong&gt;這樣的行為就叫做Context Switching&lt;/strong&gt;，Context Switch本身是一個額外的負擔，因為需要花CPU的時間去做切換，不能用在Process的執行上，因此時間大多取決於硬體的因素居多(eg. Register的數量夠不夠，Memory存取指令速度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何將低Context Switching負擔&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果Register的數量足夠多，則可以讓每一個Process皆有自己的(Private) Register Set，OS只要切換Point指向另一個process之Register Set 即可完成Context Swtitching without memory store/restore ，因為速度夠快。但這個方法不太切實際，因為Register的成本關係&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;Multithreading&lt;/strong&gt;機制。&lt;/li&gt;
&lt;li&gt;讓System process及User Process各自擁有自己的Register set，如此兩者之切換只要Registers Set的Pointer即可&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dispatcher-and-dispatch-latency&#34;&gt;Dispatcher And Dispatch Latency&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;分派器與分派延遲&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：Dispatcher，此一模組的目的是要將CPU控制權授予經由CPU Scheduler依據CPU排班法則所選出之Process，選好後CPU Scheduler會將工作交給CPU Dispatcher，主要的工作項有下列三項&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Context Switching&lt;/li&gt;
&lt;li&gt;Change Mode from to Kernel mode to User Mode&lt;/li&gt;
&lt;li&gt;Jump to the execution entry of that selected proces&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述這三個工作所耗費的時間總和就是&lt;strong&gt;Dispatch Latency&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希望&lt;strong&gt;Dispatch Latency越短越好&lt;/strong&gt;，這些Process可以盡早開工&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;process-control-operations&#34;&gt;Process Control Operations☆☆☆☆☆&lt;/h3&gt;
&lt;h4 id=&#34;lession-1-theory&#34;&gt;Lession 1 Theory&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：Process建立、終止、暫停、恢復執行、設定／修改／讀取 Process Attributes值 etc.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述這些皆是OS應該提供的服務(i.e System Call)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Procss是可以建立自己的Process(Child Process)，&lt;strong&gt;目的是要Child Process做工作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Child Process所做的工作，可以分為2類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;與Parent 相同的工作(子承父業)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特定工作(與Parent不同)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parent與Child之間的互動關係為：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Concurrent execution(交錯使用，通常是執行第一類的工作(子承父業))&lt;/li&gt;
&lt;li&gt;Parent waits for Child until child terminated(等著收割Child的成果)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Child Process 所須的資源由何處取得?&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;OS供應&lt;/strong&gt;(這種情況OS會去限制每個process最大可產生多少個Child Process)&lt;/li&gt;
&lt;li&gt;Parent供應(整個家族Process的資源都是共享，Parent Process的Sharing Time有一小時，那麼整個家族的Sharing Time 就是一個小時&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parent 若終止，則Child Process會如何處理?&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一併終止(最常被使用)&lt;/strong&gt; ：稱之為Cascading(層疊的) termination&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parent Process死了，但Child Process存活，那Child的資源由以下兩者提供&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;向OS取得資源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向祖先Process取得資源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lession-2-example---unix-system-call&#34;&gt;Lession 2 Example - UNIX System Call&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;fork()：此System call. 用以建立 Child Process，而fork()之傳回結果，對象如下&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;失敗：因為資源不足&lt;code&gt;(記憶體不夠，PCB也不夠)&lt;/code&gt;，無法建立，&lt;strong&gt;會傳回負值(-1)給OS, then Pass to parent process&lt;/strong&gt;，通常失敗的話，OS也會順便把Parent process砍死&lt;/p&gt;
&lt;p&gt;成功：OS會傳回一個值，用以區分child or parent：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0值：給child process&lt;/p&gt;
&lt;p&gt;.&amp;gt; 0值：給Parent，且此值為Child Process ID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Hkeq0GX.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221205225943369&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wait()：此System Call用以&lt;strong&gt;暫停&lt;/strong&gt;Process execute, 直到某個事件發生，eg. 父等子直到子終止 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exit()：此System Call用以終止Process的執行，回收其資源&lt;code&gt;但PCB的空間可能還留著，直到父把子的結果回收回來才回收&lt;/code&gt;通常exit(0)表示正常終止，&lt;strong&gt;exit(-1)表示異常終止&lt;/strong&gt;。&lt;strong&gt;子Process做完工作後，子Process要自己發出一個exit的System Call，讓OS來殺掉子Process。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;execlp()&lt;code&gt;或exec(), execve()&lt;/code&gt;：此system call用於請OS載入特定的binary code(可執行的檔案)，來執行。這個System call可以交由子process執行，讓子process執行特定的工作，&lt;strong&gt;去執行之後就不會再回來執行原程式下面的指令了，因為已經去執行特定的工作了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eg. execlp(&amp;ldquo;目錄名稱&amp;rdquo;,&amp;ldquo;檔名&amp;rdquo;,參數)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getpid()：此System Call用以取得Prcess的Id&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		說明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/73BPWL6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221205232325242&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;​	OS會配置child process memory space, 此空間是占用不同的記憶體空間，且子process的Data section 及 	code section內容均來自父process的copy, initially。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;若子process所作之工作與父process相同，則fork()完，就已經達成目的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;若子process要做特定工作(與父process不同)，則子process必須執行execlp()這個system call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;img src=&#34;https://i.imgur.com/FVrCZfE.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221205233942669&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;lession3-programming&#34;&gt;Lession3 Programming&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題1；建立Child process執行ls命令檔，且父等子完成後才列印Child completed
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fork fails &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//爸爸自己自殺
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//兒子要做的事情
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;execlp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//這段code不會執行，原因是因為execlp()會把process指向/bin/ls的binary code，接著就是去執行那段binary code了，就不會回來執行這個exit();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//pid &amp;gt;0{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;//爸爸要做的事情
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//父Process子Process直到子Process終止 子Process做完工作後，子Process要自己發出一個exit的System Call，讓OS來殺掉子Process。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;child Completed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;//不管怎樣都會執行的地方
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lNzxZM0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221206002505232&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題2 假設Parent, child 之process ID為2600, 2603 求line A, B, C, D 印出值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//pid-t: 一個名為pid 的type，就是整數，是C語言的寫法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//pid 放的是子process的ID， pid1放的是自己process的ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//A 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//B 2603
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//C 2603
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//D 2600
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3vEaYqb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221212233944674&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題3  問A的值value是多少 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//A=5 就算是global的變數，也是只能在自己的process作用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題4 求列印結果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;A&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//pid &amp;gt;0{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;B&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;父與子是並行的，因為父&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;process沒有wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;因此答案可能是&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AB或BA&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;A&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//pid &amp;gt;0{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;B&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;C&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nl&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ACBC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ABCC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BACC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題5 假設Count，是一個父與子Process的共享變數 ，初值為5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//父與子並行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;54&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;55&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//這是基本情況
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;//以高階程式語言的角度來看，count++實際上是兩條code
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//count+1跟count=count+1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//先加然後再附值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//如果以組合語言的角度來看，就是三行code
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//LOAD R1, Count
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//INC R1, 1;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//STORE Count,R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//但Process沒有辦法保證這三條Code會連續做完，有可能做到一半就被另一個Process搶走了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//所以還有一種情況是+1完之後，還來不及Assign，CPU就被另一個Process搶走了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.66&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;44&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;46&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PScmSWQ.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213223929951&#34;
	
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//例題6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;How&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mant&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;processes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;are&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;created&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//等同於 pid=fork(); if(pid ==0) ....
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.14&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;4.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ans&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;.729&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;5.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;6.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;共做了幾次&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ii&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;印出&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的有幾次&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iii&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;印出&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的有幾次&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iiii&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.)&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;印出&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;的有幾次&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例題1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/P7KPC3a.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213224958887&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例題2&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/sxHVION.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213230321504&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例題3&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/928uNym.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213231138167&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例題4&lt;/p&gt;
&lt;p&gt;parse1&lt;img src=&#34;https://i.imgur.com/B8YeFxw.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213233229409&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;parse2&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/z5Udxxt.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213233442414&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;parse3&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/jBQDnnR.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213233645680&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例題5&lt;/p&gt;
&lt;p&gt;parse1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/QNOoXgC.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213235008337&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;parse2,3&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VLdy9Wu.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221213235124681&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;例題6&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vNkpGIt.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221214001735125&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;evalue-cpu-scheduling-performance-5-criteria&#34;&gt;Evalue CPU Scheduling Performance 5 criteria&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU utilization：cpu花在Process exec time / CPU &lt;strong&gt;total time(process exec time + context switching time+ idle time)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;舉例：Process平均花5ms在exec上 ,context switching = 1ms,則CPU utilization = 5/5+1 =5/6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Throughput(產能)：單位時間內完成的Job數目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Waiting Time(等待時間，考試重點)&lt;/strong&gt;：process花在ready queue中等待獲得CPU之等待時間加總&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/owdeLYf.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221214224920098&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Turnaroud Time(完成時間)：從Process進入(到達)到它工作完成的這段時間差值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1F9T30z.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221214225625777&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Response Time(回應時間)：自user(user process) input 命令/Data 給系統到系統產生&lt;strong&gt;第一個回應&lt;/strong&gt;的時間差，沒有一個特定的量法去量它，稱之Time-sharing system, user-mteractive, &lt;strong&gt;application特別重視這一塊&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;由上述得知，排班的目標必是，**利用度越高、產能越高，時間相關的東西越短越好 **&lt;/p&gt;
&lt;h3 id=&#34;cpu排班法則行為介紹&#34;&gt;CPU排班法則行為介紹&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;FIFO&lt;/li&gt;
&lt;li&gt;SJF&lt;/li&gt;
&lt;li&gt;SRTF&lt;/li&gt;
&lt;li&gt;Priority&lt;/li&gt;
&lt;li&gt;RR&lt;/li&gt;
&lt;li&gt;Multilevel Queues&lt;/li&gt;
&lt;li&gt;Multilevel Feedback Queues (MFQs)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;fifo法則&#34;&gt;FIFO法則&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：到達時間最小的process，優先取得CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;CPU(burst) Time 要花的CPU time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;到達時間皆為0(從一開始就到了)&lt;/p&gt;
&lt;p&gt;到達順序為：P1, P2, P3(擺到ready queue的順序)&lt;/p&gt;
&lt;p&gt;Question&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;畫出Gantt Chart&lt;/li&gt;
&lt;li&gt;求Avg. waiting time&lt;/li&gt;
&lt;li&gt;求Avg. Turnaround Time&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5S4T8z9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221214235730530&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;排班效能最差，即&lt;strong&gt;Waiting time &amp;amp; Turnaround time 最長&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可能會有**Convoy Effect(護衛效應：許多Processes 均在等待一個需要很長CPU time之process 完成工作，才能取得CPU，造成Avg waiting time 很長之不良效應) **&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公平&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No Starvation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(沒有&lt;strong&gt;飢餓現象：Process因為長期無法取得完工所需各式資源，導致它遲遲無法完工，形成Indefinite Blocking 現象，稱之Starvation，容易發生在不公平對待之環境，若再加上Preemptive機制，則更是容易發生，補償方案：&amp;ldquo;Aging(老化)&amp;ldquo;技術，隨著Process待在System內的時間逐漸增加，我們也逐步提高此process的優先權，故可取得Process Resources完工，因為不會Starvation&lt;/strong&gt;。注意：Soft real-time System不採用Aging，因為Soft real-time system是為了確保real-time process取得最高優先權，如果加入Aging機制，就有可能有process的priority高於real time process)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-preemptive(不可插隊；不可搶奪)法則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;版本1(白話文)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Non-preemptive法則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義：除非執行中的process&lt;strong&gt;自願放掉CPU&lt;/strong&gt;，其他Process才會有機會取得CPU，否則就只能wait，不可逕自搶奪CPU&lt;/li&gt;
&lt;li&gt;例如：完成工作、Wait for I/O-completed after issue I/O-request&lt;/li&gt;
&lt;li&gt;優點：
&lt;ol&gt;
&lt;li&gt;Context Switching的次數比較少，因為不可插隊，所以Switching的頻率小很多&lt;/li&gt;
&lt;li&gt;process之完工時間點較可預期(Predictable)，因為不可插隊&lt;/li&gt;
&lt;li&gt;比較不會有Race Condition Problem&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺點：
&lt;ol&gt;
&lt;li&gt;排班的效能較差，因為可能有Convoy effect&lt;/li&gt;
&lt;li&gt;不適合用在Time-sharing System, Real time System，因為這兩個都需要插隊的機制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preemptive法則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義：執行中的Process有可能&lt;strong&gt;被迫放棄CPU&lt;/strong&gt;，回到ready Queue，將CPU切給別人使用，eg. Time-out, interrupt etc&lt;/li&gt;
&lt;li&gt;優點：
&lt;ol&gt;
&lt;li&gt;排班效益較佳，平均waiting/ turnound Time較小，可以把耗時較長的Process Preemptive掉&lt;/li&gt;
&lt;li&gt;適用於Real-time sysem(要能夠把real time 的process插入進去) 及Time-Sharing System&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺點：
&lt;ol&gt;
&lt;li&gt;完工時間較不可預期&lt;/li&gt;
&lt;li&gt;Context Switching次數多，負擔較重&lt;/li&gt;
&lt;li&gt;須注意Race Condition之發生&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本2：從CPU排班決策(啟動)之時機點來做區分(可以參考 State Transition，以下是五種情況做解說)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Running &amp;mdash;&amp;gt; Block eg: wait for I/O completed [自願放棄]&lt;/li&gt;
&lt;li&gt;Running &amp;mdash;&amp;gt; Ready eg: time-out [被迫放棄]&lt;/li&gt;
&lt;li&gt;Wait  &amp;mdash;&amp;gt; Ready eg: I/O-completed [尊爵不凡的process醒來了，所以要啟動CPU scheduling，獲得CPU，低優先權的process被迫放棄CPU]&lt;/li&gt;
&lt;li&gt;Running &amp;mdash;&amp;gt; Exit eg:完成工作 [自願放棄]&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以若排班決策之啟動點只包含1,4，未包含2,4，則為Non-preemptive,否則preempt。&lt;/p&gt;
&lt;p&gt;Note：凡是 xxx &amp;mdash;&amp;gt; ready 皆列入preemptive元素(選項)，所以&lt;/p&gt;
&lt;p&gt;ready/suspend &amp;mdash;&amp;gt; ready&lt;/p&gt;
&lt;p&gt;New &amp;mdash;&amp;gt; Ready&lt;/p&gt;
&lt;p&gt;皆列入preemptive&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sjfshortest-job-first法則&#34;&gt;SJF(Shortest Job First)法則&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：具有最小的CPU TIME之Process，優先取得CPU，若都一樣小，則採FIFO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;CPU Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P3&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Process到達時間皆為0，求Avg waiting time&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VKxulnL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217132504544&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排班效益最佳(optimal)，即Avg waiting/ turnaround time最小&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;說明：Why optimal?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tZPVenF.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217133256469&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因為Short Job所減少的等待時間必定&amp;gt;= Long-Job所增加的等待時間，因為平均等待時間會最小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不公平，偏好short Job&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可能會Starvation(for long Job)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以分成&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Non-preemptive &amp;mdash;&amp;gt; SJF做代表&lt;/p&gt;
&lt;p&gt;Preemptive &amp;mdash;&amp;gt; 另外&lt;strong&gt;叫做SRTF法則&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;較不適合用在Short-term scheduler(比較不恰當啦，但你要用也是可，因為Short-term scheduler執行頻率太高，所以很難在極短的時間間隔內去預估出精確的CPU Burst time for each process 且排出最小值，不易真正呈現出SJF之行為，反倒是&lt;strong&gt;適合用long-term scheduler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Short time scheduler是指專門負責處理短暫的工作的計劃程序。這些工作通常會在短短的時間內完成，並且有許多工作要求同時進行。在這種情況下，使用short job first（SJF）法則來處理工作可能不是最佳選擇。這是因為SJF法則是基於工作預計完成時間的，並假設工作的預計完成時間是可以預先知道的。但是，在short time scheduler中，大多數工作的預計完成時間都是未知的，因此無法準確地應用SJF法則。另一個原因是，SJF法則會將短工作放在優先執行的位置，因此會把許多短工作排在一起。在short time scheduler中，這可能會導致許多短工作之間的競爭，從而導致效率降低。總的來說，short time scheduler更適合使用其他計劃策略，例如基於先進先出（FIFO）或基於最短剩餘時間（SRT）的策略，來處理短暫的工作。)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何評估process之the next cpu burst time?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;公式(加權指數平均公式)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oysceoz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217153209006&#34;
	
	
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;t0&lt;/th&gt;
&lt;th&gt;t1&lt;/th&gt;
&lt;th&gt;t2&lt;/th&gt;
&lt;th&gt;t3&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;實際值&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;預估值&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;20&lt;/strong&gt;(一開始還沒預估，所以都是抓t0的值)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;T0&lt;/td&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8wvBUc8.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217154217150&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意義:　&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gx7aClO.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217160852665&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;srtfsrjfsrtn-shortest-remaining-time-job-firstnext&#34;&gt;SRTF,SRJF,SRTN( Shortest Remaining-Time Job First(Next))&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定義：&lt;strong&gt;即為Preemptive-SJF法則&lt;/strong&gt;，即剩餘CPU Burst Time(CPU完成一次短時間工作所需的時間)最小的 Process，取得CPU。也就是若新到達的Process其CPU Burst TIme 小於目前執行中process剩下的CPU time, 則新到達之Process可以**插隊(preemption)**執行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;舉例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;到達時間&lt;/th&gt;
&lt;th&gt;CPU Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;求Avg waiting Time for&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SRTF&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/enr3uhw.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217234802588&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF(不可插隊)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/mMRP8xo.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217235757038&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/rVUHVGE.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221217235808248&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;與SJF相比，SRTF之平均waiting/Turnaround time會比較小(SRTF是SJF的一個子類，因為SRTF&lt;strong&gt;可插隊&lt;/strong&gt;，所以會有最小的waiting time, 但是付出較大的Context Switching的overhead(負擔)&lt;/li&gt;
&lt;li&gt;不公平，偏好Short remaining-time Job&lt;/li&gt;
&lt;li&gt;會有Starvation的問題&lt;/li&gt;
&lt;li&gt;Preemptive法則&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;process-concept&#34;&gt;Process Concept&lt;/h3&gt;
&lt;h1 id=&#34;第一節-總覽&#34;&gt;第一節 總覽&lt;/h1&gt;
&lt;h2 id=&#34;第一章-序言&#34;&gt;第一章 序言&lt;/h2&gt;
&lt;h2 id=&#34;第二章-operating-system-strucutures作業系統架構&#34;&gt;第二章 Operating-System Strucutures(作業系統架構)★&lt;/h2&gt;
&lt;h3 id=&#34;os-service&#34;&gt;&lt;strong&gt;OS&lt;/strong&gt; Service&lt;/h3&gt;
&lt;p&gt;透過System Code去呼叫這些Service&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/RIMvaGk.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;os-application-interface最重要的&#34;&gt;OS-Application Interface(最重要的)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;System call (使用組合語言撰寫)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Operating System本身就是一個提供Service的Software，提供Process conmtrol, FIle management, Device management, Information maintenance, Communications。而System Call則是OS的Interface，透過System Call去進行Software的Interrupt。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於System call是使用組合語言來寫的，較不貼近人類，因此在多加一層API，來調用System call。這些API有些會使用到多個System Call，有些則連一個System Call都沒有，因為API本身就只是為了方面Programing，提供一個Interface去調用更底層的System call&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qKgR7ax.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221008225805849&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;System Call傳送參數的三種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透過Rigisters&lt;/li&gt;
&lt;li&gt;透過Pointer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/L0RUgJ9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009135803193&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;透過Stack&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;simple-os-architecture&#34;&gt;Simple OS Architecture&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GtaKA9x.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009193532801&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;MS-DOS device driver和ROM BIOS device driver其實都是Driver，大部分的東西都還是塞在Resident system program裡面，也就是沒再分。&lt;/p&gt;
&lt;h4 id=&#34;layer-os-architecture&#34;&gt;Layer Os Architecture&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SXR7S2w.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009193909302&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;基於Simple OS Architecture對於維護上的不便（所有東西都寫在一起），所以有人提出了分層的概念，在kerel依照subsystem的概念去劃分各個職責。外層的layer可以call裡面的layer，裡面的layer不能call外面的layer，概念有點像Mvc架構，這樣方便工程師去維護，但相對的也會帶來一些&lt;strong&gt;困難&lt;/strong&gt;，比如說&lt;strong&gt;效能降低&lt;/strong&gt;，因為需要由外面一層一層呼叫，因此效能會降低。另一方面，要去定義&lt;strong&gt;各個Layer&lt;/strong&gt;也不是一件容易的事情。&lt;/p&gt;
&lt;h4 id=&#34;microkernel-os&#34;&gt;Microkernel OS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lVO8ERV.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009200319941&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;kernel的程式碼應該要越少越好，越少越小代表越Reliable。&lt;/p&gt;
&lt;p&gt;引入Modularize的概念，把Subsystem變成各種modular，中間的kernel是負責去溝通各種不同的Modular。&lt;/p&gt;
&lt;p&gt;kernel只負責去溝通和定義，但因為這個架構的每一個subsystem要溝通都要透過kernel，去interrupt它，效能又會在更低&lt;/p&gt;
&lt;h4 id=&#34;modular-os-structure&#34;&gt;Modular OS Structure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/MQWMMPO.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009203643586&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;現在常見的作業系統大部分都遵循這個架構（linux），有點像OO的概念，把功能&lt;strong&gt;寫成各個在kernel&lt;/strong&gt;裡面的Subsystem，可以去這張投影片下面的網址，會手把手教你怎麼撰寫kernel&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nwp4ACJ.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009214443781&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yqh2tao.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009214705990&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://youtu.be/7pAiJeldUfk?t=700&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://youtu.be/7pAiJeldUfk?t=700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以多看幾次。&lt;/p&gt;
&lt;p&gt;critical instruction：一個instruction在user mode跟kernel mode執行的結果會不一樣，比如說user mode可能是a+b，但在kernel mode執行的結果是a+b+b&lt;/p&gt;
&lt;p&gt;VM的好處&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔離各個使用著，保護system resouce&lt;/li&gt;
&lt;li&gt;透過VM，可以在一台電腦因應不同的程式需求，建立不同的VM（window 98，windowXP）&lt;/li&gt;
&lt;li&gt;幫助R&amp;amp;D測試開發，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VM的技術&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full Virtualization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UEXmsCg.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221009224922016&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;一個guest的作業系統，可以不用做任何修改就可以直接安裝在一個作業系統，VM不知道自己是個VM，以為自己就是一個完整的作業系統&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para-virtualization&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/62vkO74.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010131253990&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;會有一個Global zone，負責去調度、協調各個VM，Guest的作業系統需要被修改&lt;/p&gt;
&lt;h4 id=&#34;java-virtual-machine&#34;&gt;Java Virtual Machine&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H4YbXj1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010132400382&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;第二節-process-management-進程管理&#34;&gt;第二節 Process Management (進程管理)&lt;/h1&gt;
&lt;h2 id=&#34;第三章-processes-進程&#34;&gt;第三章 Processes (進程)&lt;/h2&gt;
&lt;h4 id=&#34;process-management--thread-management&#34;&gt;Process Management &amp;amp; Thread Management&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Process 定義與Progeam比較&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCB內容 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process State Transition Diagram (S.T.D)考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scheduler的種類(解釋名詞)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;長期&lt;/p&gt;
&lt;p&gt;短期&lt;/p&gt;
&lt;p&gt;中期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Context Switching (解釋名詞)&lt;/p&gt;
&lt;p&gt;Dispatcher, Dispatch latency(較少考)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process Controller Operations(UNIX, System Call為主的程式追蹤) 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;評估CPU Scheduling 效能的好或不好的5個Criteria(清大喜歡考)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各種CPU 排班法則(7個)介紹及相關名詞(Starvation,Aging,Preemptive,Non-preemptive,Convoy effect) 考試重點&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特定System的排班設計&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MultiProcessors System&lt;/p&gt;
&lt;p&gt;Real-time System&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Soft (考申論題)&lt;/p&gt;
&lt;p&gt;Hard(考計算題)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thread Management&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;process&#34;&gt;Process&lt;/h4&gt;
&lt;p&gt;定義：A program in execution[恐]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Process 建立後，其主要組成有：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Process No(ID)&lt;/strong&gt;: Process被生成出來時，會有一個Process Id，作為識別&lt;/li&gt;
&lt;li&gt;Process State&lt;/li&gt;
&lt;li&gt;Code Section, Data Section：Process占用的 Memory Space&lt;/li&gt;
&lt;li&gt;Programming Counter(PC)：程式計數器，告訴我們現在這個Process執行到哪裡，裡面放下一條指令的位址&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;CPU Register value&lt;/li&gt;
&lt;li&gt;是OS 分配 **Resource(CPU,I/O-Divice, Memory) **之對象單位：跟Thread的差別&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;與Program(程式)的比較&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;Program&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;執行中的程式&lt;/td&gt;
&lt;td&gt;Just a &lt;strong&gt;File&lt;/strong&gt; stored in storage device&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ldquo;Active&amp;rdquo; entity(活動中、執行中)&lt;/td&gt;
&lt;td&gt;&amp;ldquo;Passive&amp;rdquo; entity(沒有活動的)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;process-control-block-1&#34;&gt;Process Control Block&lt;/h4&gt;
&lt;p&gt;(PCB內容)&lt;/p&gt;
&lt;p&gt;定義：OS為了管理所有Processes，會在Kernel memory中，替每個Process，各自準備一個Block(Table, 表格)，用來記錄Process之所有相關資訊&lt;/p&gt;
&lt;p&gt;PCB的主要內容有：&lt;/p&gt;
&lt;p&gt;Process&lt;/p&gt;
&lt;h4 id=&#34;process-concept-1&#34;&gt;Process Concept&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/46QhD4h.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010162753190&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program：被動的，可被執行的程式就叫Program，存在硬碟裡面&lt;/li&gt;
&lt;li&gt;Process：主動的，一個程式正在執行就叫Process，是存在Memory裡面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;code segment&lt;/code&gt;：把程式碼放到memory裡面的動作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data section&lt;/code&gt;：globla variable存放的區域&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt;：區域變數及function存放的地方&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Heap&lt;/code&gt;：(待補)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/67apr7c.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010170803581&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;又稱做Lightweight process，是CPU的最小執行單位，它跟Process有八成像，Process可以被拆分成很多個Thread，許多Thread&lt;strong&gt;可以共用同一塊Memory Space&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同一個Process下面的Thread，它的Code section，Data section，OS resource ，這三塊的memory空間是共用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/P3yDybT.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010172926249&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;管理Thread的方式跟管理Process的方式都大同小異，區別不大，像Linux就沒有Process的概念。都只有Thread而已，當一個Process被執行起來時，會有下面這五個狀態&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oPCYLp0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010175047577&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;New：當這個Process被created出來，把Program load 進 Memory裡面，然後initialization。&lt;/li&gt;
&lt;li&gt;Ready：把Process放進一個quoue裡面，等著被OS排程，放進CPU做使用。&lt;/li&gt;
&lt;li&gt;Running：送instructions到CPU裡面做使用&lt;/li&gt;
&lt;li&gt;Ｗating：有些instruction不需要CPU來做，例如IO，而等待其他事件執行完畢的這個過程就叫wating&lt;/li&gt;
&lt;li&gt;Terminated：釋放資源，把資源給其他的Process&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/A9jcaOI.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010180531411&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;管理Process的方式，就是會為每一個Process去建立一個&lt;strong&gt;Process Control Block&lt;/strong&gt;，在Memory裡面紀錄這些Information，在Ready狀態的意思，就是只把PCB放進quoue的動作，這個PCB會存放下列資訊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Process State&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Program counter（CPU中的Register，用於指示電腦在其程式序列中的位置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU Register（CPU中，用來暫存指令、數據和記憶體位址的電腦記憶體，暫存器的容量有限，但讀寫速度快的飛起）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU Scheduling Information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory-management information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O status information&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accounting Information&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/s2ZFuvE.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010182705266&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lOawJ5v.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010183709101&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU被interrupt之後，把CPU上執行的Process切換成另一個Process的動作，就叫Context Switch，實際上就是在做PCB的Save還有Load的動作。&lt;/p&gt;
&lt;p&gt;Context Switch是一個overhead（浪費）的行為，但卻無可避免，因為我們要Share CPU 給所有的Process。&lt;/p&gt;
&lt;p&gt;提升Context Switch的速度有幾種方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提升momory的速度&lt;/li&gt;
&lt;li&gt;減少Register的數量，數量減少了，需要存儲的資料也少了，但這件事情在現代很難做到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面兩種都不是主流的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware Support，有好幾個set的Register，可以在hardware裡面紀錄好幾個程式的狀態，所以在做Context Switch的時候，只是從一個Register切換到另一個Register，減少對memory的access&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;process-scheduling&#34;&gt;Process Scheduling&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zvU98FQ.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010185905554&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Process 也能產生 Process （parent跟child）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9GsCQX3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010230406358&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU的數量很少，可能只有個位數或十幾個，但在Memory要執行的程式卻很多(multiProgram)，因此需要Scheduler，有分為三種Scheduler&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Short-term**(CPU Scheduler)**：選擇哪個Process要被執行，以及分配CPU&lt;/li&gt;
&lt;li&gt;Long-term**(Job Scheduler)**：決定哪些Processes能被Load進Memory，以及進入queue等待&lt;/li&gt;
&lt;li&gt;Medium-term：決定哪個Processes被丟回Memory（從Ready state 變成 Wait state）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/XyXSPVP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010232740246&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;long-term-scheduler&#34;&gt;Long-Term Scheduler&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制 degree of multiprogramming：目前電腦上有幾個程式在Memory裡面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行的頻率相較Short-term來講較低（只在process離開系統，或是每隔幾分鐘執行一次）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇什麼Processes也很重要，因為我們希望CPU跟I/O可以overlap，不要完全偏向CPU或是I/O，而讓另一方沒事情做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在現在的OS裡面，因為Memory已經足夠，因此Job Schduler的功能逐漸淡化，直接先load進memory再說，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;short-term-scheduler&#34;&gt;Short-Term Scheduler&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/uzdlYWX.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221010234018932&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頻率極短(100ms)&lt;/li&gt;
&lt;li&gt;要非常有效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;medium-term-scheduler&#34;&gt;Medium-Term Scheduler&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nYV5B7I.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221011010707793&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;負責在DisK及Memory之間切換的Scheduler&lt;/p&gt;
&lt;p&gt;Swap Out：把Processes移出記憶體&lt;/p&gt;
&lt;p&gt;Swap In：把Processes移入記憶體&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PYbB6CD.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012001702454&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;每個Processor都有自己的ID(Processor identifier &lt;strong&gt;pid&lt;/strong&gt;)，&lt;strong&gt;整台電腦一開始在執行的時候只會有一個Process&lt;/strong&gt;，這個Process再去Create其他的Process&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個指令可以列出所有啟動的Processes&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ps-ael 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tdzYGmL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012003309571&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;process-creation&#34;&gt;Process Creation&lt;/h5&gt;
&lt;p&gt;Parent和Child雖然是兩隻不一樣的程式，但還是有某種程度上的關聯，這個關聯性的定義，分成下面三個比較重要的部分，&lt;strong&gt;這個關聯性是由OS的設計者去決定的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Resource Sharing之間的關聯性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parent跟Child分享所有資源&lt;/li&gt;
&lt;li&gt;Global共享，但Dynamic的不共享&lt;/li&gt;
&lt;li&gt;全部都不分享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Processes執行的順序，當Child被創建後，哪個Process有優先執行的權力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讓OS自己來決定&lt;/li&gt;
&lt;li&gt;Chidren擁有較高的執行權&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process Address Space的狀態&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Child複製Parent的過去（連Code Counter，程式執行到哪一行都會複製過去，比如說Parent執行到第三行，那複製過去的Child就會從第三開始啟動。行為都一樣，但Address會不一樣）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Child重新去Load Parent的程式碼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/OygMp9G.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012215807520&#34;
	
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;unixlinux-process-creation&#34;&gt;UNIX/Linux Process Creation&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fork&lt;/strong&gt; system Call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;創建新的Child Process&lt;/li&gt;
&lt;li&gt;是用複製(duplicates)的方式創建的&lt;/li&gt;
&lt;li&gt;執行無先後順序之分&lt;/li&gt;
&lt;li&gt;Fork的這個Code也是個System code，會return 一個 value，return的value會是它children的PID，若底下無children則return 0 （父母一定知道小孩是誰，但小孩不一定知道父母是誰）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;execlp&lt;/strong&gt; system call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parent跟Child是dupulicate，裡面的內容完完全全一模一樣，但今天create 一個新的process的目的不是為了做同樣的事情，因此execlp這個system call的目的，就是塞一個binary file（也就是program），就會把把child的process全部清空。**那為什麼不直接創造一個新的process？**因為需要跟OS註冊一個PID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wait&lt;/strong&gt; system call&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為執行順序是concurrently，因此需要用wait來做順序的控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/a5oWtwq.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012222041627&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這只是UNIX系統對Process的策略，不代表所有，實際還是要參照[Process Creation](# Process Creation)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從A複製一份到A&amp;rsquo;s child，之所以A&amp;rsquo;s child會比較小的原因，主要是因為，如果是完整複製的話，其實大小是會一樣的，父Process有100 MB，子Process 就會有100MB，但這樣的事情很沒意義，因此現在會採用Copy-on-write，保存重要的資訊就好，其他的就不複製過去，比如說code counter，或是Local Variable都沒有變的話，則子Process會用一個Pointer指到父Process，但如果Runtime後發現不一樣，OS才真的會複製一份到子process。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W3myj7Q.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012225909520&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tH3YUq6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012231835420&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;恩，這邊不太清楚，要再回頭看 不懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;interprocess-communicationipc&#34;&gt;Interprocess Communication(IPC)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/b6dna1d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012233401342&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在OS的世界裡，有時候Process跟Thread是不分的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPC：不同或相同的Process裡面的thread要互相溝通&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EfY6Ymz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012234603052&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;讀投影片就是完整的筆記了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;溝通的方式有兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shared Memory&lt;/p&gt;
&lt;p&gt;有一塊Memoryd空間是share的，兩個人都可以用pointer去access它(會有synchronization的問題)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Message Passing&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​      跨電腦的訊息溝通是Message Passing&lt;/p&gt;
&lt;p&gt;資料量小的話用Shared memory，資料量大的話用Message passing（避免synchronization問題），&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/getfXBb.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221012235849010&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如何Message Passing呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Socket：透過IP和Port來辨認使用者，&lt;strong&gt;Port Number(8080,5432)就是Process&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Process ID是一個Process獨一無二的ID，用來辨認不同Process&lt;/p&gt;
&lt;p&gt;Port Number是作為網路連線的一部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Socket是個比較low level的傳遞方式，只能傳遞stream of bytes。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remote Procedure Calls&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;shared-memory&#34;&gt;Shared Memory&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/vVFc3gA.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221013223320680&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pwAp55s.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015144503008&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/VX7VTFL.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015144924661&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完全看不懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;message-passing&#34;&gt;Message Passing&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zEPTisH.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015151426143&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GjTgnUy.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015152045607&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用Memory copy的方式，溝通的方式有一點像打電話，有一個人要打電話(Send)另一個人要接電話(Receive)，訊息才可以交流，這一部分也隱含了同步化的操作，意即Message Passing雖然速度比較慢，但它其實幫你做了同步化這件事情。&lt;/p&gt;
&lt;p&gt;為了要溝通，所以需要先建立一個communication link，並提供一個Send跟receive的function code，實作一個communication link有分成physical跟logical兩個部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Physical&lt;/p&gt;
&lt;p&gt;例如Shared memory, HW bus 或是 network的部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Logical(Program 在乎的事情)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;溝通的方向性(單向還是雙向)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;symmetric and asymmetric 對稱與非對稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Blocking or non-blocking&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;blocking：呼叫一個function，除非這個function全部做完才會做下一件事情，循序漸進的方法去執行程式&lt;/p&gt;
&lt;p&gt;Non-Blocking：呼叫一個function，如果有資料就回傳資料，如果沒有資料回傳就會得到一個Error，並執行下一個程式（大概啦）&lt;/p&gt;
&lt;p&gt;參考資料：&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;淺談I/O Model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;hellip;. 參閱上面投影片&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5xOl2Ks.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015154148903&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DlWQ645.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015192600656&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/bq56vJz.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015192823026&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;傳遞訊息的時候，不是把訊息直接傳給一個人，而是放到一個Mail Box裡面，想要這個message的人自己到mailbox裡面拿，這種不知道雙方是誰的Communication就叫做indirect communication&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/AOImSIi.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015231131458&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;MailBox所遇到的問題&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果很多人同時連線到MailBox該怎麼辦?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;限制這個communication只能有兩個人同時使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一時間只能有一個Receiver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;mailbox不做限制要幾個人來都可以但當有人同時access的時候會有其中一方先被delay&#34;&gt;MailBox不做限制，要幾個人來都可以，但當有人同時Access的時候，會有其中一方先被Delay&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;synchronization&#34;&gt;Synchronization&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cuNUaxt.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015232822207&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不懂，Buffer是啥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Message在傳遞的時候一定是blocking或是non-blocking的狀態，要特別注意，Blcoking Send 不一定要對到Blocking Receive，它們之間沒有相對關係&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Blocking&lt;/th&gt;
&lt;th&gt;NonBlock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Send&lt;/td&gt;
&lt;td&gt;在Message被收到之前，Sender都是被blocked住的&lt;/td&gt;
&lt;td&gt;Sender送出Messager，不管有沒有人收到訊息，都直接去做自己的事&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Receive&lt;/td&gt;
&lt;td&gt;Receiver被blocked住，直到收到訊息&lt;/td&gt;
&lt;td&gt;Receiver收到一個valid Message或null(因為是nonBlock)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;sockets&#34;&gt;Sockets&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yxrK8Tu.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221015234703436&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Accept之後會產生一個thread，所以這整體是一個MultiThread的架構&lt;/p&gt;
&lt;h4 id=&#34;remote-procedure-callsrpc&#34;&gt;Remote Procedure Calls：RPC&lt;/h4&gt;
&lt;h2 id=&#34;第四章-thread--concurrency-執行序與併發&#34;&gt;第四章 Thread &amp;amp; Concurrency (執行序與併發)&lt;/h2&gt;
&lt;h2 id=&#34;第五章-cpu-scheduling-cpu-行程&#34;&gt;第五章 CPU Scheduling (CPU 行程)&lt;/h2&gt;
&lt;h1 id=&#34;第三節-process-synchronization-進程同步&#34;&gt;第三節 Process Synchronization (進程同步)&lt;/h1&gt;
&lt;h2 id=&#34;第六章-synchronization-tools-同步工具&#34;&gt;第六章 Synchronization Tools (同步工具)&lt;/h2&gt;
&lt;h2 id=&#34;第七章-synchronization-examples-同步範例&#34;&gt;第七章 Synchronization Examples (同步範例)&lt;/h2&gt;
&lt;h2 id=&#34;第八章-deadlocks死鎖&#34;&gt;第八章 Deadlocks(死鎖)&lt;/h2&gt;
&lt;h1 id=&#34;第四節-memory-management記憶體管理&#34;&gt;第四節 Memory Management(記憶體管理)&lt;/h1&gt;
&lt;h2 id=&#34;第九章-main-memory主記憶體&#34;&gt;第九章 Main Memory(主記憶體)&lt;/h2&gt;
&lt;h2 id=&#34;第十章-virtual-memory虛擬記憶體&#34;&gt;第十章 Virtual Memory(虛擬記憶體)&lt;/h2&gt;
&lt;h1 id=&#34;第五節-storage-management儲存空間管理&#34;&gt;第五節 Storage Management(儲存空間管理)&lt;/h1&gt;
&lt;h2 id=&#34;第十一章-mass-storage-structure-大型儲存架構&#34;&gt;第十一章 Mass-Storage Structure (大型儲存架構)&lt;/h2&gt;
&lt;h2 id=&#34;第十二章-io-system-輸入輸出系統&#34;&gt;第十二章 I/O System (輸入/輸出系統)&lt;/h2&gt;
&lt;h1 id=&#34;第六節-file-system-檔案系統&#34;&gt;第六節 File System (檔案系統)&lt;/h1&gt;
&lt;h2 id=&#34;第十三章-file-system-interface-檔案系統介面&#34;&gt;第十三章 File-System Interface (檔案系統介面)&lt;/h2&gt;
&lt;h2 id=&#34;第十四章-file-system-implementation-檔案系統實作&#34;&gt;第十四章 File-System Implementation (檔案系統實作)&lt;/h2&gt;
&lt;h2 id=&#34;第十五章-file-system-internals-檔案系統內部&#34;&gt;第十五章 File-System Internals (檔案系統內部)&lt;/h2&gt;
&lt;h1 id=&#34;第七節-security-and-protected-安全性及保護&#34;&gt;第七節 Security And Protected (安全性及保護)&lt;/h1&gt;
&lt;h2 id=&#34;第十六章-security-安全性&#34;&gt;第十六章 Security 安全性&lt;/h2&gt;
&lt;h2 id=&#34;第十七章-protection-保護&#34;&gt;第十七章 Protection 保護&lt;/h2&gt;
&lt;h1 id=&#34;第八節-advenced-topics-進階主題&#34;&gt;第八節 Advenced Topics (進階主題)&lt;/h1&gt;
&lt;h2 id=&#34;第十八章-vitual-machines-虛擬機&#34;&gt;第十八章 Vitual Machines (虛擬機)&lt;/h2&gt;
&lt;h2 id=&#34;第十九章-networds-and-distributed-systems-網路與分配系統&#34;&gt;第十九章 Networds and Distributed Systems (網路與分配系統)&lt;/h2&gt;
&lt;h1 id=&#34;第九節-case-studies-案例學習&#34;&gt;第九節 Case Studies (案例學習)&lt;/h1&gt;
&lt;h2 id=&#34;第二十章-the-linux-system-linux系統&#34;&gt;第二十章 The Linux System (Linux系統)&lt;/h2&gt;
&lt;h2 id=&#34;第二十一章-windowswindows&#34;&gt;第二十一章 Windows(Windows)&lt;/h2&gt;
&lt;h1 id=&#34;第十節-appendices-附錄&#34;&gt;第十節 Appendices (附錄)&lt;/h1&gt;
&lt;h2 id=&#34;附錄a-influential-operating-system-有影響力的作業系統&#34;&gt;附錄A Influential Operating System (有影響力的作業系統)&lt;/h2&gt;
&lt;h2 id=&#34;附錄b-windowswindows&#34;&gt;附錄B Windows(Windows)&lt;/h2&gt;
&lt;h2 id=&#34;附錄c-bsd-unix&#34;&gt;附錄C BSD UNIX&lt;/h2&gt;
&lt;h2 id=&#34;附錄d-the-mach-system&#34;&gt;附錄D The Mach System&lt;/h2&gt;
&lt;h2 id=&#34;附錄a-influential-operating-system-有影響力的作業系統-1&#34;&gt;附錄A Influential Operating System (有影響力的作業系統)&lt;/h2&gt;
&lt;h2 id=&#34;附錄b-windowswindows-1&#34;&gt;附錄B Windows(Windows)&lt;/h2&gt;
&lt;h2 id=&#34;附錄c-bsd-unix-1&#34;&gt;附錄C BSD UNIX&lt;/h2&gt;
&lt;h2 id=&#34;附錄d-the-mach-system-1&#34;&gt;附錄D The Mach System&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
