<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Hoxton</title><link>https://hoxtonhsu.com/tags/docker/</link><description>Recent content in Docker on Hoxton</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Sat, 21 Jan 2023 00:52:36 +0800</lastBuildDate><atom:link href="https://hoxtonhsu.com/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker_Desktop_Starting問題解決</title><link>https://hoxtonhsu.com/p/docker_desktop_starting%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA/</link><pubDate>Sat, 21 Jan 2023 00:52:36 +0800</pubDate><guid>https://hoxtonhsu.com/p/docker_desktop_starting%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA/</guid><description>&lt;img src="https://i.imgur.com/xgUpP8O.png)" alt="Featured image of post Docker_Desktop_Starting問題解決" />&lt;p>最近在新電腦上安裝了Docker結果發現一直卡在這個畫面&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/cw9mdiw.png"
loading="lazy"
alt="image-20230121005427135"
>&lt;/p>
&lt;p>後來研究了一下發現應該是wsl沒有裝好的原因，後來安裝好之後，在把Window Update要我Update的東西全部更新一次，就可以執行成功了，推測應該是window版本沒更新，導致不支援wsl的關係。&lt;/p></description></item><item><title>Docker學習筆記</title><link>https://hoxtonhsu.com/p/docker%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</link><pubDate>Wed, 18 Jan 2023 21:47:50 +0800</pubDate><guid>https://hoxtonhsu.com/p/docker%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</guid><description>&lt;img src="https://i.imgur.com/JdDwgHn.png " alt="Featured image of post Docker學習筆記" />&lt;h1 id="名詞解釋">名詞解釋&lt;/h1>
&lt;h2 id="container">Container&lt;/h2>
&lt;p>Docker Container 是一種軟體容器，它可以在其中運行應用程式和其他服務。它使用操作系統級別的虛擬化，可以在單一的物理主機上運行多個容器，並且每個容器都有自己的運行環境和資源。&lt;/p>
&lt;p>Docker Container 是一種軟體容器，它可以在其中運行應用程式和其他服務。容器具有輕量級、可移植性和隔離性等特點。容器是通過在操作系統內核中運行的容器引擎來實現的。&lt;/p>
&lt;p>Docker容器主要是使用了Linux 的 Namespaces 和 Control groups（cgroups） 技術來實現隔離，這兩種技術可以將一個實體主機上的資源限制給每個容器，而容器內部則是共用一個kernel，因此容器比虛擬機器輕量且速度較快。&lt;/p>
&lt;p>Docker容器是基於鏡像(Image)來建立與運行的，一個鏡像可以是一個基礎鏡像或是由其他鏡像所建立而來。當執行docker run 指令時，會從鏡像建立一個容器，並在容器內執行指定的應用程式或服務。&lt;/p>
&lt;p>不僅如此，Docker容器還支援網路、儲存卷的映射，使得容器可以與外部通訊，也可以存取本地端的資料。&lt;/p>
&lt;p>透過Docker容器,我們可以將應用程式、服務和其所需的環境打包在一起，並且可以在不同的環境中運行，提高了應用程式的可移植性和彈性。&lt;/p>
&lt;h2 id="image">Image&lt;/h2>
&lt;p>Docker Image 是 Docker 容器的基礎，它是一個只讀的模板，包含了容器運行所需的所有檔案、設定和程式。當執行 &lt;code>docker run&lt;/code> 指令時，Docker 會從 Image 建立一個新的容器並在其中執行指定的應用程式或服務。&lt;/p>
&lt;p>Docker Image 可以通過構建或下載的方式創建，構建的方式可以使用 Dockerfile 來描述如何構建一個 Image。而下載的方式則可以從 Docker Hub 或其他的 registry 下載。&lt;/p>
&lt;h2 id="volume">Volume&lt;/h2>
&lt;p>Docker Volume 是 Docker 的一種功能，用於管理容器中的數據。容器本身是輕量級的，數據是不能永久存在的，而 Volume 則是可以永久存在的。&lt;/p>
&lt;p>Docker Volume 可以被掛載到容器上，並且可以在容器內部存儲數據。當容器停止運行或者被刪除時，Volume 中的數據仍然可以保留下來。這樣就可以在重啟容器或建立新容器時，繼續使用之前存儲的數據。&lt;/p>
&lt;p>並且Volume裡面的資料是可以和Host分享的，兩邊的資料呈現鏡像的雙向對應，在Host新增的東西會在Container出現，Container新增的資料也會在Host裡面出現&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/pw664cD.png"
loading="lazy"
alt="image-20230121163302976"
>&lt;/p>
&lt;h1 id="常用指令">常用指令&lt;/h1>
&lt;h2 id="搜尋image">搜尋Image&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker search postgres
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/D4Bl6SJ.png"
loading="lazy"
alt="image-20230124042123305"
>&lt;/p>
&lt;h2 id="查看目前的image">查看目前的image&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker image ls
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="執行docker-image">執行docker image&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run &lt;span class="o">[&lt;/span>imageName&lt;span class="o">][&lt;/span>:tag&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/s140pSv.png"
loading="lazy"
alt="image-20230121123518172"
>&lt;/p>
&lt;p>後面的:latest是版本號，可加可不加，沒加的話預設就是latest&lt;/p>
&lt;h2 id="刪除images">刪除images&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker rmi &lt;span class="o">[&lt;/span>imageId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="在detached-mode下執行">在Detached mode下執行&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run -d nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所謂的Detached mode亦即&lt;strong>啟動後會不會占用你的terminal&lt;/strong>，可以看一下下面的git，可以比較兩者間的差異&lt;/p>
&lt;ul>
&lt;li>沒有-d&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.imgur.com/ehYrPax.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;ul>
&lt;li>有-d&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.imgur.com/kRVrhXQ.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;h2 id="打包成docker-image">打包成docker image&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker build -t drink-more-water:latest .
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>-t 是 tag的縮寫，hello-docker是這個tag的名稱，.代表dockerfile在當前的目錄下，如果Dockerfile不在當前目錄，則這邊要改變。latest則是版本號，可加可不加，不加的話預設是latest&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/c5XdkHr.png"
loading="lazy"
alt="image-20230118215347469"
>&lt;/p>
&lt;h2 id="查看目前運行的container">查看目前運行的Container&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>ps是process status的意思&lt;/code>&lt;/p>
&lt;p>或是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker container ls
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>​ &lt;img src="https://i.imgur.com/WCJdgXl.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;h2 id="查看目前運作中running的container">查看目前運作中(running)的Container&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/C1jS3jN.png"
loading="lazy"
alt="image-20230118222647084"
>&lt;/p>
&lt;p>或是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker ps -a
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>查看底下全部的Container不論啟動與否&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/sIt29w1.png"
loading="lazy"
alt="image-20230118222751647"
>&lt;/p>
&lt;h2 id="進入container與之互動">進入Container與之互動&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-sh" data-lang="sh">docker &lt;span class="nb">exec&lt;/span> -it &lt;span class="o">[&lt;/span>ConatinerId&lt;span class="o">]]&lt;/span> bash
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>bash有可能沒有，有可能是sh，要自己到/bin裡面看&lt;/p>
&lt;h2 id="停止container">停止Container&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker stop &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/dziz1MR.png"
loading="lazy"
alt="image-20230121125714796"
>&lt;/p>
&lt;p>​&lt;/p>
&lt;p>啟動停止的Container&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker start &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="刪除container">刪除Container&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker rm &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>or&lt;span class="o">[&lt;/span>NAMEs&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/RrMc8BN.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>也可以輸入很多個Id，一次刪個爽&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/rL9pJaN.png"
loading="lazy"
alt="image-20230121155539947"
>&lt;/p>
&lt;p>還有更猛的&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docekr rm -f &lt;span class="k">$(&lt;/span>docker ps -aq&lt;span class="k">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>直接用參數的方式全刪。&lt;/p>
&lt;h2 id="暴露port">暴露port&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run -p 5432:5432 posgres
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>前面的5432是你自定義的localhost:5432，而後面的5432則是容器裡面的port號&lt;/p>
&lt;h2 id="暴露已經runningstopping-的container的port">暴露已經Running,Stopping 的Container的Port&lt;/h2>
&lt;p>沒有這個方法，只有&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run postgres
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>的這個時候你才可以把port暴露出來&lt;/p>
&lt;h2 id="一次性查看container的log紀錄">一次性查看Container的Log紀錄&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker logs &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/ux9s2GH.png"
loading="lazy"
alt="image-20230124052203569"
>&lt;/p>
&lt;p>這條指令只會顯示過去的紀錄，後續的logs不會更新&lt;/p>
&lt;h2 id="持續查看container的log紀錄">持續查看Container的Log紀錄&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker logs -f &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這條不只會顯示過去的，還會動態更新現在的log&lt;/p>
&lt;h2 id="執行docker-compose">執行Docker-compose&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker compose up -d
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>-d 代表是否背景執行，不佔用terminal&lt;/p>
&lt;h2 id="停止並刪除docker-compose的container">停止並刪除Docker-compose的Container&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker compose down
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="將dokcer-images-push至dockerhub">將Dokcer Images Push至Dockerhub&lt;/h2>
&lt;p>首先先登入dockerhub&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker login
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再將想要推上去的docker Image重新命名&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker tag &lt;span class="o">[&lt;/span>Image Name&lt;span class="o">]&lt;/span> DockerHub帳號/Image Name
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著push上去 dockerhub&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker push DockerHub帳號/Image Name
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>想要使用image的話就執行pull&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docker pull DockerHub帳號/Image Name
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="在docker啟動ubuntu">在Docker啟動Ubuntu&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>下載 ubuntu 的image&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker pull ubuntu
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或是可以&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run ubuntu
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就會自動從docker hub載下來了，但這樣只是把ubuntu的image拉到我們的docker裡面，它本身是沒有啟動的&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/MMDiSRt.png"
loading="lazy"
alt="image-20230118222929032"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在docker中運行ubuntu&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run -it ubuntu
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/IMZCVGx.gif"
loading="lazy"
alt=" "
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用apt(advanced package tool)安裝nano(Linux text editor)&lt;/p>
&lt;p>用apt載任何東西前都建議先update&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">apt update
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">apt install nano
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h1 id="exposing-port">Exposing Port&lt;/h1>
&lt;p>輸入&lt;code>docker ps&lt;/code>可以看到以下資訊&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/jkFwePC.png"
loading="lazy"
alt="image-20230121144512601"
>&lt;/p>
&lt;p>其中的PORTS 80/tcp的意思，容器對外公開的網路端口是 80/tcp，表示這個容器對外公開的網路端口是80，並且是基於TCP協議的。這意味著當外部網路瀏覽器連接到&lt;a class="link" href="http://xn--localhosthttp-cs9z//" target="_blank" rel="noopener"
>http://localhost或http://&lt;/a>&lt;IP address>時，將會連接到容器內部的 Nginx Web 伺服器。想要讓容器的端口對外開放，就需要exposing它，否則直接打localhost:80是沒有用的。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/ZD37kgp.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>我們可以使用以下的方式將8080 連接到80/TCP&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/6NmgZGj.png"
loading="lazy"
alt="image-20230121144820173"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run -d -p 8080:80 nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中的8080:80的意思是指將主機的 8080 端口映射到容器的 80 端口。也就是說，當外部網路瀏覽器連接到 &lt;a class="link" href="http://localhost:8080/" target="_blank" rel="noopener"
>http://localhost:8080&lt;/a> 時，將會連接到容器內部的 Nginx Web 伺服器。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/uv9msjJ.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/qRzMKUP.png"
loading="lazy"
alt="image-20230121152744371"
>&lt;/p>
&lt;p>你也可以不只Exposing一個Port，可以Exposing多個port給80&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/udQnP6Q.png"
loading="lazy"
alt="image-20230121153052811"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run -d -p 8080:80 -p 3000:80 nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/RAElKnV.png"
loading="lazy"
alt="image-20230121153324975"
>&lt;/p>
&lt;h1 id="container的管理">Container的管理&lt;/h1>
&lt;p>當我們啟動、並Stop一個Container，實際上如果依照我們剛剛的作法，我們是不斷的創造新的Container，輸入docker ps -a 即可看到目前存在的Container(不論running or Stopping)，或是在Desktop docker裡面也都可以看到&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/y6X5rl3.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/myW3tLy.png"
loading="lazy"
alt="image-20230121154505315"
>&lt;/p>
&lt;p>我們可以透過&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker rm &lt;span class="o">[&lt;/span>ContainerId&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>來真正意義上的移除Container，而不是停止它&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/RrMc8BN.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>&lt;code>可以使用docker ps -aq ，這個指令只會秀出ContainerId，可以刪更爽，直接複製貼上就好&lt;/code>&lt;/p>
&lt;p>還有更爽的方式，用$(docker ps -aq)的方式 傳遞參數&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/6awXQYd.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;h1 id="為container命名">為Container命名&lt;/h1>
&lt;p>建議命名一下，比較好找，只支援英文，不支援中文&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --name hoxtonPractice -d -p 8080:80 nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/ibwUXZi.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/ivVF2QW.png"
loading="lazy"
alt="image-20230121161417305"
>&lt;/p>
&lt;h1 id="volume的使用">Volume的使用&lt;/h1>
&lt;p>讓資訊可以在host與Container共享的一個功能&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/gFztGx2.png"
loading="lazy"
alt="image-20230121171102777"
>&lt;/p>
&lt;p>範例：&lt;/p>
&lt;p>首先在桌面上創建一個名為website的資料夾，裡面有個index.html，內容如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-html" data-lang="html">&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">h1&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>hello docker and volume&lt;span class="p">&amp;lt;/&lt;/span>&lt;span class="nt">h1&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/E9IOBy2.png"
loading="lazy"
alt="image-20230121172021418"
>&lt;/p>
&lt;p>接著將terminal切至/website底下，然後輸入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --name website -v &lt;span class="si">${&lt;/span>&lt;span class="nv">PWD&lt;/span>&lt;span class="si">}&lt;/span>:/usr/share/nginx/html:ro -d -p 8080:80 nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>-v是 Docker 中的 volume 指令，它用於將主機上的目錄或檔案掛載到容器中。配合後面的${PWD}:/usr/share/nginx/html，意思就是將當前目錄的內容掛載(Mount)到容器中的 /usr/share/nginx/html 目錄下。這樣設定後，當主機上的目錄內容變更時，容器中的 /usr/share/nginx/html 目錄內的內容也會隨之更新。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>:ro 是指將主機上的目錄或檔案掛載到容器中的目錄或檔案，並設定為只讀模式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>​ 這意味著在容器中將無法寫入或修改掛載的目錄或檔案，只能讀取。這可以避免對主機上的檔案造成損壞或不 必要的變更。&lt;/p>
&lt;ul>
&lt;li>/usr/share/nginx/html 是 Nginx 預設的網站根目錄。&lt;/li>
&lt;/ul>
&lt;p>結果如下：&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/JWE1ngP.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>也因為Volume是鏡像對應，因此修改host的檔案，container的內容物也會同步更新&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/xr4Ps97.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>我們可以用以下的指令來訪問看看Nginx的檔案&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker &lt;span class="nb">exec&lt;/span> -it website bash
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>docker exec 是 Docker 的命令行工具，用於在運行中的容器內執行命令。&lt;/li>
&lt;li>-it 這兩個選項表示要互動式地執行命令，並且讓輸入和輸出保持連接。&lt;/li>
&lt;li>website 是容器的名稱或 ID。&lt;/li>
&lt;li>bash 是要在容器內執行的命令，這裡是啟動 Bash shell。也可以改成ls，就變成ls了，玩法很多，自行摸索&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.imgur.com/vfD46ft.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>在Nginx裡面新增檔案，移除檔案，會發現host的資料夾檔案也同步更新&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/CxISdYl.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;h2 id="不同的container使用相同的volume">不同的Container使用相同的Volume&lt;/h2>
&lt;p>&lt;img src="https://i.imgur.com/sF6Jpws.png"
loading="lazy"
alt="image-20230122000944184"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/M0VVEdM.png"
loading="lazy"
alt="image-20230122000515311"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --name website-copy --volumes-from website -d -p 8081:80 nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&amp;ndash;volumes-from [ContainerName]：將這次要啟動的Container使用和website一樣的Volume&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.imgur.com/138uiD1.png"
loading="lazy"
alt="image-20230122000709771"
>&lt;/p>
&lt;h1 id="dockerfile">Dockerfile&lt;/h1>
&lt;p>Dockerfile是一個文本文件，它包含了創建Docker image所需的指令。這些指令可以包括例如：&lt;/p>
&lt;ul>
&lt;li>從哪個基礎鏡像建立新鏡像&lt;/li>
&lt;li>安裝需要的軟體&lt;/li>
&lt;li>設置環境變量&lt;/li>
&lt;li>添加應用程序文件&lt;/li>
&lt;li>定義容器啟動時執行的命令&lt;/li>
&lt;/ul>
&lt;p>透過Dockerfile, 可以自動化的建立一個環境，方便在不同的環境上部署，使用者可以更方便的管理環境，以及減少部署錯誤的機會。&lt;/p>
&lt;p>例如，如果你有一個Java應用程序需要在多個不同的服務器上運行，你可以使用Dockerfile創建一個包含Java執行時環境的镜像，然後在每個服務器上執行這個镜像，這樣就能保證每個服務器上都有相同的環境。&lt;/p>
&lt;p>試著把剛剛寫的volume打包成一個image，首先在/website的資料夾裡面新增一個名稱一定要是dockerfile的檔案&lt;/p>
&lt;p>裡面的檔案結構長的像這樣子&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> nginx:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> . /usr/share/nginx/html&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>FROM：指定了基礎Image是nginx，後面的latest是指版本號。Dockerfile中必須要有FROM指令，它是一切的根本，它指定了基礎Image環境。舉例來說，這邊指定用最新版的nginx，那麼我們的鏡像會基於這個最新版的nginx環境運行&lt;/li>
&lt;li>ADD：將本地目錄中的文件複製到鏡像中的指定目錄。在這個例子中是將本地目錄中的所有文件複製到鏡像中的/usr/share/nginx/html目錄。它的功能跟COPY有點像，但是COPY用法比較單純，只能複製本地文件和目錄到鏡像中，而ADD指令還可以解壓縮tar文件並將其中的文件複製到鏡像中。&lt;/li>
&lt;/ul>
&lt;p>​ 值得注意的是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">ADD&lt;/span> . /usr/share/nginx/html&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這行指的是，將當前目錄的所有東西(以一個.表示)加入至Container中的/usr/share/nginx/html目錄中。在這個例子中就是將&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/xhF8sgi.png"
loading="lazy"
alt="image-20230122005758339"
>&lt;/p>
&lt;p>這些東西ADD進/usr/share/nginx/html裡面。&lt;/p>
&lt;p>當Dockerfile寫好後，要開始bulid它，步驟如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">docker build -t website:latest .&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>這個命令是在使用 Docker 建立一個新的鏡像檔，並標記為 &amp;ldquo;website:latest&amp;rdquo;。 &amp;ldquo;.&amp;rdquo; 表示當前目錄下的 Dockerfile 檔案將會被用來建立映像檔。這個命令將會建立一個名為 &amp;ldquo;website&amp;rdquo; 並且標記為 &amp;ldquo;latest&amp;rdquo; 的鏡像檔。&lt;/li>
&lt;/ul>
&lt;p>Build完後就會出現一個image了，輸入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker images
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就可以查看目前擁有的images&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/fjUHVh9.png"
loading="lazy"
alt="image-20230122023400655"
>&lt;/p>
&lt;p>並且可以這個image可以運行我們剛剛對index的設定，輸入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --name website -p 8080:80 -d website:latest
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：這邊不需要再為website設置volume，因為我們已經將需要的東西打包進image裡面了。&lt;/p>
&lt;p>輸入完後，在URL的地方輸入localhost:8080就可以看到我們剛剛設置的東西了。&lt;/p>
&lt;p>gif如下&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/XvOfKcm.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;p>​&lt;/p>
&lt;h1 id="實際演練-nodejs">實際演練 NodeJs&lt;/h1>
&lt;h2 id="前置作業">前置作業&lt;/h2>
&lt;p>安裝Node.js，這邊安裝為了快速，就直接用Choco來裝了，Choco的安裝如下&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在Terminal中輸入，記得要以系統管理員身分輸入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">Set-ExecutionPolicy Bypass -Scope Process -Force&lt;span class="p">;&lt;/span> &lt;span class="o">[&lt;/span>System.Net.ServicePointManager&lt;span class="o">]&lt;/span>::SecurityProtocol &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>System.Net.ServicePointManager&lt;span class="o">]&lt;/span>::SecurityProtocol -bor 3072&lt;span class="p">;&lt;/span> iex &lt;span class="o">((&lt;/span>New-Object System.Net.WebClient&lt;span class="o">)&lt;/span>.DownloadString&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;https://community.chocolatey.org/install.ps1&amp;#39;&lt;/span>&lt;span class="o">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>安裝完後安裝nodeJs&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">choco install nodejs
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>安裝完後隨便創一個資料夾，這邊命名叫做user-service-api&lt;/p>
&lt;/li>
&lt;li>
&lt;p>切換到該資料夾底下，並且npm init它&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">npm init
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>接著安裝express&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">npm install --save express
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>用好後檔案結構長這樣&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/UfcpwaY.png"
loading="lazy"
alt="image-20230122032825912"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在該目錄底下新增一個index.js的檔案，內容如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">const&lt;/span> &lt;span class="nx">express&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;express&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">app&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">express&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">port&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">3000&lt;/span>
&lt;span class="nx">app&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">res&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">json&lt;/span>&lt;span class="p">([{&lt;/span>
&lt;span class="nx">name&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;Bod&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">email&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="s1">&amp;#39;bob@gmail.com&amp;#39;&lt;/span>
&lt;span class="p">}])&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;span class="nx">app&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">port&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sb">`Example app listening on port &lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nx">port&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="sb">`&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用nodejs運行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">node index.js
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>成功後進入localhost:3000即可看到下列畫面&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/dRynWn4.png"
loading="lazy"
alt="image-20230122033843917"
>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>如此一來前置作業就完成了&lt;/p>
&lt;h2 id="製作dockerfile">製作DockerFile&lt;/h2>
&lt;p>在目錄底下新增dockerfile，內容如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm install&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> node index.js&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>WORKDIR：若Container有/app這個資料夾，則使用它，若沒有，則創造它。&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>ADD . .： 将当前目录中的文件复制到镜像中的 /app 目录。&lt;/li>
&lt;li>RUN npm install： 在鏡像中运行 npm install 命令，安装应用程序所需的依赖项。&lt;/li>
&lt;li>CMD node index.js：设置镜像启动时运行的命令，这里是运行 node index.js。&lt;/li>
&lt;/ul>
&lt;p>為什麼要分成RUN跟CMD呢？有幾個原因，首先RUN跟CMD的用途本身就不一樣，RUN主要是在創建image中執行命令，並將結果保存在image中，它主要用來安裝依賴、配置應用程式或其他操作。則是用來說明Image創建完成後要執行的動作。&lt;strong>簡而言之，RUN是在創建Image中過程所執行的，而CMD則是在Image創建完成後所執行的&lt;/strong>。&lt;/p>
&lt;p>並且，一個DockerFile可以有很多RUN指令，但只能有一個CMD指令，因為Container只能運行一個CMD指令&lt;/p>
&lt;h2 id="使用image">使用Image&lt;/h2>
&lt;p>接著創建鏡像&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker build --tag user-service-api:latest .
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>創建完之後啟動鏡像&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker run --name user-api -d -p 8080:3000 user-service-api:latest
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這邊的&lt;code>8080:3000&lt;/code>是指，將我們容器裡面原本配置的3000端口暴露出來，以8080來接收。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/VSKx5y3.png"
loading="lazy"
alt="image-20230122041621171"
>&lt;/p>
&lt;p>因為3000是指在Container裡面的端口，host想要讀到它，必須將Container的端口暴露出來。因此localhost:3000會找不到東西，只有打localhost:8080才會有我們要的內容&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/vUVU65T.gif"
loading="lazy"
alt="demo"
>&lt;/p>
&lt;h2 id="dockerignore">DockerIgnore&lt;/h2>
&lt;p>做完上面這些操作後，我們的檔案結構長這樣&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/zx4lldH.png"
loading="lazy"
alt="image-20230122042649897"
>&lt;/p>
&lt;p>然後我們的Dockerfile長這樣&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm install&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> node index.js&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>比較之後發現一件事情，RUN npm install會創建node_modules資料夾，但我們在ADD時已經把node_modules加入進去，等於說我們&lt;strong>重複創建&lt;/strong>了兩次node_modules，這種情況就類似gitIgnore，需要排除掉重複的資料夾&lt;/p>
&lt;p>dockerIgnore的寫法&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">node_modules&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>dockerfile&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>.git&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/cw6wiqo.png"
loading="lazy"
alt="image-20230122043320515"
>&lt;/p>
&lt;p>這樣就可以把這些檔案排除在外了&lt;/p>
&lt;h1 id="caching--layers">Caching &amp;amp; Layers&lt;/h1>
&lt;p>DockerFile裡面的每一個CML都是一個Layer，每個Layer都用來Caching`&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> node:latest&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> . .&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> npm install&lt;span class="err">
&lt;/span>&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> node index.js&lt;span class="err">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/qOnozTP.png"
loading="lazy"
alt="image-20230124033035860"
>&lt;/p>
&lt;p>可以看到這邊的Step1, Step2都對應著CML的指令&amp;hellip;&lt;/p>
&lt;p>而Cache的點就在於，其實除了ADD . . 以外(原始碼每次打包時都會有更動)，其實WORKDIR, RUN npm install這些指令其實都是重複的，我們每次打包都需要再重複執行一次，這樣很沒**效率 **&lt;/p>
&lt;p>於是Dokcer就會把這些重複的事情Caching起來，只要沒有改變就不會重複再做，就會看到上面的Using Cache了&lt;/p>
&lt;h1 id="alpine">ALPINE&lt;/h1>
&lt;p>&lt;code>翻譯的意思是高山&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/lHZT25E.png"
loading="lazy"
alt="image-20230124040633982"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/vROHoya.png"
loading="lazy"
alt="image-20230124040527548"
>&lt;/p>
&lt;p>我剛剛打包的Image檔案已經快逼近一個G了，很明顯我們其實不需要那麼多的東西，Alpine版本的就是一個非常小的鏡像。&lt;/p>
&lt;h2 id="實際安裝alpine">實際安裝ALPINE&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker pull node:lts-alpine
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/sOvYX9X.png"
loading="lazy"
alt="image-20230124041533774"
>&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/WiRUr17.png"
loading="lazy"
alt="image-20230124041614756"
>&lt;/p>
&lt;p>兩者的Size差了快十倍&lt;/p>
&lt;h1 id="docker-compose-將後端與資料庫一起包一包">Docker Compose 將後端與資料庫一起包一包&lt;/h1>
&lt;p>一個Project不可能只由一個後端組成，肯定是要由後端、前端、以及資料庫三者組合，甚至更甚者可能會有10,20個的部件需要去組合，那麼一個一個run container這件事情就變得相當缺乏效率。為了處理這件事情，於是有了&lt;strong>Docker-Compose&lt;/strong>的概念出現。&lt;/p>
&lt;p>Docker-Compose大概就像這樣，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.7&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">db&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres-for-dockerpractice&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">root&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_USER&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">root&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_DB&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">root&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">./pgdata:/var/lib/postgresql/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;5432:5432&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend-for-dockerpractice&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">shop&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">db&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;8080:8080&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>和dockerfile一樣存在於專案根目錄中&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/UpKhAur.png"
loading="lazy"
alt="image-20230130235149649"
>&lt;/p>
&lt;p>他類似於一個&lt;strong>配置檔&lt;/strong>，用以告訴Docker要啟動哪些Container，以及它們之間的交互關係，以上面的Docker-compose.yml來說明&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.7&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">//要使用的dokcer-compose版本，有分很多版，比如說1.0,2.0，但目前主流是3.0，所以照著寫就好&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">//每一個起起來的Container有一個特殊的名字，叫做service，這個yaml檔就有兩個service，分別叫db跟backend&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">db&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">//可自定義的service名稱，高興叫啥就叫啥，但這個名字會與你在application.properties裡描述的名稱有對應關係，可以看看下面的附圖，第四行的url:jdbc:postgresql://db:5432/shop，其中的db就是service的名稱&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres-for-dockerpractice //自定義的名稱，想叫啥就叫啥，這名稱會是你的Container名稱&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres //要使用哪個image作為基底&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_PASSWORD&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">45002502&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_USER&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">postgres&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">POSTGRES_DB&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">shop&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">./pgdata:/var/lib/postgresql/data&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;5432:5432&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">//要暴露出來的端口&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">//可自定義的service名稱，高興叫啥就叫啥，但這個名字會與你在application.properties裡描述的名稱有對應關係。&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">backend-for-dockerpractice //自定義的名稱，想叫啥就叫啥，這名稱會是你的Container名稱&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">shop //要使用哪個image作為基底，這個是我自己docker build -t shop:latest . 所創建出來的image&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">db //這意味著，你這邊的service會等到db這個service完成後才會進行部屬。&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="s1">&amp;#39;8080:8080&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">// 暴露出來的端口&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/AMN0bz6.png"
loading="lazy"
alt="image-20230130235821812"
>&lt;/p>
&lt;p>▲第四行的db與services的名稱有對應。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/ksv3RFX.png"
loading="lazy"
alt="image-20230131000230558"
>&lt;/p>
&lt;p>▲上述的docker-compose啟動後顯示的樣子。&lt;/p>
&lt;p>常用的指令&lt;/p>
&lt;p>啟動當前目錄的docker-compose&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker compose up
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>關閉當前目錄的docker-compose&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">docker compose down
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>