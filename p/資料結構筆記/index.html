<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="資料結構的筆記"><title>資料結構筆記</title><link rel=canonical href=https://hoxtonhsu.com/p/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel=stylesheet href=/scss/style.min.b0b89b0dd996a596c4f3b50239e7a6499c1a59da968562fa4649d097368cdb29.css><meta property="og:title" content="資料結構筆記"><meta property="og:description" content="資料結構的筆記"><meta property="og:url" content="https://hoxtonhsu.com/p/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/"><meta property="og:site_name" content="Hoxton"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content><meta property="article:published_time" content="2022-10-08T03:02:43+08:00"><meta property="article:modified_time" content="2022-10-08T03:02:43+08:00"><meta property="og:image" content="https://i.imgur.com/NiqSvey.png"><meta name=twitter:title content="資料結構筆記"><meta name=twitter:description content="資料結構的筆記"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.imgur.com/NiqSvey.png"><link rel="shortcut icon" href=https://cdn-icons-png.flaticon.com/512/92/92031.png><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-9N16MVLR0Q','auto');ga('send','pageview');}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-9N16MVLR0Q"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-9N16MVLR0Q');</script></head><body class=article-page><script>(function(){const colorSchemeKey='StackColorScheme';localStorage.setItem(colorSchemeKey,"dark");})();</script><script>(function(){const colorSchemeKey='StackColorScheme';const colorSchemeItem=localStorage.getItem(colorSchemeKey);const supportDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches===true;if(colorSchemeItem=='dark'||colorSchemeItem==='auto'&&supportDarkMode){document.documentElement.dataset.scheme='dark';}else{document.documentElement.dataset.scheme='light';}})();</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avator_hu6a42c31c76a673cb4138239719c1dd56_73650_300x0_resize_box_2.png width=300 height=301 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Hoxton</a></h1><h2 class=site-description>快樂的CRUD Boy</h2></div></header><ol class=social-menu><li><a href=https://discordapp.com/users/840906423076782082 target=_blank title=Discord><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-discord" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M7.5 7.5c3.5-1 5.5-1 9 0"/><path d="M7 16.5c3.5 1 6.5 1 10 0"/><path d="M15.5 17c0 1 1.5 3 2 3 1.5.0 2.833-1.667 3.5-3 .667-1.667.5-5.833-1.5-11.5-1.457-1.015-3-1.34-4.5-1.5l-1 2.5"/><path d="M8.5 17c0 1-1.356 3-1.832 3-1.429.0-2.698-1.667-3.333-3-.635-1.667-.476-5.833 1.428-11.5C6.151 4.485 7.545 4.16 9 4l1 2.5"/></svg></a></li><li><a href=https://github.com/Hoxton019030 target=_blank title=GitHub><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0c-2.4-1.6-3.5-1.3-3.5-1.3a4.2 4.2.0 00-.1 3.2 4.6 4.6.0 00-1.3 3.2c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.instagram.com/hoxton_8a31/ target=_blank title=Instagram><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-instagram" width="80" height="80" viewBox="0 0 24 24" stroke-width="1.5" stroke="#6f32be" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="4"/><circle cx="12" cy="12" r="3"/><line x1="16.5" y1="7.5" x2="16.5" y2="7.501"/></svg></a></li><li><a href=https://www.linkedin.com/in/hoxton-hsu-298b22269/ target=_blank title=LinkedIn><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-linkedin" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section></div></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/><img src=https://i.imgur.com/NiqSvey.png loading=lazy alt="Featured image of post 資料結構筆記"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%A8%8B%E5%BC%8F/ style=background-color:#2a9d8f;color:#fff>程式</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/>資料結構筆記</a></h2><h3 class=article-subtitle>資料結構的筆記</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Oct 08, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><p>[ToC]</p><h1 id=學習路線>學習路線</h1><h2 id=ch1algorithm-recursion-and-performance-analysisspace--time>Ch1Algorithm, Recursion and Performance Analysis(space + Time)</h2><h2 id=ch3-stack--queue>Ch3 Stack & Queue</h2><h2 id=ch5-tree-and-binary-tree>Ch5 Tree And Binary Tree</h2><h2 id=ch9-advanced-trees>Ch9 Advanced Trees</h2><h2 id=ch7-search-and-usortingu>Ch7 Search and <u>Sorting</u></h2><h2 id=ch8-hasing>CH8 Hasing</h2><h2 id=ch6-graph>Ch6 Graph</h2><h2 id=ch2ch4-arraylinked-list>Ch2/Ch4 Array&Linked List</h2><h1 id=ch1-algorith-recursion-and-performance-analysis>Ch1 Algorith, Recursion and Performance Analysis</h1><blockquote><p>Algo定義(5個Criteria)</p><p>Recursion(遞迴)☆☆☆☆☆</p><blockquote><p>定義</p><p>種類</p><p>與 Non-Recursion比較考型及來源</p></blockquote><p>效能分析</p><blockquote><p>Space(較少考)</p><p>Time(較常考)☆☆☆☆☆</p></blockquote></blockquote><h2 id=algorithm演算法>Algorithm(演算法)</h2><ul><li>定義：為了解決特定問題之有限個敘述／步驟／指令所構成之集合，且必須滿足下列<strong>５</strong>個Criteria：</li></ul><ol><li>Input：輸入的資料量>=0個即可</li><li>Output：至少要有>=1個輸出量</li><li>Definiteness(明確性)：每個敘述／步驟／指令必須是Clear且unambiauous(不可混淆不清)。<code>3之要求在於Algo之寫作格式無一致標準之規範</code></li><li>Finiteness(有限性)：必須在執行／追蹤有限個步驟後，必能夠終止</li><li>Effectiveness(有效性)：人可以用紙和筆追蹤／執行每一個步驟，即每一個Step is baisc enough to be carried。<code>當log完成，你如何確定它是正確的</code></li></ol><h2 id=recurtion遞迴>Recurtion(遞迴)</h2><ul><li><p>定義：(以Direct Recursion為例)，Algo/program中含有==<strong>self-calling(自我呼叫)</strong>==敘述存在者，稱之遞迴</p></li><li><p>種類：</p><ol><li>Direct：直接遞迴</li><li>Indirect：間接遞迴</li><li>Tail：尾端遞迴</li></ol></li><li><p>分述如下</p><ol><li><p>直接遞迴：方法中直接呼叫自己</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>function</span> <span class=nf>A</span><span class=p>(){</span>
    <span class=c1>// do something
</span><span class=c1></span>    <span class=k>if</span><span class=p>(...)</span> <span class=n>then</span>  <span class=n>A</span><span class=p>();</span> <span class=c1>//重複自己
</span><span class=c1></span>    <span class=k>else</span><span class=p>{</span>
    <span class=c1>// do something
</span><span class=c1></span>    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li><li><p>間接遞迴：多個Module之間彼此形成Calling Cycle，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>function</span>  <span class=nf>A</span><span class=p>(){</span>
    <span class=c1>//something
</span><span class=c1></span>    <span class=n>Call</span> <span class=n>B</span><span class=p>();</span> <span class=c1>//相互呼叫
</span><span class=c1></span>    <span class=c1>//something
</span><span class=c1></span><span class=p>}</span>
     
<span class=n>function</span> <span class=nf>B</span><span class=p>(){</span>
    <span class=c1>//something
</span><span class=c1></span>    <span class=n>Call</span> <span class=n>A</span><span class=p>();</span> <span class=c1>//相互呼叫
</span><span class=c1></span>    <span class=c1>//something
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div></li><li><p>尾端遞迴：是Direct Recustion 之一種，recursive call發生在程式即將結束之前一行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>function</span> <span class=nf>A</span><span class=p>(){</span>
    <span class=c1>//do something
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>xxx</span><span class=p>){}</span> <span class=n>then</span> <span class=n>A</span><span class=p>()</span> <span class=c1>//程式的最後一行 優點是Complier或工程師方便改寫成非遞迴的形式(降低時間複雜度
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ol></li></ul><p><strong>任何problem之解決，必定存在兩種形式之Algo</strong></p><ol><li>遞迴</li><li>非遞迴(Interation)</li></ol><p>eq. 求n! 求費氏數列</p><p><img src=https://i.imgur.com/dIbSOTs.png loading=lazy alt=image-20230212130259106></p><p>比較圖如下</p><div class=table-wrapper><table><thead><tr><th>Recursion</th><th>Non-Recursion</th></tr></thead><tbody><tr><td><strong>程式碼較為精簡</strong></td><td>冗長</td></tr><tr><td>較少，或沒有使用區域變數</td><td>使用到區域變數來保存中間值，Loop控制等等</td></tr><tr><td><strong>程式碼占的儲存空間</strong>比較少</td><td>程式碼占用的儲存空間較多</td></tr><tr><td>表達力較強(powerful)</td><td>表達力較弱(weak)</td></tr><tr><td>==<strong>執行的時間較久，較沒效率</strong>==</td><td>執行時間較短，較有效率</td></tr><tr><td>==<strong>需要額外的stack space支持</strong>==</td><td>不需要這東西</td></tr></tbody></table></div><ul><li>補充</li></ul><p>在complier或程式語言的課程裡面，會<strong>討論如何處理recursion?</strong></p><ol><li><p>當遇到Recursive call的時候，</p><ol><li>必須先保存當時執行狀況，push這些東西</li></ol><blockquote><ol><li>參數值</li><li>區域/占存 變數值</li><li>返回位址(return address)</li></ol></blockquote><p>到System <strong>stack</strong></p><ol start=2><li>Jump to 程式開端執行</li></ol></li><li><p>若遇到程式結束(END)敘述時<code>遞迴條件不符合，繼續往下執行，遇到程式的END，要判斷是某一次的遞迴結束，還是整個都結束了。判斷的依據是查看Stack區是否為空，若為空則代表只是一次的遞迴結束，若Stack為空，則代表整個程式結束</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>stack</span> <span class=n>is</span> <span class=n>empty</span><span class=p>)</span> <span class=n>then</span> <span class=err>整個結束</span>
    <span class=k>else</span><span class=p>{</span>
        <span class=n>pop</span> <span class=n>stack</span><span class=p>;</span> <span class=c1>//取出當時保存的參數或區域變數以及返回位置(return address) then go to &#34;return address&#34;執行
</span><span class=c1></span>        <span class=c1>//所謂的return address(返回位址，就是指遞迴結束完後，下一個會執行的程式碼)
</span><span class=c1></span>    <span class=p>}</span>
</code></pre></td></tr></table></div></div><p>例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>function</span> <span class=nf>A</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>){</span> 
    <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>y</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
    <span class=n>a</span><span class=o>++</span><span class=p>;</span>
    <span class=k>if</span><span class=p>(</span><span class=n>xxx</span><span class=p>)</span> <span class=n>then</span> <span class=n>A</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>//recursive call
</span><span class=c1></span>    <span class=k>else</span><span class=p>{</span>
<span class=c1>//do something
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=p>(</span><span class=err>這就是返回位址</span> <span class=p>(</span><span class=mi>1</span><span class=o>:</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li></ol><p><img src=https://i.imgur.com/7uzIEQg.png loading=lazy alt=image-20230212135153292></p><p><img src=https://i.imgur.com/7JDHEkJ.png loading=lazy alt=image-20230212135446234></p><h3 id=考型及來源>考型及來源</h3><p>考型：</p><blockquote><ol><li>給一個Probleam，寫下Recursive algo/code</li><li>給Recursive algo/code，要我們追蹤結果 etc&mldr;</li></ol></blockquote><p>來源：</p><blockquote><ol><li>數學類：階層</li><li>往後章節(二元樹的追蹤、圖形的追蹤、排序的追蹤&mldr;)</li><li>其他</li></ol><blockquote><ol><li>Tower fo Hanoi</li><li>permutation printing</li></ol></blockquote></blockquote><h4 id=數學類>數學類</h4><ol><li>寫下一個非遞迴的求階層方法</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>fac</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>0</span><span class=p>){</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span><span class=k>else</span> <span class=c1>// n&gt;0{
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>S</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
    	<span class=kt>int</span> <span class=n>i</span> <span class=p>;</span>
    	<span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
            <span class=n>S</span><span class=o>=</span><span class=n>S</span><span class=o>*</span><span class=n>i</span><span class=p>;</span>
            <span class=k>return</span> <span class=n>S</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>   
<span class=p>}</span>
</code></pre></td></tr></table></div></div><ol start=2><li><p>寫下一個用遞迴處理的求階程式</p><p>==關鍵點：記下數學遞迴定義式==</p><p><img src=https://i.imgur.com/taUXn8C.png loading=lazy alt=image-20230212145854185></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>fac</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>0</span><span class=p>){</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
      <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>fac</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li><li><p>以2的Code為題目</p><ol><li><p>求Fac(3)</p><p><img src=https://i.imgur.com/5TgPcuk.png loading=lazy alt=image-20230212145917501></p></li><li><p>共呼叫Fac函數?次，含Fac(3)這次<code>這影響到了時間複雜度，以及會調用幾次pop</code></p><p>4次，<code>Fac(n)共呼叫幾次=n+1次</code></p></li></ol></li><li><p>write a recursive algo for sum(n)= 1+2+&mldr;+n, and sum(0)=0;</p><p><img src=https://i.imgur.com/7JkNHxN.png loading=lazy alt=image-20230212150912005></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>0</span><span class=p>){</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=k>return</span> <span class=n>n</span><span class=o>+</span><span class=n>sum</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li><li><p>Fibonacci Number(費氏數列)</p><p><img src=https://i.imgur.com/T5k9DFx.png loading=lazy alt=image-20230212151908181></p><div class=table-wrapper><table><thead><tr><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th></tr></thead><tbody><tr><td>Fn</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td><td>144</td><td>233</td></tr></tbody></table></div><p>Q：F98 = ? + ? = ? - ? = ? - ?</p><ol><li>F97+F96;</li><li>F99-F97;</li><li>F100-F99;</li></ol><p>Q：不超過500之費氏數列</p><p>​ A. F14 = 377</p></li><li><p>Write a recursive algo/code for Fibonacci</p><ol><li>遞迴解法</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int Fib(int n){
if(n==0){ return 0;}
if(n==1){return 1;}
return Fib(n-1)+Fib(n-2);
}
</code></pre></td></tr></table></div></div><ol start=2><li>非遞迴解法</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>Fib</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>0</span><span class=p>){</span>
        <span class=k>return</span> <span class=mi>0</span>
    <span class=p>}</span><span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>1</span><span class=p>){</span>
        <span class=k>return</span> <span class=mi>1</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span><span class=mi>0</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>c</span> <span class=p>;</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=p>;</span>
        <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
            <span class=n>c</span><span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
            <span class=n>a</span> <span class=o>=</span><span class=n>b</span> <span class=p>;</span>
            <span class=n>b</span> <span class=o>=</span> <span class=n>c</span> <span class=p>;</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>c</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th>Fo</th><th>F1</th><th>F2</th><th>F3</th><th>&mldr;</th></tr></thead><tbody><tr><td>a=0</td><td>b=1</td><td>c=a+b<br>a=b<br>b=c</td><td>c=a+b<br>a=b<br>b=c</td><td>&mldr;</td></tr></tbody></table></div></li><li><p>依(1)之code，(i)求出Fib(5)之值(ii)呼叫次數?次(iii)Fib(10)的呼叫次數呢?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int Fib(int n){
if(n==0){ return 0;}
if(n==1){return 1;}
return Fib(n-1)+Fib(n-2);
}
</code></pre></td></tr></table></div></div><p>ans .</p><p>(i) 5</p><p>(ii)<img src=https://i.imgur.com/9rkgJtk.png loading=lazy alt=image-20230220000219053></p><p>(iii)<img src=https://i.imgur.com/ed9zsLC.png loading=lazy alt=image-20230220001353812></p><ol start=4><li><p>令T<sub>(n)</sub>代表求Fin(n)時之呼叫次數，即T(0)=T(1)=1次，(i)寫出T(n)之Recursive definition(ii)Based on (i)，求出T(10)之值</p><p>ans . (i) T(n) = T(n-1)+T(n-2)+1 且 T(0) =T(1) = 1;</p><p>​ (ii)</p><div class=table-wrapper><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>3</td><td>5</td><td>9</td><td>15</td><td>25</td><td>41</td><td>67</td><td>109</td><td>177</td></tr></tbody></table></div></li><li><p>求Fib(5)時，則Fib(0),Fib(1),Fib(2),Fib(3),Fib(4),Fib(5),分別被呼叫?次</p><div class=table-wrapper><table><thead><tr><th>Fib(n)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>呼叫幾次</td><td>3</td><td>5</td><td>3</td><td>2</td><td>1</td><td>1</td></tr></tbody></table></div><p>5只會自己生自己，4只會由5產生，3會由4跟5產生(1+1)，2則是由3跟4產生(2+1)，1會由2跟3產生(3+5)，但0只會由2產生，不會由0產生。</p></li><li><p>接續上題，那Fib(10)呢?</p><div class=table-wrapper><table><thead><tr><th>Fin(n)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>呼叫幾次</td><td>34</td><td>55</td><td>34</td><td>21</td><td>13</td><td>8</td><td>5</td><td>3</td><td>2</td><td>1</td><td>1</td></tr></tbody></table></div></li><li><p>令T(n)代表求Fib(n)時之加法次數</p><p>(i)求出T(n)之recursive definition</p><p>(ii)求T(5)之值 based on(i)</p><p>ans</p><p>(i) T(n)=T(n-1)+T(n-2)+1，且T(0)=0,T(1)=0</p><div class=table-wrapper><table><thead><tr><th>Fib(n)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>呼叫幾次</td><td>0</td><td>0</td><td>1</td><td>2</td><td>4</td><td>7</td><td>12</td><td>20</td><td>33</td></tr></tbody></table></div></li><li><p>code如下，求F(5)之值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int Fib(int n){
if(n==0 || n==1){return 1}
return F(n-1)+F(n-2)
}
</code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th>Fib(n)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>值</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td></tr></tbody></table></div></li><li><p>code如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int Fib(int n){
if(n&lt;1){return 0}
if(n&lt;3){return 1}
return Fib(n-1)+Fin(n-2)
}
</code></pre></td></tr></table></div></div><p>(i)求Fib(5)之值</p><div class=table-wrapper><table><thead><tr><th>Fib(n)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>值</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td></tr></tbody></table></div><p>(ii)呼叫Fib函數?次(含Fib(5))</p><p><img src=https://i.imgur.com/cR8M7qZ.png loading=lazy alt=image-20230220214503733></p></li><li><p>Binomical coe(二項式係數)</p></li></ol><p>​</p><p>$$
{C_m}^n =(\underset{m}{\overset{n}{{}}})=\frac{n!}{m!(n-m)!}
$$</p></li></ol><p>​</p><p>$$
(i)write a recursive algo / code 求 (\underset{m}{\overset{n}{{}}})之值
$$</p><p>ans. 關鍵，==<strong>必背</strong>==</p><p>$$
(\underset{m}{\overset{n}{{}}})=<br>\begin{cases}
& 1, \text{ if } (n = m \text{ or } m = 0) \<br>& (\underset{m}{\overset{n-1}{{}}})+(\underset{m-1}{\overset{n-1}{{}}})
\end{cases}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int Bin(int n , int m){
if(n==m || m==0){return 1}
else{
return Bin(n-1,m)+Bin(n-1,m-1)
}
}
</code></pre></td></tr></table></div></div><p>(ii) based on (i) code 求Bin(5,3)之值及呼叫次數</p><p><img src=https://i.imgur.com/8VKJjX9.png loading=lazy alt=image-20230220232145991></p><p>ans 10 ,19次</p><p>Note ：計算時有些撇步</p><p>$$
(\underset{3}{\overset{5}{{}}}) = \frac{5\times4\times3}{1\times2\times3}=10
$$</p><p>$$
(\underset{4}{\overset{8}{{}}}) = \frac{8\times7\times6\times5}{1\times2\times3\times4}=70
$$</p><ol start=12><li>GCD(A,B) 求A,B兩數之最大公因數，寫出recursive algo/code</li></ol><p>==<strong>☆☆☆☆☆☆☆☆☆要背☆☆☆☆☆☆☆☆☆☆☆☆</strong>==</p><p>$$
GCD(A,B)=\ \begin{cases}
& B, \text{ if } (A modsB)=0 \<br>&GCD(B,AmodsB), other wise
\end{cases}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int GCD(int A,int B){
if (A%B==0) {return B}
else return GCD(B,A%B)
}
</code></pre></td></tr></table></div></div><p>依上述code，試求(1)求GCD(18,33)之值(2)呼叫GCD?次</p><p><img src=https://i.imgur.com/JkzUfwK.png loading=lazy alt=image-20230221000814907></p><ol start=13><li>Ackerman&rsquo;s Function <code>一坨大便，幹破你娘</code></li></ol><p>$$
A(m,n) = \begin{cases}
n+1, & \text{if } m=0\<br>A(m-1,1), & \text{if } n=0\<br>A(m-1,A(m,n-1)), & \text{otherwise}
\end{cases}
$$</p><p>(i) A(2,2)=?</p><p>ans.</p><p>A(2, 2) =7</p><p>(ii) A(10,10)
ans.</p><p>A(10, 10) = A(9, A(10, 9))
= A(9, A(9, A(10, 8)))
= A(9, A(9, A(9, A(10, 7))))
= A(9, A(9, A(9, A(9, A(10, 6)))))
= A(9, A(9, A(9, A(9, A(9, A(10, 5))))))
= A(9, A(9, A(9, A(9, A(9, A(9, A(10, 4)))))))
= A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(10, 3))))))))
= A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(10, 2)))))))))
= A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(10, 1))))))))))
= A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, A(9, 1))))))))))
≈ 2.1216 x 10^19728</p><p>(iii)A(1,3)</p><p>A(1, 3) = A(0, A(1, 2))
= A(0, A(0, A(1, 1)))
= A(0, A(0, A(0, A(1, 0))))
= A(0, A(0, A(0, A(0, 1))))
= A(0, A(0, A(0, 1)))
= A(0, A(0, 2))
= A(0, 3)
= 4</p><p><strong>常考排行</strong></p><p>A(2,2) = 7</p><p>A(2,1) = 5</p><p>A(1,2) = 4</p><p>A(2,3)= 9</p><ol start=14><li>求x<sup>n</sup>，其中x,n是integer，且n ≧ 0 , write a recursive algo/ code</li></ol><p>ans</p><p>$$
x^n=
\begin{cases}
1&\text {if}(n==0) \
x \times x^{n-1}&\text {if} (n>0)
\end{cases}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>int exp(int x,int n){
if (n==0){return 1}
else{
return Exp(x,n-1)*x
}
}
</code></pre></td></tr></table></div></div><ol start=15><li></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>%</span><span class=mi>2</span><span class=o>==</span><span class=mi>0</span><span class=p>){</span>
        <span class=n>f</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=n>f</span><span class=o>=</span><span class=n>x</span>
    <span class=p>}</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>){</span>
        <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>f</span><span class=o>*</span><span class=n>foo</span><span class=p>(</span><span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>n</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>(i) 求foo(2,5)值</p><p>​ <img src=https://i.imgur.com/GvgDjdH.png loading=lazy alt=image-20230223220045068></p><p>(ii)求foo(x,n)之功能</p><p>​ 求x<sup>n</sup></p><p>(iii)求foo(x,n)之Time Complexity</p><p>​ O(log<sub>n</sub>)</p><h4 id=河內塔towers-of-hanai>河內塔(Towers of Hanai)</h4><p><img src=https://i.imgur.com/dj1RFAh.png loading=lazy alt=image-20230223232944377></p><p>程式如下：</p><p>Hanoi(n,x,y,z);</p><p>n：盤數</p><p>x：來源</p><p>y：占存地</p><p>z：目的地</p><p>Step1 Hanoi(n-1,A,C,B);</p><p>Step2 Hanoi(1,A,B,C);</p><p>Step3 Hanoi(n-1,B,A,C);</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>Hanoi</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=kt>char</span> <span class=n>A</span><span class=p>,</span><span class=n>Char</span> <span class=n>B</span><span class=p>,</span> <span class=n>Char</span> <span class=n>C</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>==</span><span class=mi>1</span><span class=p>){</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;move disk %d from %c to %c </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>n</span><span class=p>,</span><span class=n>A</span><span class=p>,</span><span class=n>C</span><span class=p>);</span>
    <span class=p>}</span><span class=k>else</span> <span class=c1>//n&gt;1{
</span><span class=c1></span>        <span class=n>Hanoi</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>A</span><span class=p>,</span><span class=n>C</span><span class=p>,</span><span class=n>B</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;move disk %d from %c </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>n</span><span class=p>,</span><span class=n>A</span><span class=p>,</span><span class=n>C</span><span class=p>);</span>
    	<span class=n>Hanoi</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>B</span><span class=p>,</span><span class=n>A</span><span class=p>,</span><span class=n>C</span><span class=p>);</span>
    	
<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=permutation列印>Permutation列印</h4><p>將[a,b,c]以不同的排列組合印出來</p><p>如</p><p>abc</p><p>acb</p><p>bac</p><p>bca</p><p>cba</p><p>cab</p><p>有3!=6種寫法</p><p>以遞迴的概念來理解</p><p><img src=https://i.imgur.com/VJL10za.png loading=lazy alt=image-20230308214715912></p><p>原始碼的部分</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>perm</span><span class=p>(</span><span class=kt>char</span> <span class=n>list</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=c1>//產生list[i]~list[n]之排列組合
</span><span class=c1></span>    <span class=c1>//i≦n
</span><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>==</span><span class=n>n</span><span class=p>){</span> <span class=c1>//代表遞迴中止
</span><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
            <span class=n>printf</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span> <span class=c1>// for each完後印出當時list的內容
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
            <span class=n>swap</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>list</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span> <span class=c1>// list[j]做頭
</span><span class=c1></span>            <span class=n>perm</span><span class=p>(</span><span class=n>list</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>n</span><span class=p>);</span> <span class=c1>//接(i+1)~(n)之perm
</span><span class=c1></span>            <span class=n>swap</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>list</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=c1>// 還原成原本List的內容
</span><span class=c1></span>        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>實際演練</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>main</span><span class=p>(){</span>
    <span class=kt>char</span> <span class=n>list</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>};</span>
    <span class=n>Perm</span><span class=p>(</span><span class=n>list</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><img src=https://i.imgur.com/Eiyo3mb.jpg loading=lazy alt=1914A818-E923-4D51-854B-57E4AB2A9C3F></p><h2 id=performance-analysis效能分析>Performance Analysis(效能分析)</h2><p>Algo/code之效能分析，主要分析兩點</p><ol><li>Space</li><li>Time</li></ol><h2 id=space空間需求分析>Space(空間)需求分析</h2><p>定義：令SP(P)代表Algo/Code P 之空間需求，則SP(P)= <strong>Fixed</strong> Space requirement + <strong>Variable</strong> Space Requirement</p><p>固定(Fixed)空間需求= Instruction (or Code) Space <code>意即你寫了幾行的程式</code>+變數+常數空間 =<strong>C</strong>(mean Constant)</p><p>變動(Varialbe)空間需求=</p><p>主要有兩個來源</p><ol><li>若參數為結構型態(Array, Struct)且<strong>採用Call-By-Value參數傳遞方式</strong>(若是用Call-By-Address則也不是變動空間，因為只收一個Address的起始位址而已)</li><li>遞迴(recursion)所需之stack space (堆疊空間)</li></ol><p>因此主要的分析是在變動空間需求這邊</p><p>SP(P)= C + SP(i)</p><p>範例</p><p>求SP(i)=?</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>rsum</span><span class=p>(</span><span class=n>floot</span> <span class=n>list</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>){</span>
    <span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=o>!=</span><span class=mi>0</span><span class=p>){</span>
        <span class=k>return</span> <span class=n>rsum</span><span class=p>(</span><span class=n>list</span><span class=p>,</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=o>+</span><span class=n>list</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=p>}</span>
<span class=c1>// 此外，假設 floot 佔4 bytes, int佔2bytes pointr(address)佔2bytes, List[]採用Call-by-address傳遞
</span><span class=c1></span>
</code></pre></td></tr></table></div></div><p>Ans.SP(i)= Stack Space for recursion</p><p>如何計算?</p><ul><li><p>每發生一次遞迴的呼叫(recusive call)，我們需要將</p><ul><li><p>參數值 <code>list[] 佔2byte,因為是call by address。n 佔2bytes</code></p></li><li><p>區域變數值<code>無</code></p></li><li><p>Return Address<code>一定有，題目說是2Byte</code></p><p><strong>Push 6 byte per recursive call</strong></p><p>又共發生<strong>n</strong>次recursive call(不含rsum(list,n))</p></li></ul></li></ul><p>因此Sp(i)= 6n bytes</p><h2 id=time時間需求分析>Time(時間)需求分析</h2><p>定義：令T(P)代表Algo,code P之時間需求，則T(P)=Development time(開發時間) + Execution Time</p><p>只注重/討論 Execution Time分析in DS/Algo課程</p><p>Execution Time之評量有兩個方法</p><ol><li>Measurement(實際量度)</li><li><strong>Analysis</strong>(分析、預估)\</li></ol><p>本課程是採用Analysis方式，Analysis是以Algo/Code的指令執行總次數，作為分析Time之基礎</p><p>範例1. 不考慮指令之難易度</p><p>eq. 整數除法 a/b，浮點數除法 a/b視為一樣</p><p>原始code如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=n>i</span><span class=err>≦</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
    <span class=n>a</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>Then, 宣告一個Global變數，Count=0，在適當處加入Count++之敘述</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=n>i</span><span class=err>≦</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
    <span class=n>count</span><span class=o>++</span><span class=p>;</span> <span class=c1>//用來統計for做幾次
</span><span class=c1></span>    <span class=n>a</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
    <span class=n>count</span><span class=o>++</span> <span class=c1>//統計 a=a+b做幾次
</span><span class=c1></span><span class=p>}</span>
<span class=n>count</span> <span class=o>++</span><span class=p>;</span><span class=c1>// for最後失敗的那一次，跳出for迴圈，實際上還是有做，因此要補上
</span><span class=c1></span><span class=n>conut</span><span class=o>++</span><span class=p>;</span> <span class=c1>//用來統計下面的return
</span><span class=c1></span><span class=k>return</span> <span class=n>a</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>T(P)= 指令執行次數之統計= 2n+1+1(每行被執行了幾次)=2n+2次</p><p>範例2. 考慮指令之難易程度</p><div class=table-wrapper><table><thead><tr><th>Source Code</th><th>S/E</th><th>Frequency</th><th>Total</th></tr></thead><tbody><tr><td>for(i=1;i≦n;i++)</td><td>4</td><td>n+1</td><td>4n+4</td></tr><tr><td>{a=a+b}</td><td>2</td><td>n</td><td>2n</td></tr><tr><td>return a</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td></td><td></td><td>6n+5</td></tr></tbody></table></div><p>利用S/E (Steps per Execution<code>每執行一次要花幾步，開心要怎麼定就怎麼定</code>)區別指令難易程度 S/E高，代表較難</p><h2 id=研究所的time分析考型>研究所的Time分析考型</h2><ol><li><p>計算某行指令執行次數</p></li><li><p>Asymptotic<code>漸進式</code> Notations<code>符號</code>定義、大小、定理</p><p>(O,Ω,θ,o,w)</p></li><li><p>Recursive time function遞迴時間函數計算/求解 (eq. Honai Tower:T(n)+2*T(n-1)+1)</p></li><li><p>給一遞迴演算法Recursive algo/code寫出Time Function求解</p></li></ol><p>[006]</p><h2 id=複習-數學公式>[複習] 數學公式</h2><ol><li><p>等差數列</p><p>公式：(首項＋尾項) * 項數 / 2</p></li><li><p>等比數列</p><p>公式：((最高項)<sup>exp+1</sup>- (最低項))/公比-1</p><p>範例：r<sup>0</sup>+r<sup>1</sup>+r<sup>2</sup>+&mldr;+r<sup>n</sup> = (r<sup>n+1</sup>-1) / r-1 = (r<sup>n+1</sup> -r<sup>0</sup>)/(r-1)</p></li><li><p>平方和公式：</p><p>公式：(n(n+1)(2n+1))/6</p><p>範例：1<sup>2</sup>+2<sup>2</sup>+3<sup>2</sup>+&mldr;+n<sup>2</sup></p></li><li><p>Σ i<sup>d</sup> 約莫是 n<sup>d+1</sup>的多項式，d ≧之 int</p></li><li><p>Σ 1/i = log n (底數為2) (調和數列)</p></li><li><p>排列組合 C幾取幾之計算</p></li><li><p>n!之相關式子</p><ol><li>n! = 1* 2 * &mldr; n ≦ n * n * n =n<sup>n</sup></li><li>n! ≧ (n/2) <sup>n/2</sup> (離散)</li><li>Striling&rsquo;s 公式</li><li>n ! ≒ n <sup>n+(1/2)</sup> * e<sup>-n</sup>, e 為自然對數之底</li></ol></li><li><p>Σ i x 2 <sup>i</sup> 解法為</p><p>令S= Σ i x 2 <sup>i</sup>，因此S= 1x2 +2x2 <sup>2</sup> + 3x3<sup>3</sup>+&mldr;nx2<sup>n</sup>，兩邊同x2，為</p><p>2S = 1x2<sup>2</sup> +2x2 <sup>3</sup> + 3x3<sup>4</sup>+&mldr;nx2<sup>n+1</sup></p><p>然後兩邊相減，得出 S = -2<sup>1</sup>-2<sup>2</sup>-2<sup>3</sup>-&mldr;-2<sup>n</sup> + n* 2 <sup>n+1</sup>=經過很多推導之後=n*2<sup>n+1</sup>-2<sup>n+1</sup>+2</p><p><img src=https://i.imgur.com/IzFs5at.png loading=lazy alt=image-20230422162944363></p><p>Note：其他相似型也是如此求法</p><p><img src=https://i.imgur.com/FW5KmGA.png loading=lazy alt=image-20230422162934574></p></li><li><p>對數系列(底數預設為2)</p><p><img src=https://i.imgur.com/SWCurg3.png loading=lazy alt=image-20230424225728499></p><p><img src=https://i.imgur.com/SuDvTIq.png loading=lazy alt=image-20230422164130892></p><p><img src=https://i.imgur.com/nMuKk2l.png loading=lazy alt=image-20230422164402270></p><p><img src=https://i.imgur.com/jYTm1Fo.png loading=lazy alt=image-20230422164740452></p><p><img src=https://i.imgur.com/uZrADYQ.png loading=lazy alt=image-20230422165056867></p></li></ol><h2 id=給code求某行指令執行次數或big-oh>給Code，求某行指令執行次數或Big-Oh</h2><p>例１</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>for i = 1 to n do
	for j = 1 to n do
		x++;

求x ++ 執行次數
ans :　ｎ＊ｎ次
</code></pre></td></tr></table></div></div><p>例２</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>for i = 1 to n do
	for j = 1 to i do
		x++;

求x ++ 執行次數
ans :　(1+n)*n/2次

</code></pre></td></tr></table></div></div><p><span style=color:#ff0>針對i++, i&ndash;之 Loop，可用級數求解</span></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-ps data-lang=ps><span class=nf>for</span> <span class=nf>i</span> <span class=nf>=</span> <span class=mf>1</span> <span class=nf>to</span> <span class=nf>n</span> <span class=nf>do</span>
	<span class=nf>for</span> <span class=nf>j</span> <span class=nf>=</span> <span class=nf>i</span> <span class=nf>to</span> <span class=nf>n</span> <span class=nf>do</span>
		<span class=nf>x++;</span>

<span class=nf>求x</span> <span class=nf>++</span> <span class=nf>執行次數</span>
<span class=nf>ans</span> <span class=nf>:</span>　<span class=nf>n+</span><span class=s>(n-1)</span><span class=nf>+</span><span class=s>(n-2)</span><span class=nf>...+1</span> <span class=nf>=</span> <span class=s>(n+1)</span><span class=nf>n</span><span class=nv>/2</span>
</code></pre></td></tr></table></div></div><p><img src=https://i.imgur.com/P9HN3rX.png loading=lazy alt=image-20230422171306799></p><p><img src=https://i.imgur.com/ItHy0Kw.png loading=lazy alt=image-20230422171624148></p><p>​</p><p><span style=color:#ff0;font-size:32px>太基本，直接跳過</span></p><p>[007]</p><p>例題一</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>for i = 1 to n do
	for j = 1 to n*n
		if(j%i ==0) then
			for k = 1 to j do
				x++
</code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th>i=1</th><th>i=2</th><th>i=3</th></tr></thead><tbody><tr><td>j=1 to 1</td><td>j=1 to 4</td><td>j= 1 to 9</td></tr><tr><td>j % i ==0 when j=1</td><td>j % i == 0 when j = 2 and 4</td><td>j % i ==0 when j = 3 ,6 and 9</td></tr><tr><td>1次</td><td>2+4次</td><td>3+6+9次</td></tr></tbody></table></div><p>若i=4時，x會加 4+8+12+16次，也就是4(1+2+3+4)，若i是n時，x會加</p><p>n(1+2+..+n)次 = n((1+n)*n)/2</p><p><img src=https://i.imgur.com/M2zZgGv.png loading=lazy alt=image-20230422231955941></p><h2 id=asymptotic-notations>Asymptotic Notations</h2><p>漸進式符號</p><p>目的：表示時間函數之<span style=color:#ff0>成長速率(Growth rate)之等級</span></p><p>符號種類：</p><ol><li>Big-Oh：O</li><li>Omega：Ω</li><li>Theta：θ</li><li>Little-Oh：o</li><li>Little-Omega：ω</li></ol><h2 id=big-oh>Big-Oh</h2><p>小於等於</p><p>定義：F(n)= O(g(n)) iff<code>(若且為若)</code> exitst two postitive constatnts C and N0 such that f(n)≦ C* g(n)，對所有n≧N0</p><p>Note：Big-Oh代表理論之上限值(upper-Bound)</p><p>例：f(n)=5n<sup>2</sup>+8n-3，則f(n) = O(n<sup>2</sup>)</p><p>proof：<span style=color:#ff0>可找到兩個正常數，C=6,N0=8，使得5n<sup>2</sup>+8n-3≦C*n<sup>2</sup></span>，所以f(n) = O(n<sup>2</sup>)</p><p>解法如下，通常會先取最大次項的項數，將他+1</p><p><img src=https://i.imgur.com/uckRsKC.png loading=lazy alt=image-20230423000037106></p><p>例：f(n) = 3n<sup>2</sup>+8，則f(n)=O(n)是錯的</p><p><img src=https://i.imgur.com/7wTxgD1.png loading=lazy alt=image-20230423115002262></p><p><span style=color:#ff0>例：log(n!) = O (nLogn) ☆☆☆☆</span></p><p>ans</p><p><img src=https://i.imgur.com/COCV1GI.png loading=lazy alt=image-20230423120053961></p><p><span style=color:#ff0>例</span></p><p><img src=https://i.imgur.com/ODQ2Db1.png loading=lazy alt=image-20230423123121376></p><p>例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>for (i=1;i&lt;=n;i++)
	for(j=1; j&lt;=i; j*=2)
		x++;
</code></pre></td></tr></table></div></div><p>求此Code之Time=O(?)</p><p><img src=https://i.imgur.com/drPI5Oh.png loading=lazy alt=image-20230423125327318></p><h2 id=比較growth-rate等級之大小>比較Growth rate等級之大小</h2><h3 id=例１基本型>例１：基本型</h3><p>Growth rate：小 &mdash;> 大</p><p><img src=https://i.imgur.com/Yzd1ovw.jpg loading=lazy alt=DB4B4E61-ACB1-4F58-8C3C-D94677DE7245></p><h3 id=例2複雜型請參閱課本>例2：複雜型，請參閱課本</h3><p>[007 1:24:00]</p><p><img src=https://i.imgur.com/Y8PH2iI.png loading=lazy alt=image-20230423162117827></p><p><img src=https://i.imgur.com/85DpOvR.png loading=lazy alt=image-20230423163630068></p><p>[008]</p><p>例題：</p><p><img src=https://i.imgur.com/Z024vlN.jpg loading=lazy alt=FAED04D9-F436-461C-A483-6A3CBDFA0D98></p><p>例題：</p><p><img src=https://i.imgur.com/3KVL7aZ.jpg loading=lazy alt=C965C8BB-F7B7-4E1B-AEF3-7F823DDECE9C></p><p>例三</p><p><img src=https://i.imgur.com/tl5TJJa.jpg loading=lazy alt=F72EDF02-DD51-4AB7-9028-5383349D5350></p><h2 id=omega-ω>Omega Ω</h2><p>大於等於</p><p>定義：f(n)=Ω(g(n) iff exists two positive constants C and no. such that f(n)≧ c.g(n)，對所有大於N0的n而言</p><p>Note：Ω視為理論之下限值(low-bound)</p><p>例題：</p><p><img src=https://i.imgur.com/MdsuGk5.png loading=lazy alt=image-20230425222040787></p><p>例題</p><p><img src=https://i.imgur.com/1rloQWg.png loading=lazy alt=image-20230425223102662></p><h2 id=theta-θ>Theta θ</h2><p>定義：f(n)= θ (g(n)) iff exists <span style=color:#ff0>three</span> positive constrants <span style=color:#ff0>C1, C2, and N0</span>, such that，<span style=color:#ff0>C1*g(n) ≦ f(n) ≦C2*g(n)，對所有大於n0的n而言。</span></p><p>Note：</p><ol><li>θ is more <span style=color:#ff0>precise</span> than O and Ω</li><li>f(n) = <span style=color:#ff0>θ (n)</span></li><li>f(n) = O(g(n)) and f(n) = Ω(g(n))</li></ol><p>例：</p><p><img src=https://i.imgur.com/6fAUJIr.png loading=lazy alt=image-20230427002152181></p><p>例：</p><p><img src=https://i.imgur.com/UaMvgKW.png loading=lazy alt=image-20230427002552546></p><h2 id=little-oho>Little-Oh：o</h2><blockquote><p>哲學意義在於絕對小於</p></blockquote><p>o 就像小於</p><p>定義：f(n) = o (g(n)) iff 對於所有的C，存在n0，且C為正常數，使得f(n) ≦ C*g(n)，對於所有的n0皆大於n</p><p>大部分都考是非題</p><p>例：</p><p><img src=https://i.imgur.com/znyS9FE.png loading=lazy alt=image-20230427004044210></p><h2 id=little-omegaω>Little-Omega：ω</h2><blockquote><p>哲學意義在於絕對大於</p></blockquote><p>w 就像大於</p><p>定義：f(n) = ω (g(n)) iff 對於所有的C，存在n0，且C為正常數，使得f(n) > C*g(n)，對於所有的n0皆大於n</p><p><img src=https://i.imgur.com/qJTJRGx.png loading=lazy alt=image-20230427005653632></p><h2 id=相關性質關係>相關性質/關係</h2><ol><li><p>反身性(Reflexive)：自己與自己之間的關係</p><ul><li>f(n)=O(f(n))。f(n)≦1*f(n), ∀ n≧n0</li><li>f(n)=Ω(f(n))。</li><li>f(n)=θ(f(n))。</li></ul><p>這三者皆滿足反身性</p><ul><li>f(n)=o(f(n)) 不成立，自己絕對不小於自己</li><li>f(n)=ω(f(n)) 不成立，自己也不大於自己</li></ul><p>這兩者不滿足反身性</p></li><li><p>遞移性(Transitive)：若a R b, b R c, 則 a R c 也成立</p><p>O, Ω. θ ,o, ω皆滿足遞移性</p><ul><li>f(n)=O(g(n))且g(n)=O(h(n))，則f(n)=O(h(n))</li></ul></li><li><p>對稱性(Symmetric)：若aＲb成立，則bＲa也成立</p><ul><li><span style=color:#ff0>只有θ滿足這個性質(==)</span>，其他均不滿足。</li><li>即<span style=color:#ff0>f(n)=θ(g(n))成立，則g(n)=θ(f(n))也會成立</span></li></ul></li><li><p>反對稱性(Asymmetric)：</p><ul><li><p>若f(n)=O(g(n))，則g(n)=Ω(f(n))為True</p><blockquote><p>f(n)≦c*g(n) => g(n)≧1/c*f(n)</p></blockquote></li><li><p>若f(n)=o(g(n))，則g(n)=ω(f(n))為True</p></li></ul></li></ol><h2 id=綜合練習>綜合練習</h2><p>[009 00:40:00]</p><p>例題一：</p><p><img src=https://i.imgur.com/MzdjnDC.jpg loading=lazy alt=image-20230430160922704></p><p>例題二：下列哪些是polynomial-Bounded(≦多項式時間等級)?</p><p><img src=https://i.imgur.com/qhPDIzi.jpg loading=lazy alt=6FDB9D79-A067-43BB-AB9F-A7115084C4BB></p><p>例題３</p><p><img src=https://i.imgur.com/4nWNymw.jpg loading=lazy alt=3100F4A8-BB07-4D2F-BFBC-71D7C4C283CC></p><p>[010]</p><h2 id=recursive-time-function求解>Recursive Time Function求解</h2><ol><li>展開代入法</li><li>Master Theory</li><li>Extended Master Theory</li><li>Recursive Tree</li><li>[離散]特徵方程組</li><li>猜測、近似法則</li></ol><h3 id=展開代入法>展開代入法</h3><blockquote><p>做苦工，通常沒問題，但缺點就是麻煩</p></blockquote><p>例一：Tower Of Hanoi</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>T(n)= 2*T(n-1)+1, T(1)=1
求T(n)=? O=? 
</code></pre></td></tr></table></div></div><p>Ans ：</p><p><img src=https://i.imgur.com/i55mUkw.jpg loading=lazy alt=291AF098-A2D6-4740-9A82-6DE19C81AE8A></p><p>例題二</p><p><img src=https://i.imgur.com/NL4DGTc.png loading=lazy alt=image-20230501170206600></p><p>例題三</p><p><img src=https://i.imgur.com/9zQVTz3.png loading=lazy alt=image-20230501173920709></p><p>例題四</p><p><img src=https://i.imgur.com/LmOX0fX.png loading=lazy alt=image-20230501235606138></p><p>例題五</p><p><img src=https://i.imgur.com/DpfLs2i.png loading=lazy alt=image-20230502001912248></p><p>例題六：<span style=color:#ff0>陷阱題</span></p><p><img src=https://i.imgur.com/bJBM3Xs.jpg loading=lazy alt=A74F2CBF-7070-416A-A5CD-38D05A277074></p><p>　</p><p>例題七：好難，不懂</p><p><img src=https://i.imgur.com/k3mdNJE.png loading=lazy alt=image-20230502034220410></p><p>例題八</p><p><img src=https://i.imgur.com/dapbAny.png loading=lazy alt=image-20230502220504588></p><p>[010 1:30:00]</p><h3 id=master-theory>Master Theory</h3><ol><li><p><span style=color:#ff0>若T(n)=a*T(n/b)+f(n)</span>,其中a≧1之constant，b是>1之constant，f(n)是positive-growth function，則可以使用此定理求出T(n)=θ(?)</p></li><li><p><span style=color:#ff0>使用方式</span></p><ol><li><p>先求出 <img src=https://i.imgur.com/vzOv1jP.png loading=lazy alt=image-20230502222828531></p></li><li><p>與f(n)比較<span style=color:#ff0>growth rate大小</span></p></li></ol></li></ol><h4 id=case1>Case1</h4><p><img src=https://i.imgur.com/j9zsz7J.png loading=lazy alt=image-20230502224531587></p><h4 id=case2>Case2</h4><p><img src=https://i.imgur.com/1lrX4PL.png loading=lazy alt=image-20230503234622323></p><h4 id=case3>Case3</h4><p><img src=https://i.imgur.com/EJDRRto.png loading=lazy alt=image-20230502230436531></p><p>例一：　</p><p><img src=https://i.imgur.com/6jFJt4e.png loading=lazy alt=image-20230503234828768></p><p>例二：</p><p><img src=https://i.imgur.com/IKtccE0.png loading=lazy alt=image-20230503235505480></p><p>例三：</p><p><img src=https://i.imgur.com/RElaFsd.png loading=lazy alt=　></p><p>綜合練習：</p><p><img src=https://i.imgur.com/JGhgiU0.png loading=lazy alt=image-20230504224611301></p><p><img src=https://i.imgur.com/wwnXUVm.png loading=lazy alt=image-20230504233728869></p><p><img src=https://i.imgur.com/pvq65rg.png loading=lazy alt=image-20230504233735147></p><p><img src=https://i.imgur.com/kTI1lr9.png loading=lazy alt=image-20230504233745485></p><p><img src=https://i.imgur.com/SqyIAO3.png loading=lazy alt=image-20230504233955940></p><h4 id=master-theory-之例外狀況>Master Theory 之例外狀況</h4><p><img src=https://i.imgur.com/rZuZlNg.png loading=lazy alt=image-20230505001536322></p><p>若遇到這種情況，則用<span style=color:#ff0>Extended Master Theory</span></p><p>[011] 00:30:00</p><h3 id=extended-master-theory>Extended Master Theory</h3><p><img src=https://i.imgur.com/Yq5RlTg.png loading=lazy alt=image-20230506151546429></p><p>以上面那一題為例，重新再解一次</p><p><img src=https://i.imgur.com/4CWidT6.png loading=lazy alt=image-20230506152619767></p><p>例題一</p><p><img src=https://i.imgur.com/VmqEL90.png loading=lazy alt=image-20230506154232088></p><p>例題二</p><p><img src=https://i.imgur.com/ZDaERbP.png loading=lazy alt=image-20230506153729266></p><p>綜合練習</p><p><img src=https://i.imgur.com/3RqoE9j.png loading=lazy alt=image-20230506162320124></p><p><img src=https://i.imgur.com/p6LXxEu.png loading=lazy alt=image-20230506162327009></p><p><img src=https://i.imgur.com/4dgk7aW.png loading=lazy alt=image-20230506163736019></p><p><img src=https://i.imgur.com/DOSLZQE.png loading=lazy alt=image-20230506164240320></p><p><img src=https://i.imgur.com/wtoXsGE.png loading=lazy alt=image-20230506164700523></p><h4 id=更特殊之例外>更特殊之例外</h4><p><img src=https://i.imgur.com/y7fKedA.png loading=lazy alt=image-20230506170316685></p><p>[011 01:30:00]</p><h3 id=recursive-tree遞迴樹求解>Recursive Tree(遞迴樹)求解</h3><p>就是結構化的展開帶入法啦</p><p><span style=font-size:32px;color:#ff0>太抽象了。之後再來看</span></p><p>[012]</p><h3 id=特徵方程>特徵方程</h3><p><span style=font-size:32px;color:#ff0>太抽象了。之後再來看</span></p><h3 id=近似值>近似值</h3><p><span style=font-size:32px;color:#ff0>太抽象了。之後再來看</span></p><p>[013]</p><h1 id=ch3-stack-與-queue>Ch3 Stack 與 Queue</h1><blockquote><p>Stack Def 、應用、製作</p><p>Stack Permutations</p><p>Infix, Postfix, Perfix 轉換與計算 ☆☆☆☆☆</p><p>Complier Parsing Using stack例子 ☆☆☆</p><p>Queue 定義、應用、&ldquo;製作&rdquo;、種類</p><p>Stack與Queue相互製作 ☆☆☆</p></blockquote><h2 id=stack-堆疊>Stack (堆疊)</h2><p>定義：Stack 具有<span style=color:#ff0>LIFO</span>之性質，其Insert元素動作叫做PUSH，DELETE元素之動作叫做POP，且PUSH、POP動作發生在同一端，稱為TOP(頂端)</p><p>就像品客洋芋片罐一樣</p><p>例：對空Stack執行</p><p>PushA</p><p>PushB</p><p>PushC</p><p>POP</p><p>PushD</p><p>POP</p><p>POP</p><p>PushE</p><p>後，Stack內容為何?</p><p>AE</p><h2 id=應用>應用</h2><ul><li>re-entrant routine</li></ul><p>​ = pure code</p><p>​ = 可重複進入執行之程式</p><p>​ = 用在Utility program</p><ul><li><p>走迷宮</p></li><li><p>Palindrome(迴文)</p><p>= 由左而右 Reading 等於由右而左</p><p>= 若將一文字依序Push到Stack，再一一Pop輸出，等於加到Queue再一一刪除輸出，這一字串有什麼特性？<span style=color:#ff0>Palindrome</span></p></li></ul><h2 id=stack之製作>Stack之製作</h2><p>一個Stack之ADT(abstract data type)應提供下列Operations供外界呼叫/使用</p><p><span style=color:#ff0>Create,push,pop,isEmpty,isFull</span>，有時候還會多一個<span style=color:#ff0>TOP(只傳回TOP元素，但不刪除)</span></p><ol><li><p>利用Arrray製作Stack</p><p>宣告</p><ol><li><p>S : Array [1..n] of items 或 [0 .. (n-1)]</p></li><li><p>Top：Int = 0 ; <code>也有可能是-1 取決於你的Index怎麼訂</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>push (S, Item){
if(top==n)then
return &#34;S is Full&#34;;
else {
 top = top+1;
 S[top] = item;
       
}
}
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>pop(s){
if(top==0)then{
return &#34;s is empty&#34;
}
else {
item = s[top];
top = top-1;
return item;
}
}
</code></pre></td></tr></table></div></div></li></ol></li><li><p>利用Link List製作Stack</p><p>宣告</p><ol><li><p>Note Structure如下</p><p><img src=https://i.imgur.com/EQAO0Hn.png loading=lazy alt=image-20230507042921084></p><p>若以C語言來看</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>Node</span><span class=p>{</span>
    <span class=kt>int</span> <span class=n>Data</span><span class=p>;</span>
    <span class=n>Struct</span> <span class=n>Node</span> <span class=o>*</span><span class=n>Next</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></li><li><p>top : pointer = null;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Push(S,Item){
new(t); //向系統要求配置一個Node空間，讓t指標指向它
t -&gt; Data = item;
t -&gt; Next = Top;
Top = t;
}
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Pop(s){
if(top ==null){
return &#34;S is empty&#34;
}
else {
t = top;
item = top - &gt; Data;
Top = Top -&gt; Next ;
release(t); //回收T所指的Node Space
return item;
}
}
</code></pre></td></tr></table></div></div></li></ol></li></ol><h2 id=stack-permutation>Stack Permutation</h2><p>定義：給予N個Data，<span style=color:#ff0>規定須依序push入Stack，但在過程中，可執行任意合法的POP輸出資料，則所有Data之輸出排列組合，稱之</span></p><p><span style=color:#ff0>n個Data之Stack permutation數目 =<img src=https://i.imgur.com/SAXJvNb.png loading=lazy alt=image-20230507133619981></span></p><p>與下列問題同義：</p><ol><li>n個node可形成的不同Binary Tree結構(ch5)</li><li>n個"(&ldquo;與n個&rdquo;)&ldquo;的合法配對數目</li><li>(n+1)個Matrix相乘之可能乘法配對順序數目</li><li>軌道問題</li></ol><p>[014]</p><h2 id=infixpostfixprefix-之轉換-本章最常考>Infix,Postfix,Prefix 之轉換 (本章最常考)</h2><p><span style=color:#ff0>先介紹這3個式子</span></p><ol><li><p><span style=color:#ff0>Infix中序置式</span></p><p>格式：Operand1 <span style=color:#ff0>Operator</span> Operand2 <code>運算元 運算子 運算元</code></p><p>eg. a+b, a*b, (a-b)/c</p><p>缺點：對Compiler 處理Infix計算十分不方便，<span style=color:#ff0>因為必須考慮Operator之間的優先權及結合性，故可能導致來回多次的掃描式子，才可求出結果</span>，用白話文來講就是先乘除後加減的特性導致Compiler不方便</p><p>eg: a+b*c^d &mldr;.</p></li><li><p><span style=color:#ff0>Postfix(後序式)</span></p><p>格式：Operand1 operand 2 <span style=color:#ff0>Operator</span></p><p>ag ab+, ab*, ab></p><p><span style=color:#ff0>優點：Compilter處理Postfix計算，只須由左而右Scan一次</span></p></li><li><p><span style=color:#ff0>Perfix(前序式)</span></p><p>格式：格式：<span style=color:#ff0>Operator</span>Operand1 operand 2</p><p>eg. +ab, *ab, /ab</p><p>優點：同Postfix，<span style=color:#ff0>但由右而左Scan</span></p><p>缺點：中序轉前序須兩個Stack支持，但中序轉後序須1個Stack即可</p></li></ol><h3 id=infix轉postfixprefix計算題型>Infix轉Postfix/Prefix計算題型</h3><p>作法：使用<span style=color:#ff0>括號法</span></p><p>以Infix轉PostFix為例</p><p>Steps</p><ol><li>對Infix加上<span style=color:#ff0>完整的括號配對</span></li><li><span style=color:#ff0>Operator</span>取代最近的右括號</li><li>刪左括號，其他由左而右寫出即得Postfix</li></ol><p><span style=color:#ff0>一般而言，Operator之優先權等參考下表</span></p><div class=table-wrapper><table><thead><tr><th>Operator</th><th>優先權</th><th>結合性</th><th>Binary 或 unary</th></tr></thead><tbody><tr><td>括號()</td><td>高</td><td>Na</td><td>Na</td></tr><tr><td>負號 -</td><td>.</td><td>Na</td><td>unary</td></tr><tr><td>冪次方 ^</td><td>.</td><td>右結合</td><td>Binary</td></tr><tr><td>*,/ 乘除</td><td>.</td><td>左結合</td><td>Binary</td></tr><tr><td>+,-</td><td>.</td><td>左結合</td><td>Binary</td></tr><tr><td>>,&lt;,==,>=,&lt;=,!=</td><td>.</td><td>左結合</td><td>Binary</td></tr><tr><td>Not(否定),~</td><td>.</td><td>Na</td><td>Unary</td></tr><tr><td>AND,OR</td><td>.</td><td>左結合</td><td>Binary</td></tr><tr><td>Assign = :=</td><td>低</td><td>右結合</td><td>Binary</td></tr></tbody></table></div><p><span style=color:#ff0>題目若有規定，則以題目為主</span></p><p>例一：Infix轉Postfix</p><ol><li><p>a+b*c-d/e*f</p><p>Ans. a+(b*c)-((d/e)*f))</p><p><span style=color:#ff0>abc*+de/f*-</span></p></li><li><p>a*(b-c/d)^e*(f/g+h)</p><p>Ans：abcd/-e&*fg&/f+*</p><p><img src=https://i.imgur.com/pMLANIl.png loading=lazy alt=image-20230508001016753></p></li><li><p>(a+(b-c))^d^e*((f-g)/h)</p><p>Ans: abc-+de^^fg-h/*</p></li><li><p>~A and (B>C or D&lt;E) or(~F)</p><p>Ans: A~BC>DE&lt;or And F~ or</p></li></ol><p>例二：Infix 轉 Prefix</p><ol><li><p>a*((b/c)-d)+e*f/g</p><p>Ans: +*a-/bcd/*efg</p></li><li><p>a*(b-(c+d))/(e*f)^g</p><p>Ans：/*a-b+cd^*efg</p></li><li><p>a+((b-c)/d)-e*f</p><p>Ans：-+a/-bcd*ef</p></li><li><p>A or ((~B and C>D) and E>F)</p><p>Ans. Or A and and ~ B > CD > EF</p></li></ol><p>規定：優先權：括號＞＋＞÷＞－＞╳。＋，÷，－為右結合。×為左結合</p><ol><li>(a*b)-c/d/e+f+g</li><li>(a/b/c)+d+(e*f*g)</li></ol><p>Ans. (a*b)-c/d/e+f+g</p><p>Ans. +/a/bc+d**efg</p><p>例三：Postfix轉Infix</p><ul><li>找出Postfix 樣板</li></ul><p><code>op1 op2 operator</code></p><ul><li>改為Infix (op1 operator op2)</li><li><span style=color:#ff0>刪除不必要之括號</span></li></ul><ol><li><p>AB+C*DE-FG+^-</p><p>Ans. (A+B)*C-(D-E)^(F+G)</p></li><li><p>ab/c-de*+ac*-</p><p>Ans. ((()))</p></li></ol><p>[014 50:00:00]</p><p><span style=font-size:32px;color:#ff0>先跳過，太複雜了，之後來看</span></p><p>[015]</p><p><span style=font-size:32px;color:#ff0>先跳過，太複雜了，之後來看</span></p><p>[016]</p><h2 id=queue佇列>Queue(佇列)☆☆☆</h2><p>定義：具有<span style=color:#ff0>FIFO(First-In-First-Out)先進先出</span>。性質之有序串列</p><ul><li>Insert(enqueue)元素在<span style=color:#ff0>rear(尾端)</span></li><li>Delete<span style=color:#ff0>(dequeue)元素</span>在<span style=color:#ff0>front(前端)</span></li></ul><p>所以是發生在<span style=color:#ff0>不同端</span></p><p>例：針對Empty Queue實施</p><p>enqueue(a)</p><p>enqueue(b)</p><p>enqueue(c)</p><p>dequeue</p><p>dequeue</p><p>enqueue(d)</p><p>enqueue(e)</p><p>dequeue</p><p>後，Queue內容為何?</p><p>Ans</p><p>d,e</p><p>應用：</p><ol><li>作業系統裡頭各式各樣的Queue eg: ready queue, waiting queue, i/o-device queue etc</li><li><span style=color:#ff0>Buffer(緩衝區)也採FIFO Queue </span></li><li><span style=color:#ff0>佇列理論</span>：Simulation(模擬) System Performnace 評估</li><li><span style=color:#ff0>圖形的BFS(Breadth First Seatch)</span></li><li><span style=color:#ff0>Binary Tree的Level-order Traversal</span></li><li>日常生活的排隊行為</li></ol><h3 id=queue-的製作>Queue 的製作</h3><ol><li><p>Queue 此一ADT必須提供下列運作供外界使用以及呼叫</p><p><span style=color:#ff0>Create, Enqueue, Dequeue,InFull, Isempty </span></p></li><li><ol><li>利用Array製作<ol><li>Linear Array</li><li><span style=color:#ff0>Circular Array(最多可利用(n-1)格 Space)</span></li><li><span style=color:#ff0>Circular Array(最多可利用n格space)</span></li></ol></li></ol></li></ol><h3 id=linear-array>Linear Array</h3><p><span style=color:#ff0>缺點：若Rear ==n成立，並不一定代表Queue真的滿，若此時Front>0，代表仍有Front 個Space可用，但卻無法加入東西</span>，代表有空間閒置、浪費</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>LinearStack</span> <span class=o>{</span>

    <span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>[]{</span><span class=n>10</span><span class=o>};</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列前端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>front</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列尾端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>rear</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>Enqueue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=n>Integer</span> <span class=n>item</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>rear</span> <span class=o>==</span> <span class=n>10</span><span class=o>)</span> <span class=o>{</span> <span class=c1>//問題點
</span><span class=c1></span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue已滿&#34;</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>rear</span> <span class=o>=</span> <span class=n>rear</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
            <span class=n>array</span><span class=o>[</span><span class=n>rear</span><span class=o>]</span> <span class=o>=</span> <span class=n>item</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>Dequeue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>rear</span> <span class=o>==</span> <span class=n>front</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue為空&#34;</span><span class=o>);</span>
            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>front</span> <span class=o>=</span> <span class=n>front</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
            <span class=n>Integer</span> <span class=n>integer</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>];</span>
            <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>]</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
            <span class=k>return</span> <span class=n>integer</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>分析：</p><ul><li>解法一：一個直覺的做法當Rear==n，且front>0時，表示有front個空格所以可將[front+1]~[rear]這些元素往左移Front格，並設Rear=Rear-Front,Front=0; then 再作Enqueue。<span style=color:#ff0>但缺點：導致Enqueue 平均Time從O(1)變成O(n)</span></li><li>解法二：利用Circular Array來作Queue</li></ul><h3 id=circular-arrayn-1>Circular Array(n-1)</h3><p><img src=https://i.imgur.com/kx0qCij.png loading=lazy alt=image-20230511002423718></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>CircularLinearStack</span> <span class=o>{</span>

    <span class=kt>int</span> <span class=n>queueSize</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>
    <span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>[]{</span><span class=n>queueSize</span><span class=o>};</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列前端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>front</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列尾端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>rear</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>Enqueue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=n>Integer</span> <span class=n>item</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>rear</span> <span class=o>=</span> <span class=o>(</span><span class=n>rear</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>queueSize</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue已滿&#34;</span><span class=o>);</span>
            <span class=n>rear</span> <span class=o>=</span> <span class=o>(</span><span class=n>rear</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>queueSize</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>array</span><span class=o>[</span><span class=n>rear</span><span class=o>]</span> <span class=o>=</span> <span class=n>item</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>Dequeue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue為空&#34;</span><span class=o>);</span>
            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>front</span> <span class=o>=</span> <span class=o>(</span><span class=n>front</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>queueSize</span><span class=o>;</span>
            <span class=n>Integer</span> <span class=n>integer</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>];</span>
            <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>]</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
            <span class=k>return</span> <span class=n>integer</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>分析：</p><ol><li><p>最多只能利用(n-1)格Space即front 所指之格不用</p><p><img src=https://i.imgur.com/XKGLcGG.png loading=lazy alt=image-20230511003739381></p></li><li><p><span style=color:#ff0>若硬用此格(Front)</span>，則當front==rear成立時，<span style=color:#ff0>無法區分Queue為空或Queue為滿</span>。eg. 明明滿了，但卻無法刪除</p></li><li><p><span style=color:#ff0>判斷Queue空，及Queue滿之條件式一樣</span></p></li><li><p>Enqueue 及 Dequeue 之 Time為O(1)</p></li></ol><h3 id=circular-array-n>Circular Array (n)</h3><p>宣告：多加一個tag:boolean 變數，<span style=color:#ff0>初值為false</span></p><p>目的：<span style=color:#ff0>協助</span>rear, front判斷Queue空orQueue滿，當rear==front成立時</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>CircularLinearStackBetter</span> <span class=o>{</span>


    <span class=kt>int</span> <span class=n>queueSize</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>
    <span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>[]{</span><span class=n>queueSize</span><span class=o>};</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列前端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>front</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=cm>/**
</span><span class=cm>     * 佇列尾端
</span><span class=cm>     */</span>
    <span class=kt>int</span> <span class=n>rear</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>

    <span class=cm>/**
</span><span class=cm>     * 
</span><span class=cm>     */</span>
    <span class=kt>boolean</span> <span class=n>tag</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>


    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>Enqueue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=n>Integer</span> <span class=n>item</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span> <span class=o>&amp;</span> <span class=n>tag</span> <span class=o>==</span> <span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue已滿&#34;</span><span class=o>);</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>rear</span> <span class=o>=</span> <span class=o>(</span><span class=n>rear</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>queueSize</span><span class=o>;</span>
            <span class=n>array</span><span class=o>[</span><span class=n>rear</span><span class=o>]</span> <span class=o>=</span> <span class=n>item</span><span class=o>;</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>tag</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>Dequeue</span><span class=o>(</span><span class=n>Integer</span><span class=o>[]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span> <span class=o>&amp;</span> <span class=n>tag</span> <span class=o>==</span> <span class=kc>false</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Queue為空&#34;</span><span class=o>);</span>
            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>front</span> <span class=o>=</span> <span class=o>(</span><span class=n>front</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>%</span> <span class=n>queueSize</span><span class=o>;</span>
            <span class=n>Integer</span> <span class=n>integer</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>];</span>
            <span class=n>array</span><span class=o>[</span><span class=n>front</span><span class=o>]</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>front</span> <span class=o>==</span> <span class=n>rear</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>tag</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
            <span class=o>}</span>
            <span class=k>return</span> <span class=n>integer</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>分析：</p><ol><li><span style=color:#ff0>最多可利用n格space</span></li><li>Enqueue及Dequeue之Time皆為O(1);</li><li><span style=color:#ff0>與法二相比，此法Enqueue及Dequeue之時間會變長，因為每個運作中皆多了一條if額外測試，看tag值是否要改變</span></li></ol><h3 id=linkedlist作queue>LinkedList作Queue</h3><h4 id=使用single-link-list>使用Single Link List</h4><p><code>單向鏈結串列</code></p><p>[017 00:55:00]</p><p><span style=font-size:32px;color:#ff0>跟Pointer有關，先跳過</span></p><h3 id=queue的種類>Queue的種類</h3><ol><li><p>FIFO Queue （標準、內定、預設）</p></li><li><p><span style=font-size:16px;color:#ff0>Priority Ｑueue(優先權佇列)</span></p><p>Def: <span style=font-size:16px;color:#ff0>不見得是FIFO order 而是刪除時是Delete-MAX或Delete-Min value元素</span></p><p>eg. OS中運用頗多(CPU Schedule)</p><p><span style=font-size:16px;color:#ff0>製作Priority Queue 合適之Data structure- Heap</span></p></li><li><p>Double-ended Queue(雙邊佇列)</p><p>Def: 此佇列之兩端(front, rear)皆可<span style=font-size:16px;color:#ff0>插入及刪除</span></p><p><img src=https://i.imgur.com/gDBuehW.png loading=lazy alt=image-20230513225728318></p></li><li><p><span style=font-size:16px;color:#ff0>Double-ended Priority Queue(雙邊優先權佇列)</span></p><p>Def: 此Queue支持3個主要運作</p><ol><li>Insert</li><li>Delete-Min</li><li>Delete-MAx</li></ol><p><span style=font-size:16px;color:#ff0>製作此Queue之最合適Data Structure有</span></p><ol><li>Min-Max Heap</li><li>Deop</li><li>SMMH</li></ol><p><code>高等樹會碰到</code></p></li></ol><p>練習題：用<span style=font-size:16px;color:#ff0>Circular Array(法二)製作Queue，如何球出Queue中元素個數，使用Rear, front, n?</span></p><p>Ans. (Rear-Front+n)%n</p><h2 id=stack與queue之相互製作>Stack與Queue之相互製作</h2><ol><li><p>利用stack製作(模擬)Queue<code>兩個Stack</code>✩✩✩✩✩</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Enqueue(queue,item){
 if(isFull(stack1)) then return &#34;Queue已滿&#34;
 else push(stack1,item)
}
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Dequeue(queue){ //由於Stack無法讓你Dequeue最底下的element出去，因此要借助第二個Stack來實現這件事情
 if(IsEmpty(stack2))then
     if(IsEmpty(stack1)) then return &#34;Queue空&#34;
    else{
     while(!IsEmpty(stack1))do{
             x= pop(stack1);
      push(stack2,x);	
     }
    }
    item = pop(stack2)
    return item;
}
</code></pre></td></tr></table></div></div><p><img src=https://i.imgur.com/lGexwnQ.png loading=lazy alt=image-20230514003454363></p><p><span style=font-size:16px;color:#ff0>Time分析：</span></p><ul><li><span style=font-size:16px;color:#ff0>大部分case(T!=空) -> Time: O(1)</span></li><li><span style=font-size:16px;color:#ff0>少部分case(S!=空,T=空) -> Time:O(n)</span></li></ul><p>&mdash;> amortized cose:O(1)</p></li><li><p>利用Queue製作Stack(假設是用Circular Array(法二)作的)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Push(stack, item){
 if(isFull(queue)) then return &#34;Stack滿&#34;
 else Enqueue(queue)
}
</code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>Pop(stack){
if (isEmpty(queue)) then return &#34;Stack為空&#34;
else{
n = (rear-front+n) %n //求出元素個數
for(i=1 to (n-1)) do
{
x= dequeue(queue)
enqueue(queue,x)
}
item = dequeue(queue)
return item
}
}
</code></pre></td></tr></table></div></div></li></ol><h1 id=ch5-tree-and-binary-tree-1>Ch5 Tree And Binary Tree</h1><blockquote><p>Tree Def 相關術語</p><p>Tree的表示方法(4種)</p><p>Binary Tree之Def，與Tree不同比較</p></blockquote><p><span style=font-size:16px;color:#ff0></span></p><p><u></u></p><p><sup></sup></p><p><span style=color:red></span></p><p><u></u></p><p><sup></sup></p><p>​</p><p><img src=https://p.ipic.vip/v29x8u.png loading=lazy alt=image-20230510002315303></p></section><footer class=article-footer><section class=article-tags></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true}]});})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/%E7%B5%90%E5%90%88lombok%E5%AF%AB%E5%87%BA%E6%9B%B4%E6%95%B4%E6%BD%94%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC/><div class=article-image><img src=https://i.imgur.com/1OBx1AG.png loading=lazy data-key data-hash=https://i.imgur.com/1OBx1AG.png></div><div class=article-details><h2 class=article-title>結合Lombok寫出更整潔的程式碼</h2></div></a></article><article class=has-image><a href=/p/%E9%81%8B%E7%94%A8arraylist%E8%88%87%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E5%B0%87swich%E8%AA%9E%E6%B3%95%E6%8B%86%E8%A7%A3/><div class=article-image><img src=https://i.imgur.com/rfkvgRO.png loading=lazy data-key data-hash=https://i.imgur.com/rfkvgRO.png></div><div class=article-details><h2 class=article-title>運用ArrayList與自動配置將Swich語法拆解</h2></div></a></article><article class=has-image><a href=/p/%E5%AF%A6%E7%94%A8%E7%9A%84git%E6%8C%87%E4%BB%A4/><div class=article-image><img src=https://i.imgur.com/nCGDuUc.png%20 loading=lazy data-key data-hash=https://i.imgur.com/nCGDuUc.png></div><div class=article-details><h2 class=article-title>實用的Git指令</h2></div></a></article><article class=has-image><a href=/p/java%E7%95%B0%E6%AD%A5%E5%9F%B7%E8%A1%8C%E5%B0%8F%E7%B2%BE%E9%9D%88-completablefuture%E4%BB%8B%E7%B4%B9/><div class=article-image><img src=https://i.imgur.com/bbIoOnR.png loading=lazy data-key data-hash=https://i.imgur.com/bbIoOnR.png></div><div class=article-details><h2 class=article-title>Java異步執行小精靈 CompletableFuture介紹</h2></div></a></article><article class=has-image><a href=/p/intellij%E5%BF%AB%E9%80%9F%E7%94%A2%E7%94%9Flog%E6%A8%A1%E6%9D%BF/><div class=article-image><img src=https://i.imgur.com/oRRgTer.jpg loading=lazy data-key data-hash=https://i.imgur.com/oRRgTer.jpg></div><div class=article-details><h2 class=article-title>IntelliJ快速產生log模板</h2></div></a></article></div></div></aside><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script><script>const gitalk=new Gitalk({clientID:"bf152013e92e48c1495f",clientSecret:"bed32f8438cb1e00d8628d9b6d148003bb4bf25d",repo:"comment",owner:"Hoxton019030",admin:["Hoxton019030"],distractionFreeMode:false,id:md5(location.pathname),});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return;}
gitalk.render("gitalk-container");})();</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 Hoxton</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.14.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#學習路線>學習路線</a><ol><li><a href=#ch1algorithm-recursion-and-performance-analysisspace--time>Ch1Algorithm, Recursion and Performance Analysis(space + Time)</a></li><li><a href=#ch3-stack--queue>Ch3 Stack & Queue</a></li><li><a href=#ch5-tree-and-binary-tree>Ch5 Tree And Binary Tree</a></li><li><a href=#ch9-advanced-trees>Ch9 Advanced Trees</a></li><li><a href=#ch7-search-and-usortingu>Ch7 Search and <u>Sorting</u></a></li><li><a href=#ch8-hasing>CH8 Hasing</a></li><li><a href=#ch6-graph>Ch6 Graph</a></li><li><a href=#ch2ch4-arraylinked-list>Ch2/Ch4 Array&Linked List</a></li></ol></li><li><a href=#ch1-algorith-recursion-and-performance-analysis>Ch1 Algorith, Recursion and Performance Analysis</a><ol><li><a href=#algorithm演算法>Algorithm(演算法)</a></li><li><a href=#recurtion遞迴>Recurtion(遞迴)</a><ol><li><a href=#考型及來源>考型及來源</a><ol><li><a href=#數學類>數學類</a></li><li><a href=#河內塔towers-of-hanai>河內塔(Towers of Hanai)</a></li><li><a href=#permutation列印>Permutation列印</a></li></ol></li></ol></li><li><a href=#performance-analysis效能分析>Performance Analysis(效能分析)</a></li><li><a href=#space空間需求分析>Space(空間)需求分析</a></li><li><a href=#time時間需求分析>Time(時間)需求分析</a></li><li><a href=#研究所的time分析考型>研究所的Time分析考型</a></li><li><a href=#複習-數學公式>[複習] 數學公式</a></li><li><a href=#給code求某行指令執行次數或big-oh>給Code，求某行指令執行次數或Big-Oh</a></li><li><a href=#asymptotic-notations>Asymptotic Notations</a></li><li><a href=#big-oh>Big-Oh</a></li><li><a href=#比較growth-rate等級之大小>比較Growth rate等級之大小</a><ol><li><a href=#例１基本型>例１：基本型</a></li><li><a href=#例2複雜型請參閱課本>例2：複雜型，請參閱課本</a></li></ol></li><li><a href=#omega-ω>Omega Ω</a></li><li><a href=#theta-θ>Theta θ</a></li><li><a href=#little-oho>Little-Oh：o</a></li><li><a href=#little-omegaω>Little-Omega：ω</a></li><li><a href=#相關性質關係>相關性質/關係</a></li><li><a href=#綜合練習>綜合練習</a></li><li><a href=#recursive-time-function求解>Recursive Time Function求解</a><ol><li><a href=#展開代入法>展開代入法</a></li><li><a href=#master-theory>Master Theory</a><ol><li><a href=#case1>Case1</a></li><li><a href=#case2>Case2</a></li><li><a href=#case3>Case3</a></li><li><a href=#master-theory-之例外狀況>Master Theory 之例外狀況</a></li></ol></li><li><a href=#extended-master-theory>Extended Master Theory</a><ol><li><a href=#更特殊之例外>更特殊之例外</a></li></ol></li><li><a href=#recursive-tree遞迴樹求解>Recursive Tree(遞迴樹)求解</a></li><li><a href=#特徵方程>特徵方程</a></li><li><a href=#近似值>近似值</a></li></ol></li></ol></li><li><a href=#ch3-stack-與-queue>Ch3 Stack 與 Queue</a><ol><li><a href=#stack-堆疊>Stack (堆疊)</a></li><li><a href=#應用>應用</a></li><li><a href=#stack之製作>Stack之製作</a></li><li><a href=#stack-permutation>Stack Permutation</a></li><li><a href=#infixpostfixprefix-之轉換-本章最常考>Infix,Postfix,Prefix 之轉換 (本章最常考)</a><ol><li><a href=#infix轉postfixprefix計算題型>Infix轉Postfix/Prefix計算題型</a></li></ol></li><li><a href=#queue佇列>Queue(佇列)☆☆☆</a><ol><li><a href=#queue-的製作>Queue 的製作</a></li><li><a href=#linear-array>Linear Array</a></li><li><a href=#circular-arrayn-1>Circular Array(n-1)</a></li><li><a href=#circular-array-n>Circular Array (n)</a></li><li><a href=#linkedlist作queue>LinkedList作Queue</a><ol><li><a href=#使用single-link-list>使用Single Link List</a></li></ol></li><li><a href=#queue的種類>Queue的種類</a></li></ol></li><li><a href=#stack與queue之相互製作>Stack與Queue之相互製作</a></li></ol></li><li><a href=#ch5-tree-and-binary-tree-1>Ch5 Tree And Binary Tree</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script></body></html>