[{"content":"目錄 Filter(過濾器)Interceptor(攔截器)AOP(剖面導向程式設計)之差異 Filter Interceptor AspectJ AspectJ 1 2 graph TD; AOP ---\u0026gt; SpringAop \u0026amp; AspectJ AOP (概念) 面向切面編程，利用AOP可以對業務邏輯的各個部分進行隔離，使得業務邏輯各部分之間的耦合度降低，提高程式的可重用性，同時提高開發的效率\n不修改原始碼，從而擴充新功能\nFilter(過濾器)Interceptor(攔截器)AspectJ(AOP)之差異 1 2 3 4 5 6 7 8 9 10 11 flowchart LR; 1((使用者))--發送請求 --\u0026gt;Filter\\n+統一設置編碼\\n+過濾敏感字\\n+登入驗證\\n+URL級別的訪問權限控制\\n+數據壓縮 --\u0026gt;dispatcher --\u0026gt;Interceptor\\n+權限驗證\\n+登入驗證\\n+性能檢測 --\u0026gt;AOP\\n+日誌紀錄 --\u0026gt;2(Controller) -1[粗糙]--能處理request的精細程度----\u0026gt;-2[細緻] Filter 1 2 3 4 5 flowchart LR; 1[瀏覽器]---\u0026gt;2{過濾器}---\u0026gt;3[Web資源] 3[Web資源]--\u0026gt;2{過濾器}--\u0026gt;1[瀏覽器] 在HttpServletRequest到達Servlet之前，過濾、處理一些資訊，本身依賴Sevlet容器，不能獲取SpringBean的一些資訊，它是javax.servlet.FilterChain的項目，不是Springboot\n可以做什麼\n修改Request, Response 防止xss(Cross-Site-SCripting跨網站指令碼)攻擊 包裝二進制流 自定義Filter 以註解方式製作Filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ @Slf4j @Component @WebFilter(filterName = \u0026#34;f1\u0026#34;,urlPatterns = {\u0026#34;*.html\u0026#34;,\u0026#34;*.jsp\u0026#34;,\u0026#34;/\u0026#34;}) //filterName就只是一個名稱可以，隨意就好，urlPattern是用來指定哪些url要經過這個過濾器 public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了 } } 結果如上\n以Java配置方式製作Filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Slf4j /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了 } } 1 2 3 4 5 6 7 8 9 @Configuration public class FilterConfig { @Bean public FilterRegistrationBean heFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(new HiFilter()); registration.addUrlPatterns(\u0026#34;/*\u0026#34;); //配置相關的路徑 return registration; } } 一些其他的config設置，僅供參考，與上面釋例無關\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration public class FilterConfig { //test @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logProcessTimeFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogProcessTimeFilter()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;logProcessTimeFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(0); //設定過濾器的執行順序 return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logApiFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogApiFilter()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;logApiFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(1); //設定過濾器的執行順序 return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; printResponseRequestFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new PrintResponseRequest()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;printResponseRequestFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(2); //設定過濾器的執行順序 return bean; } } SpringBoot本身也提供了許多不同的Filter供使用，參考如下\n常用的有以下幾個\nCharacterEncodingFilter(用於處理編碼問題) HiddenHttpMethodFilter(隱藏Http函數) HttpPutFormContentFilter(form表單處理) RequesrtContextFilter(請求上下文) 其他資訊可以詳閱Spring MVC中各个filter的用法\n其中以OncePerRequestFilter最常被使用，這個Filter會去過濾每一個Request請求，且不會重複執行，且這個Filter有一個doFilterInternal()的方法，供我們撰寫Filter邏輯因doFilter()的方法已在OncePerRequestFilter裡面實現了，可以用來做Jwtoken的登入驗證，程式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { @Autowired private JwtService jwtService; @Autowired private UserDetailsService userDetailsService; //注入JwtService UserDetailsService，分別用來解析Token與查詢使用者詳情 @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION); if (authHeader != null) { String accessToken = authHeader.replace(\u0026#34;Bearer \u0026#34;, \u0026#34;\u0026#34;); //從請求標頭中取得Authorization欄位中的值 Map\u0026lt;String, Object\u0026gt; claims = jwtService.parseToken(accessToken); //擷取出後面的JWT字串，接著解析它 String username = (String) claims.get(\u0026#34;username\u0026#34;); //從claims物件中取得username欄位的值 UserDetails userDetails = userDetailsService.loadUserByUsername(username); //並透過userDetailService查詢使用者詳情。這也代表JWT的內容(payload)必須包含username這個欄位 //在filter中查詢使用者的目的，是為了將該次請求所代表的驗證後資料(Authentication)帶進security中的Context。 //Context是一種較抽象的概念，可以想像成該次請求的身分狀態 Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); //為了將這個請求的使用者身分告訴伺服器，我們建立UsernamePasswordAuthenticationToken的物件，其中第三個參數放GrantedAuthority的List， 作為API的授權檢查 //第一個參數(principal)傳入使用者詳請(UserDetails)。 // 而第二個參數是credential，通常是密碼，但不傳入也無訪 //經由傳入principal，我們得以在業務邏輯中從Context輕易獲取使用者身分的資料 SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } } 配置完後再將這個Filter加入Security的過濾鍊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; /** * 協助帳號密碼認證的東西 * @return */ @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } //加入Security的過濾鍊 protected void configure(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .antMatchers(HttpMethod.GET, \u0026#34;/users/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name()) // .antMatchers(HttpMethod.GET,\u0026#34;/h2/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name()) .antMatchers(HttpMethod.GET,\u0026#34;/login/**\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST,\u0026#34;login\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST, \u0026#34;/users\u0026#34;).permitAll() .anyRequest().permitAll() .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) //於UsernamePasswordAuthenticationFilter進行認證 .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .csrf().disable() .formLogin(); http.headers().frameOptions().disable(); //讓spring Security可以和h2建立連線 } /** * * @param auth 配置全局驗證資訊，如Authentication Provider,UserDetailService等等資訊， * authenticationManager會接收到UsernamePasswordAuthenticationToken傳入的資料後 * 調用SecurityConfig中所配置的userDetailsService,passwordEncoder來協助驗證 * * @throws Exception */ protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); } } 一些Code的示範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LogProcessTimeFilter extends OncePerRequestFilter { /** * @param request 請求 * @param response 回應 * @param filterChain 過濾鏈 會將現有的filter給串聯起來，當請求進入後端，需要依序經過它們才會達到Controller，相對的，當回應離開Controller，則是按照相反的方向經過那些Filter * @throws ServletException * @throws IOException */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { long startTime = System.currentTimeMillis(); filterChain.doFilter(request, response); //doFilter:相當於將請求送至Controller。 long endTime = System.currentTimeMillis(); long processTime = endTime - startTime; System.out.println(\u0026#34;processTime = \u0026#34; + processTime); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Controller收到的請求主體(RequestBody)和回應主體(ResponseBody) * 分別由HttpServletRequest與HttpServletResponse的InputStream、OutputStream轉化而來， * 但資料流只能讀取一次，如果在Filter層就被讀掉，可能會導致後面都收不到資料 * 為了保留主體中的資料，我們將請求主體與回應主體包裝成ContentCachingResponseWrapper ContentCachingRequestWrapper * 再如同往常傳入FilterChain * * 這兩個Wrapper的特色是會在內部備份一個ByteArrayOutputStream，我們只要呼叫這兩個Wrapper的 * getContentAsByteArray就可以無限制地取得主體內容 */ public class PrintResponseRequest extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request); ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response); filterChain.doFilter(requestWrapper, responseWrapper); // logApi(request, response); logBody(requestWrapper,responseWrapper); responseWrapper.copyBodyToResponse(); } private void logApi(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int httpStatus = response.getStatus(); //200,403,404之類的 String httpMethod = request.getMethod(); String uri = request.getRequestURI(); String params = request.getQueryString(); if (params != null) { uri += \u0026#34;?\u0026#34; + params; } System.out.println(String.join(\u0026#34; \u0026#34;, String.valueOf(httpStatus), httpMethod, uri)); } private void logBody(ContentCachingRequestWrapper request, ContentCachingResponseWrapper response) { String requestBody = getContent(request.getContentAsByteArray()); System.out.println(\u0026#34;Request: \u0026#34; + requestBody); String responseBody = getContent(response.getContentAsByteArray()); System.out.println(\u0026#34;Response: \u0026#34; + responseBody); } /** * @param content * @return 返回JSON字串 */ private String getContent(byte [] content){ String body = new String(content); return body.replaceAll(\u0026#34;[\\n\\t]\u0026#34;, \u0026#34;\u0026#34;); //去除換行\\n與定位符號\\t } } Interceptor 本身是AOP的一種應用，其實攔截器跟過濾器是可以互相替換的，功能其實差不多，只是攔截器可以在請求到達Controller或是回應回傳出Contrller時進行攔截，攔截成功時可以實做一些自定義的業務邏輯進行修改，且Interceptor是Springboot下的一個功能org.springframework.web.servlet.HandlerInterceptor\n可以用來\n性能監控：紀錄請求的處理時間，比如說請求處理太久（超過500毫秒） 登入檢測 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 graph LR; request--\u0026gt;id1 id1--\u0026gt;id2--\u0026gt;id4--\u0026gt;id3--\u0026gt;id6--\u0026gt;id5 subgraph 攔截器1 direction TB id1[\u0026#34;preHandle()\u0026#34;] id3[\u0026#34;postHandler()\u0026#34;] id5[\u0026#34;afterCompletion()\u0026#34;] end subgraph 攔截器2 direction TB id2[\u0026#34;preHandle()\u0026#34;] id4[\u0026#34;postHandler()\u0026#34;] id6[\u0026#34;afterCompletion()\u0026#34;] end 要實現interceptor有兩種方式\n實作HandlerInterceptor 繼承HandlerInterceptorAdapter 釋例\n自定義攔截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class LogInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); System.out.println(\u0026#34;\\n-------- LogInterception.preHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;Start Time: \u0026#34; + System.currentTimeMillis()); request.setAttribute(\u0026#34;startTime\u0026#34;, startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.postHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.afterCompletion --- \u0026#34;); long startTime = (Long) request.getAttribute(\u0026#34;startTime\u0026#34;); long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;End Time: \u0026#34; + endTime); System.out.println(\u0026#34;Time Taken: \u0026#34; + (endTime - startTime)); } } 註冊攔截器 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogInterceptor()); registry.addInterceptor(new OldLoginInterceptor()).addPathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); registry.addInterceptor(new AdminInterceptor()).addPathPatterns(\u0026#34;/admin/*\u0026#34;).excludePathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); } } AspectJ 屬於一種AOP框架\n動態代理(Spring5本身已經封裝了) 有兩種情況的動態代理 有介面(JDK動態代理)\n1 2 3 interface UserDao{ public void login(); } 1 2 3 4 class UserDaoImpl implements　UserDao{ public void login(){ } } 創建UserDao介面實現類的代理對象，代理對象會有被代理對象的所有方法，並且增強\n無介面(CGLIB動態代理)\n1 2 3 4 5 class User{ public void add (){ } } 1 2 3 4 5 class Person extends User{ public void add(){ super.add(); } } AOP(JDK動態代理) 使用JDK的動態代理，要使用Proxy類裡面的方法來創建出代理對象 newProxyInstance(類加載器,增強方法所在的類，這個類實現的介面,實現這個接口(InvocationHandler)\n編寫JDK動態代碼\n1 2 3 4 5 public interface UserDao { public int add (int a,int b); public String update(String id); } 1 2 3 4 5 6 7 8 9 10 11 12 public class UserDaoImpl implements UserDao{ @Override public int add(int a, int b) { System.out.println(\u0026#34;add方法執行了\u0026#34;); return a+b; } @Override public String update(String id) { return id; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.aop; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; /** * @author Hoxton * @version 1.1.0 */ public class JDKProxy { public static void main(String[] args) { Class[] interfaces = {UserDao.class}; UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); //此dao已經不是原本的dao，而是新的代理類dao了 int result = dao.add(1, 2); System.out.println(\u0026#34;result = \u0026#34; + result); } } //創建代理對象的代碼 class UserDaoProxy implements InvocationHandler { //1. 把創建的是誰的代理對象，把誰傳遞進來 // 有參建構子 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增強的邏輯 @Override public Object invoke(Object proxy, Method method, Object[] methodArgs) throws Throwable { //方法之前 System.out.println(\u0026#34;方法之前執行...\u0026#34; + method.getName() + \u0026#34;傳遞的參數...\u0026#34; + Arrays.toString(methodArgs)); //被增強的方法執行 Object res = method.invoke(obj, methodArgs); //方法之後 System.out.println(\u0026#34;方法之後執行...\u0026#34; + obj); return res; } } AOP專業術語 連接點\n一個類裡面中，能被增強的方法就叫連接點，下面這個類就有四個連接點\n1 2 3 4 5 6 class User{ add(); update(); select(); delete(); } 切入點\n實際被增強的方法，就叫切入點\n通知(增強)\n實際增強的邏輯部分稱為通知(增強)\n通知有多種類型\n前置通知\n在切入點前執行\n後置通知\n在切入點後執行\n環繞通知\n在切入點前後執行\n異常通知\n出現異常時執行\n最終通知\n執行到try\u0026hellip;catch的final時執行\n切面\n是一個動作\n把通知應用到切入點的過程，就叫切面 AOP(準備) Spring 框架一般都是基於AspectJ實現的AOP操作\n什麼是AspectJ\nAspectJ不是Spring的組成部分，是一個獨立的AOP框架， 一般把AspectJ和Spring框架一起使用，進行AOP操作 基於Aspect實現AOP操作\nxml配置文件實現 基於註解方法實現(主要使用) 再專案裡面引入AOP依賴\n切入點表達式\n切入點表達式的作用: 知道對哪個類的哪個方法進行增強\n語法結構:\nexecution( [權限修飾符] [返回類型] [類全路徑] [方法名稱] ( [參數列表] ) )\n權限修飾符: public, private, *(代表不論是public, private 都選)\n返回類型: String, int\n類全路徑: com.hoxton\u0026hellip;\u0026hellip;.\n方法名稱: 就方法名稱\n參數列表: 有哪些參數\n舉例\n對com.hoxton.dao.BookDao類裡面的add方法進行增強\n1 execution(* com.hoxton.dao.BookDao.add(..) ) 對com.hoxton.dao.BookDao類的所有方法進行增強\n1 execution(* com.hoxton.dao.BookDao.*(..)) 對com.hoxton.dao包裡的所有類，類裡面的髓有方法進行增強\n1 excution(* com.hoxton.dao.*.*(..)) within([package名].* )或( [package名]..*)\n舉例\n1. 1.\nAOP操作(Aspect J 註解) 創建類，在類裡面定義方法 1 2 3 4 5 6 public class User { public void add(){ System.out.println(\u0026#34;add\u0026#34;); } } 創建增強類(編寫增強邏輯)\n在增強類的裡面，創建方法，讓不同方法代表不同通知類型\n1 2 3 4 5 public class UserProxy { public void before(){ System.out.println(\u0026#34;before\u0026#34;); } } 進行通知的配置\n在Spring Log4j 2 1 2 3 flowchart TD; 8[\u0026#34;ALL(全輸出不留情)\u0026#34;]---\u0026gt;7[\u0026#34;Trace(更細的除錯資訊，通常用來追蹤城市流程的日誌)\u0026#34;]---\u0026gt;6[\u0026#34;DEBUG(除錯資訊的日志)推薦★\u0026#34;]---\u0026gt;5[\u0026#34;INFO(一般資訊的日志)推薦★\u0026#34;]---\u0026gt;4[\u0026#34;WARN(可能導致錯誤的日志)\u0026#34;]---\u0026gt;3[\u0026#34;ERROR(造成應用錯誤停止的日志)\u0026#34;]---\u0026gt;2[\u0026#34;FETAL(造成應用程式停止的日志)\u0026#34;]---\u0026gt;1[\u0026#34;OFF(不輸出任何日志)\u0026#34;] 參考 https://www.cnblogs.com/itlihao/p/14329905.html\nhttps://blog.csdn.net/fly910905/article/details/86537648\nSpringBoot攔截器(Interceptor)詳解\nSpring Boot使用過濾器和攔截器分別實現REST介面簡易安全認證\n","date":"2022-10-07T22:41:52+08:00","image":"https://i.imgur.com/B7GhSw1.png","permalink":"https://Hoxton019030.github.io/p/%E5%9F%BA%E7%A4%8Eaop%E4%BB%8B%E7%B4%B9-filter-interceptor-aspectj/","title":"基礎AOP介紹-Filter Interceptor AspectJ"},{"content":"​\t如果你是好奇死亡擱淺這款遊戲到底好不好玩，擔心對不到電波，怕買了浪費錢的人可以聽看看我的想法\u0026ndash;「我覺得很難歸納出哪種類型的人會喜歡死亡擱淺」 我只能說，會比較推薦給至少能撥出個1、2小時玩遊戲的人才會比較適合玩。\n無雷心得：\n我本身不是小島秀夫的粉絲，他的作品我也只玩過幻痛而已，而且 我覺得幻痛超級無聊，遊戲評分鼓勵你不殺，所以你很多裝備是不能用 的，而且地圖設計也稱不上有趣，荒漠和草原的地形空蕩到很空虛，不太能理解 為什麼硬要做成開放地圖，A任務做完要到B任務就只能自己過去、或是叫直升機等等的。看完了儀式之人的影片後也沒有覺得躍躍欲試的感覺，玩了20個小時後真的撐不下去就 不玩了，所以我在買死亡擱淺前其實猶豫很久，因為我知道我可能會Get不到遊戲有趣的點? 後來還是抱持著是驢是馬遛看看的心情買了下去。\n純論遊戲心得，並且在不暴雷太多重要劇情的情形下，死亡擱淺最大的樂趣在於遊戲一開始剝奪你很多東西，初期會要求你背著大重量的貨物到有一段距離的地方，然後這路上可能有懸崖、陡坡之類的地形阻隔著你，所以初期會對於這些事情覺得很毛躁、等到遊戲中期，開始出現很多東西能輔助你送貨，能裝載更多重量的、加速的，會讓你覺得所有的一切不再那麼痛苦，而後期當你解鎖所有設施、道具之後，你會開始愛上送貨這件事情，我覺得這點蠻神奇的，因為在往常的遊戲裡面跑腿送貨是最無聊的環節，你會用快速旅行直接省略掉這個過程，但在死亡擱淺裡你會體認到，所有的一切都是自己努力而來的，是自己讓這件事情變得輕鬆，變得平易近人，就好比學習一項事物，從排斥到接受，再到學以致用，漸漸地愛上一件事情。\n​\t我記得有一個晚上我就上線，也沒推任何主線劇情，就很單純的從A點接單送到B點，再從B點接單送到C點，然後再從C點接單送到B點這樣往復巡還，聽起來很無聊，但我當時送完貨物跑出結算畫面，看到滿滿的SSS時，真的覺得送貨使我快樂。\n另一點我覺得有趣的是遊戲裡面的線上模式，會讓你的地圖裡出現其他玩家的建物，比如說休息站、涼亭之類的，或者是其他玩家的登山索、樓梯，這點不是死亡擱淺原創，但在這遊戲裡面卻是我最喜歡的一點，在爬山的時候爬著其他玩家的梯子，然後在山頂看到其他玩家撒尿的蘑菇叢、然後在拉著其他玩家的纜繩下山，雖然你無法看到那些玩家的身影，但它們在你的世界留下的足跡卻令他們的形象具體而鮮明，在你在河流底部發現散落的貨品、峽谷下方報廢的摩托車，宛若有一段故事被濃縮成一個小小的物品，而這個小小的物品又經由你的發現而解壓縮成一段送貨之旅，死亡擱淺大部分的遊戲時間都是獨自一人的，但這種設計讓這個世界不在那麼冰冷，而多了些許溫度。\n最後是這個遊戲的氛圍，死亡擱在某些地形出現的時候（比如說高山、平原、裂谷）會撥放一些很空靈感的歌，配合上游戲的畫面、眼前的景象，山姆苗小的身影形成強烈的對比，耳中響起的和聲與山姆亦步亦趨的步伐，行走在一望無際的大草原，所有的一切都是空的，但心中卻被滿滿的感動填滿著。\n死亡擱淺到底適合什麼樣的人，我覺得只有自己玩了才能知道，他就是一款這麼特別的遊戲，看起來很無聊，但玩起來卻比想像中的有趣。\n有雷心得：\n其實玩完之後，我原本是很期待劇情而對遊戲性無感，但玩完後我卻相反過來 ，因為我劇情看不太懂，但遊戲性卻是出乎我意料之外的好。遊戲到尾聲之前我是都看得懂的，大概就是我們要去救艾米莉，但有個叫希格斯的人百般阻饒，然後頑人藏著什麼秘密。但當艾米莉出來之後我就完全看不懂了，我只能理解到一個艾米莉在冥灘、另一個在總統府當總統，但不能理解為什麼她要希格斯又要山姆，也不能理解她是不是好人，因為從結尾畫面上看來，艾米莉是想要毀掉世界的，但當山姆放下槍後她卻又抱著山姆說了一段我不明所以的台詞：\n「我做過無數個夢，我不知道該相信哪一個，所以我才決定跟你和其他人分享我的夢境，但是為了讓點連成一條線，讓一切都弄清楚，你們需要看得更透徹。你們需要時間。時間對我沒有任何意義，我不是一條線，我是單獨存在的點\u0026hellip;(省略)\u0026hellip;你(山姆)找到了共通的線，把所有點串在一起，而且你用唯一可能的方式做到了，也就是努力活好每一天，謝謝你山姆。」 ​\t這邊我看不懂的原因，是因為不能理解為什麼山姆努力活好每一天就能把所有點串成一條線，也不能理解為什麼山姆把所有的點連城線之後就可以進行大滅絕，我聽得出來翻譯的字幕和語音是對的上的，沒有亂翻，但就是不知道到底發生了什麼事情，後來上網看之後發現日文版的意思比較直觀，比如說有一段我也看不太懂，但日文版就比較清楚 (中文版)艾米莉：\n「我是滅絕體，讓我們的種族滅絕是我們的命運，但在那一刻你也成為這個命運的一部分，你變成了回歸者，DOOMS將我們的惡夢擴散到了全世界」 (日文版)艾米莉：「我是滅絕體，為了將我們的種族引往滅絕才誕生的，當時你也成為了我的一部分，你成為了回歸者，而共享我滅絕夢能力的DOOMS能力者也誕生了」\n所以我後面的劇情是破完之後再去找解析影片才知道到底如何，可能是我資質駑鈍，真的看不懂遊戲最後的劇情吧，要看人家解析才看的懂，如果有人要留言說是我自己理解力有問題，他都看得懂的話，那我想跟你說聲抱歉，我是低能兒，我不配玩這個遊戲，發這篇文章真的是很對不起PTT對不起我的爸爸媽媽，生了一個連遊戲劇情都看不懂的小孩。\n原本還想打更多的，但發現該講的都講完，最後一點雞蛋挑骨頭的大概就是地圖可以再大一點點之類的，很多人說撐過第三章就會好玩，但我是到爬雪山的時候才覺得好玩，因為雪山就開始能針對地形攻略，而且你攻略的越透徹，爬起來就越輕鬆，所以我當初在爬的時候就帶了一堆建材，瘋狂蓋纜車，建材一沒就立刻搭纜車回家拿，這樣把雪山道路牽起來，最後結尾的時候我就是一路從雪山搭車搭到基地，連對話都還沒跑完就到家了。\n結尾就是，如果死亡擱淺有出2，我會買，有朋友要我推薦遊戲，我也會推薦死亡擱淺給他們，畢竟這應該是市面上唯一一款用3A規模製作的獨立遊戲風格的大作了。\n","date":"2022-10-07T02:44:36+08:00","image":"https://i.imgur.com/mg2syAL.jpg","permalink":"https://Hoxton019030.github.io/p/%E6%AD%BB%E4%BA%A1%E6%93%B1%E6%B7%BA%E5%BF%83%E5%BE%97%E5%89%8D%E9%9D%A2%E7%84%A1%E9%9B%B7%E5%BE%8C%E9%9D%A2%E6%9C%89%E9%9B%B7/","title":"死亡擱淺心得，前面無雷，後面有雷"},{"content":"如果你沒有看過黑暗靈魂1代的任何影片，比如說boss介紹、地圖跑法之類的\n也沒有玩過魂3，那我會覺得黑暗靈魂1代很值得玩 但如果你已經看過很多實況主玩過黑暗靈魂，知道怎麼從傳火祭祀場走到灰燼湖 知道怎麼走到不死鎮底層\u0026hellip;諸如此類的事情，那我會建議你不要玩黑魂 因為黑魂1真正有趣的是地圖探索，如果你地圖都知道怎麼跑 那我不建議你玩魂1\n我先從抱怨的地方開始好了，我以下的抱怨都是針對黑暗靈魂1 大部分我抱怨的事情都在魂3有改善了\n1.打Boss的跑屍路程\n魂1裡面有些boss的跑屍路程我覺得是設計的不錯的，比如說守鐘的石像鬼、翁斯坦與? 摩等等，這種路程落在30秒內，路上的阻礙不會嚴重到殺死你的，我覺得是個合格的跑屍流程，這種長度可以在每次跑屍的路上，想看看上次犯的錯要如何修正、哪些招該怎麼閃之類的。但有些boss的跑屍流程我就覺得有點誇張了，比如說墓王尼特、烏薪王葛溫、 混沌的溫床這類型的，跑屍流程大於30秒，路上又不是說特別好跑，比如說初始火爐卡在橋上的黑騎士，或是溫床路上的楔型石惡魔、墓王尼特要先跑過一堆有的沒的的區域才能進霧門，使得我後期越玩越煩躁，前面剛開始打的時候都覺得還好，越到後面的王跑屍過程就越長。\n2.篝火的傳送點太少\n魂1的篝火每個篝火都能主動傳送，但不是每個篝火都能接受傳送，比如病村的底部下? 道的傳點就不能傳過去，只能選擇從蜘蛛女那邊過去，偏偏病村跑圖又不是件很有趣的 事情，會減弱我中途想要回去探索的慾望\n3.靈活度\n魂1的翻滾只能朝前後左右方向滾，所幸魂1大部分的boss都不太需要斜方移動，但操作 來就是卡卡的，而且負重要低於25%才能讓翻滾動畫像魂3那樣絲滑流暢，所以我幾乎都是裸體在玩的。\n至於魂1的優點，我想先老實說，因為我已經知道大家說黑魂1的地圖設計很神，所以在 的時候已經有主觀認知了，所以在玩的時候沒有真的很驚艷的感覺，不死鎮的電梯下來到祭祀場、病村接飛龍之谷接小隆德接祭祀場，這些我都覺得是很棒的設計，但沒有那種大腦震撼的感覺。當初我在玩空洞騎士的時候，還不知道空洞騎士的地圖探索也做得很強，當我偶然間從心血來潮，不選擇搭車，而是在繼續往右走，走到王國邊界時，真的覺得這遊戲的地圖設計真的太強了，所有的一切都環環相扣。但在魂1裡面我沒有感受到這種 感覺過，唯一一個比較接近的應該就是灰燼湖，我很後悔我是從攻略影片上面得知這個地點，我想如果我是自己偶然間走進樹洞，偶然間撞進幻影牆，順著路一路走，最後進入 灰燼湖，踏上古龍之道的話，我想我對魂1的地圖評價應該會更高，但真的很可惜，我透過Youtube、Twitch等等渠道，已經大略的知道魂1的地圖，所以我對於地圖的感受都已經是二手的，就像張愛玲說的「我們對於生活的體驗往往是第二輪的」，自然而然也沒有那麼感動了。\n但魂1還是有些地點是我覺得很有趣的，比如說賽恩古城、地下墓地。古城被譽為賽恩 快樂城、極限體能王，裡面的道路錯綜複雜、又有許多陷阱、埋伏、但實際在跑圖的時候，能感受到這個古城非常用心，怪物的配置、陷阱的位置都有給玩家對應的空間。地下墓地則是讓我體驗了一次神鬼傳奇的感覺，身後有無數隻骷髏士兵永無止盡的追著自己，而自己就要在這種情況下找到篝火，在這一區域每次找到篝火都會讓我有種鬆了口氣的感覺。\n文章差不多就打到這邊了，就像我一開始說的，如果你沒玩過魂3、也不知道魂1的地圖長啥樣，想體驗看看什麼叫地圖設計，那魂1可以嘗試看看，但如果你玩過魂3、或是知道魂1? 那我就覺得魂1不太適合玩了，畢竟也是十年前的作品有些地方都顯得有點過時，建議看看影片、看看實況補完就好，以我自己實際下去玩的感受，我覺得痛苦太多，收穫太少，有趣的點都因為預先知情而被淡化、無趣的點則因為玩過魂3而被無限放大，以上這些都是? 個人意見，如果版上有黑暗靈魂一代粉絲，我就在這邊說聲抱歉了。\n","date":"2022-10-06T23:16:34+08:00","image":"https://i.imgur.com/jQx4JF5.png","permalink":"https://Hoxton019030.github.io/p/%E9%BB%91%E6%9A%97%E9%9D%88%E9%AD%821%E5%BF%83%E5%BE%97/","title":"黑暗靈魂1心得"},{"content":"SpringBoot-Scheduling 用來做定期任務的東西，有兩種\nSpring schedule：只適合處理簡單的計畫任務，不能處理分散式的任務，當任務太多時，可能出現阻塞、崩潰、延遲啟動等問題 Quartz：更強大的一個排程器，能夠配置上百甚至上千的事務。 Spring Schedule 步驟 在啟動類上加上@EnableScheduling 1 2 3 4 5 6 7 @SpringBootApplication() @EnableScheduling public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 在方法上加上@Scheduled 1 2 3 4 5 6 7 @Component public class Task { @Scheduled(fixedDelay = 10 * 100) public void printLocalTime() { System.out.println(LocalTime.now().toString()); } } 1 2 3 4 @Scheduled(cron = \u0026#34;1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } 1 2 3 4 @Scheduled(cron = \u0026#34;0/1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } Cron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 Quartz 是一個開源的任務排程器，幾乎可以整合到任何Java應用程式中。\n它可以用來\n安排每個晚上把資料庫內容轉存到檔案 提供定時提醒服務 族繁不及備載\u0026hellip; 底層數據結構- 堆 介紹 堆是一種特殊的樹，滿足下面兩個條件，就是一個堆\n堆是一顆完全二元樹完整二元樹：除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..) 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 小頂堆\n完整二元樹的一些特性：快速定位父節點\n在排程器的框架中，每一個節點就是一個Job，越頻繁的Job會被放置在越上層的節點\n如何插入元素 尾插法，在尾部插入一個新的元素，然後上浮，浮到符合定義\n除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..)，且最後一層節點都靠左排列 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 如何刪除元素 將尾部(最後一個節點)放置到堆頂，然後下沉\n時間輪算法(Time Wheel) 再刪除元素的時候都需要下沉，當節點數很多時會造成性能延宕\nround 型的時間輪 任務上記錄一個round，遍歷到了就將round減一，為0時取出來執行\n分層時間輪 Cron表達式以及其他排程器所採用的底層架構，分成秒輪、分輪、小時輪、日輪、周輪、月輪、年輪\u0026hellip;，月輪迭代到了，就將任務取出放到天輪中執行\u0026hellip;，以此類推\nCron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 ​\n重要API及概念 記得Job類一定要是public class，不然Scheduler會讀不到\n釋例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Quartz { public static void main(String[] args) { MyJob myJob = new MyJob(); JobDetail jobDetail = JobBuilder.newJob(MyJob.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .build(); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;trigger1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); } catch (SchedulerException e) { throw new RuntimeException(e); } ; } } 1 2 3 4 5 6 public class MyJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;MyJob execute:\u0026#34; + new Date()); } } 釋例二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class HelloJob { public static void main(String[] args) { try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) //Job1是名字，具有唯一性，group1是這個Job屬於哪一組，同一組的Job可以共享相同的邏輯來處理Job。需要name與Job才可以組成一個JobKey .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); // scheduler.shutdown(); } catch (SchedulerException e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @NoArgsConstructor public class SayHello implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail jobDetail = context.getJobDetail();//從context中獲取屬性 JobKey key = jobDetail.getKey(); Class\u0026lt;? extends Job\u0026gt; jobClass = jobDetail.getJobClass(); String description = jobDetail.getDescription(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); String username = jobDataMap.getString(\u0026#34;username\u0026#34;); int age = jobDataMap.getIntValue(\u0026#34;age\u0026#34;); log.info(\u0026#34;\\nJobKey : {},\\n JobClass : {},\\n JobDesc : {},\\n username : {},\\n age : {}\u0026#34;, key, jobClass.getName(), description, username, age); } } Scheduler 生命週期由ScheduleFactory建立開始，呼叫shutdown方法結束。\n當Schduler建立，任何關於Schduling相關的事情，都由它控制\n新增 刪除 列出所有Job 暫停觸發器 在Start之前不會做任何事情\nJob 你希望被排程器排程的任務元件介面，定義如何執行，是正在執行的作業例項，一個Job可以建立多個JobDetail，擁有不同的JobDataMap。本身implement了Job類\n1 2 3 graph TD; Job ---\u0026gt; JodDetail1 \u0026amp; JodDetail2 \u0026amp; JodDetail3 \u0026amp; JodDetail... 1 2 3 4 5 6 public class SendEmail implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;SendEmail\u0026#34;); } } 當Job的觸發器觸發時，排程程式的工作執行將呼叫excute()方法 該方法接收一個JobExcutionContext物件，為Job提供了豐富的執行時環境，比如schduler,trigger,jobDataMap,job,calender,time 何謂Context(上下文)\n可以理解為環境、容器的意思會比上下文更具體一點，它提供了一個程式中全域性的資訊。\nJobDetail 用於定義Job的各種屬性、各種任務，還可以用來為Job儲存狀態資訊的JobDataMap，是將Job加入scheduler時，所需要創建的一個物件，它包含了各種屬性設置，以及用於存取job實例狀態訊息的JobDataMap，在創建JobDetail時，需要將欲執行的類名傳遞給JobDetail，這樣schedule就知道要執行何種類型的job。\n1 JobDetail jobDetail=JobBulider.newJob(Job.class).bulid(); JobDataMap 實作Map介面，因此具有Key-Value，儲存可序列化資料，供Job在執行時使用。也可以使用usingJobData(key,value)在建構JobDetail的時候傳入資料，使用JobDetail.getDataMap()獲取Map。可以再透過jobDataMap取出裡面的數據\n1 2 3 4 JobDetail job = JobBuilder.newJob(HelloJob.class) .withIdentity(\u0026#34;helloJob\u0026#34;, \u0026#34;hello\u0026#34;)//給job命名並分組 .usingJobData(\u0026#34;jobdd\u0026#34;, \u0026#34;hello job\u0026#34;)//通過JobBuilder的usingJobData方法給JobDataMap中塞入數據 .build(); 1 2 3 4 5 6 7 8 9 10 public class HelloJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.err.println(context.getJobDetail().getKey());// JobDetail的key又他的name和group組成 System.err.println(context.getTrigger().getKey());// Trigger的key又他的name和group組成 System.err.println(context.getJobDetail().getJobDataMap().get(\u0026#34;jobdd\u0026#34;)); System.err.println(\u0026#34;hello,quartz\u0026#34;); } } 會輸出\n`hello.helloJob\nhello.helloTrigger\nhello job\nhello, quartz\nTrigger 觸發任務執行，觸發器可能具有與Job有關的JobDataMap，以便將觸發器觸發的引數傳遞給Job，Quartz本身提供了幾種觸發器SimpleTrigger和CronTrigger是最常用到的。\nSimpleTriger 用於一次性執行作業或需要在給定的時間觸發一個作業並重複執行N次，且兩次執行時間有Delay。用在具體的時間點，並已指定的間隔時間重複執行若干次，它包含了幾種屬性：\n開始時間 結束時間 重複次數 重複間隔 釋例一：立刻觸發一次，然後停止\n1 2 3 4 5 Date date = new Date(); Trigger trigger1 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(date) .build(); 釋例二：指定時間觸發，每隔十秒執行一次，重複10次\n1 2 3 4 5 6 7 8 trigger = newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(myTimeToStartFiring) // if a start time is not given (if this line were omitted), \u0026#34;now\u0026#34; is implied .withSchedule(simpleSchedule() .withIntervalInSeconds(10) .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings .forJob(myJob) // identify job with handle to its JobDetail itself .build(); 釋例三：5分鐘以後開始觸發，僅執行一次\n1 2 3 4 5 trigger = (SimpleTrigger) newTrigger() .withIdentity(\u0026#34;trigger5\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future .forJob(myJobKey) // identify job with its JobKey .build(); 釋例四：立即觸發，每個5分鐘執行一次，直到22:00：\n1 2 3 4 5 6 7 trigger = newTrigger() .withIdentity(\u0026#34;trigger7\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(simpleSchedule() .withIntervalInMinutes(5) .repeatForever()) .endAt(dateOf(22, 0, 0)) .build(); 釋例五：在下一小時整點觸發，每個2小時執行一次，一直重複：\n1 2 3 4 5 6 7 8 9 10 11 trigger = newTrigger() .withIdentity(\u0026#34;trigger8\u0026#34;) // because group is not specified, \u0026#34;trigger8\u0026#34; will be in the default group .startAt(evenHourDate(null)) // get the next even-hour (minutes and seconds zero (\u0026#34;00:00\u0026#34;)) .withSchedule(simpleSchedule() .withIntervalInHours(2) .repeatForever()) // note that in this example, \u0026#39;forJob(..)\u0026#39; is not called which is valid // if the trigger is passed to the scheduler along with the job .build(); scheduler.scheduleJob(trigger, job); CronTrigger 希望以日期作為觸發任務的板機，就用CronTriger，實務上比較常用這個\n1 2 3 4 CronTrigger trigger2 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(CronScheduleBuilder.cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.how2java; import static org.quartz.CronScheduleBuilder.cronSchedule; import static org.quartz.JobBuilder.newJob; import static org.quartz.TriggerBuilder.newTrigger; import static org.quartz.SimpleScheduleBuilder.simpleSchedule; import java.util.Date; import org.quartz.CronTrigger; import org.quartz.DateBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SimpleTrigger; import org.quartz.impl.StdSchedulerFactory; public class TestQuartz { public static void main(String[] args) throws Exception{ Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); Date startTime = DateBuilder.nextGivenSecondDate(null, 8); JobDetail job = newJob(MailJob.class).withIdentity(\u0026#34;mailJob\u0026#34;, \u0026#34;mailGroup\u0026#34;).build(); CronTrigger trigger = newTrigger().withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;).withSchedule(cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); // schedule it to run! Date ft = scheduler.scheduleJob(job, trigger); System.out.println(\u0026#34;使用的Cron表达式是：\u0026#34;+trigger.getCronExpression()); // System.out.printf(\u0026#34;%s 这个任务会在 %s 准时开始运行，累计运行%d次，间隔时间是%d毫秒%n\u0026#34;, job.getKey(), ft.toLocaleString(), trigger.getRepeatCount()+1, trigger.getRepeatInterval()); scheduler.start(); //等待200秒，让前面的任务都执行完了之后，再关闭调度器 Thread.sleep(200000); scheduler.shutdown(true); } } JobBulider 用來建立JobDetail\n1 2 3 4 5 6 7 8 JobDetail jobDetail = JobBuilder.newJob(某個繼承了Job的類)... JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); TriggerBulider\n用於建立Trigger\nIdentity 當Job和Trgger在Quartz排程程式中註冊時，會獲得標示鍵，JobKey和TriggerKey置入group中，易於組織管理，其中name與group必須唯一\n為何要將Job和Trigger分開來? While developing Quartz, we decided that it made sense to create a separation between the schedule and the work to be performed on that schedule. This has (in our opinion) many benefits.\nFor example, Jobs can be created and stored in the job scheduler independent of a trigger, and many triggers can be associated with the same job. Another benefit of this loose-coupling is the ability to configure jobs that remain in the scheduler after their associated triggers have expired, so that that it can be rescheduled later, without having to re-define it. It also allows you to modify or replace a trigger without having to re-define its associated job.\nJob與JobDetail的一些說明 Job是正在執行的作業，JobDetail則是作業的定義 一個Job可以創建多個JobDetail，擁有不同的JobDataMap 舉例來說，今天寫了一個定時寄送信件的Job，叫做SendEmailJob，我們希望這個Job可以寄給客戶，然後在cc給你的主管，所以需要創建兩個不同的JobDetail，比如說SendEmailToClient、SendEmailToAdministor，並透過JobDataMap綁定參數傳遞至JobDetail中，這兩個JobDetail擁有各自獨立的JobDataMap，實現起來會更靈活。\n參考 官方文檔\n任務排程框架Quartz快速入門\nQuartz教學基礎\n觸發器詳細定義\n","date":"2022-10-06T23:14:21+08:00","image":"https://i.imgur.com/9or5BzU.png","permalink":"https://Hoxton019030.github.io/p/java%E5%85%A7%E7%9A%84%E7%89%8C%E7%A8%8B%E5%99%A8%E4%BB%8B%E7%B4%B9/","title":"Java內的牌程器介紹"}]