[{"content":"​\t如果你是好奇死亡擱淺這款遊戲到底好不好玩，擔心對不到電波，怕買了浪費錢的人可以聽看看我的想法\u0026ndash;「我覺得很難歸納出哪種類型的人會喜歡死亡擱淺」 我只能說，會比較推薦給至少能撥出個1、2小時玩遊戲的人才會比較適合玩。\n無雷心得：\n我本身不是小島秀夫的粉絲，他的作品我也只玩過幻痛而已，而且 我覺得幻痛超級無聊，遊戲評分鼓勵你不殺，所以你很多裝備是不能用 的，而且地圖設計也稱不上有趣，荒漠和草原的地形空蕩到很空虛，不太能理解 為什麼硬要做成開放地圖，A任務做完要到B任務就只能自己過去、或是叫直升機等等的。看完了儀式之人的影片後也沒有覺得躍躍欲試的感覺，玩了20個小時後真的撐不下去就 不玩了，所以我在買死亡擱淺前其實猶豫很久，因為我知道我可能會Get不到遊戲有趣的點? 後來還是抱持著是驢是馬遛看看的心情買了下去。\n純論遊戲心得，並且在不暴雷太多重要劇情的情形下，死亡擱淺最大的樂趣在於遊戲一開始剝奪你很多東西，初期會要求你背著大重量的貨物到有一段距離的地方，然後這路上可能有懸崖、陡坡之類的地形阻隔著你，所以初期會對於這些事情覺得很毛躁、等到遊戲中期，開始出現很多東西能輔助你送貨，能裝載更多重量的、加速的，會讓你覺得所有的一切不再那麼痛苦，而後期當你解鎖所有設施、道具之後，你會開始愛上送貨這件事情，我覺得這點蠻神奇的，因為在往常的遊戲裡面跑腿送貨是最無聊的環節，你會用快速旅行直接省略掉這個過程，但在死亡擱淺裡你會體認到，所有的一切都是自己努力而來的，是自己讓這件事情變得輕鬆，變得平易近人，就好比學習一項事物，從排斥到接受，再到學以致用，漸漸地愛上一件事情。\n​\t我記得有一個晚上我就上線，也沒推任何主線劇情，就很單純的從A點接單送到B點，再從B點接單送到C點，然後再從C點接單送到B點這樣往復巡還，聽起來很無聊，但我當時送完貨物跑出結算畫面，看到滿滿的SSS時，真的覺得送貨使我快樂。\n另一點我覺得有趣的是遊戲裡面的線上模式，會讓你的地圖裡出現其他玩家的建物，比如說休息站、涼亭之類的，或者是其他玩家的登山索、樓梯，這點不是死亡擱淺原創，但在這遊戲裡面卻是我最喜歡的一點，在爬山的時候爬著其他玩家的梯子，然後在山頂看到其他玩家撒尿的蘑菇叢、然後在拉著其他玩家的纜繩下山，雖然你無法看到那些玩家的身影，但它們在你的世界留下的足跡卻令他們的形象具體而鮮明，在你在河流底部發現散落的貨品、峽谷下方報廢的摩托車，宛若有一段故事被濃縮成一個小小的物品，而這個小小的物品又經由你的發現而解壓縮成一段送貨之旅，死亡擱淺大部分的遊戲時間都是獨自一人的，但這種設計讓這個世界不在那麼冰冷，而多了些許溫度。\n最後是這個遊戲的氛圍，死亡擱在某些地形出現的時候（比如說高山、平原、裂谷）會撥放一些很空靈感的歌，配合上游戲的畫面、眼前的景象，山姆苗小的身影形成強烈的對比，耳中響起的和聲與山姆亦步亦趨的步伐，行走在一望無際的大草原，所有的一切都是空的，但心中卻被滿滿的感動填滿著。\n死亡擱淺到底適合什麼樣的人，我覺得只有自己玩了才能知道，他就是一款這麼特別的遊戲，看起來很無聊，但玩起來卻比想像中的有趣。\n有雷心得：\n其實玩完之後，我原本是很期待劇情而對遊戲性無感，但玩完後我卻相反過來 ，因為我劇情看不太懂，但遊戲性卻是出乎我意料之外的好。遊戲到尾聲之前我是都看得懂的，大概就是我們要去救艾米莉，但有個叫希格斯的人百般阻饒，然後頑人藏著什麼秘密。但當艾米莉出來之後我就完全看不懂了，我只能理解到一個艾米莉在冥灘、另一個在總統府當總統，但不能理解為什麼她要希格斯又要山姆，也不能理解她是不是好人，因為從結尾畫面上看來，艾米莉是想要毀掉世界的，但當山姆放下槍後她卻又抱著山姆說了一段我不明所以的台詞：\n「我做過無數個夢，我不知道該相信哪一個，所以我才決定跟你和其他人分享我的夢境，但是為了讓點連成一條線，讓一切都弄清楚，你們需要看得更透徹。你們需要時間。時間對我沒有任何意義，我不是一條線，我是單獨存在的點\u0026hellip;(省略)\u0026hellip;你(山姆)找到了共通的線，把所有點串在一起，而且你用唯一可能的方式做到了，也就是努力活好每一天，謝謝你山姆。」 ​\t這邊我看不懂的原因，是因為不能理解為什麼山姆努力活好每一天就能把所有點串成一條線，也不能理解為什麼山姆把所有的點連城線之後就可以進行大滅絕，我聽得出來翻譯的字幕和語音是對的上的，沒有亂翻，但就是不知道到底發生了什麼事情，後來上網看之後發現日文版的意思比較直觀，比如說有一段我也看不太懂，但日文版就比較清楚 (中文版)艾米莉：\n「我是滅絕體，讓我們的種族滅絕是我們的命運，但在那一刻你也成為這個命運的一部分，你變成了回歸者，DOOMS將我們的惡夢擴散到了全世界」 (日文版)艾米莉：「我是滅絕體，為了將我們的種族引往滅絕才誕生的，當時你也成為了我的一部分，你成為了回歸者，而共享我滅絕夢能力的DOOMS能力者也誕生了」\n所以我後面的劇情是破完之後再去找解析影片才知道到底如何，可能是我資質駑鈍，真的看不懂遊戲最後的劇情吧，要看人家解析才看的懂，如果有人要留言說是我自己理解力有問題，他都看得懂的話，那我想跟你說聲抱歉，我是低能兒，我不配玩這個遊戲，發這篇文章真的是很對不起PTT對不起我的爸爸媽媽，生了一個連遊戲劇情都看不懂的小孩。\n原本還想打更多的，但發現該講的都講完，最後一點雞蛋挑骨頭的大概就是地圖可以再大一點點之類的，很多人說撐過第三章就會好玩，但我是到爬雪山的時候才覺得好玩，因為雪山就開始能針對地形攻略，而且你攻略的越透徹，爬起來就越輕鬆，所以我當初在爬的時候就帶了一堆建材，瘋狂蓋纜車，建材一沒就立刻搭纜車回家拿，這樣把雪山道路牽起來，最後結尾的時候我就是一路從雪山搭車搭到基地，連對話都還沒跑完就到家了。\n結尾就是，如果死亡擱淺有出2，我會買，有朋友要我推薦遊戲，我也會推薦死亡擱淺給他們，畢竟這應該是市面上唯一一款用3A規模製作的獨立遊戲風格的大作了。\n","date":"2022-10-07T02:44:36+08:00","image":"https://i.imgur.com/mg2syAL.jpg","permalink":"https://Hoxton019030.github.io/p/%E6%AD%BB%E4%BA%A1%E6%93%B1%E6%B7%BA%E5%BF%83%E5%BE%97%E5%89%8D%E9%9D%A2%E7%84%A1%E9%9B%B7%E5%BE%8C%E9%9D%A2%E6%9C%89%E9%9B%B7/","title":"死亡擱淺心得，前面無雷，後面有雷"},{"content":"如果你沒有看過黑暗靈魂1代的任何影片，比如說boss介紹、地圖跑法之類的\n也沒有玩過魂3，那我會覺得黑暗靈魂1代很值得玩 但如果你已經看過很多實況主玩過黑暗靈魂，知道怎麼從傳火祭祀場走到灰燼湖 知道怎麼走到不死鎮底層\u0026hellip;諸如此類的事情，那我會建議你不要玩黑魂 因為黑魂1真正有趣的是地圖探索，如果你地圖都知道怎麼跑 那我不建議你玩魂1\n我先從抱怨的地方開始好了，我以下的抱怨都是針對黑暗靈魂1 大部分我抱怨的事情都在魂3有改善了\n1.打Boss的跑屍路程\n魂1裡面有些boss的跑屍路程我覺得是設計的不錯的，比如說守鐘的石像鬼、翁斯坦與? 摩等等，這種路程落在30秒內，路上的阻礙不會嚴重到殺死你的，我覺得是個合格的跑屍流程，這種長度可以在每次跑屍的路上，想看看上次犯的錯要如何修正、哪些招該怎麼閃之類的。但有些boss的跑屍流程我就覺得有點誇張了，比如說墓王尼特、烏薪王葛溫、 混沌的溫床這類型的，跑屍流程大於30秒，路上又不是說特別好跑，比如說初始火爐卡在橋上的黑騎士，或是溫床路上的楔型石惡魔、墓王尼特要先跑過一堆有的沒的的區域才能進霧門，使得我後期越玩越煩躁，前面剛開始打的時候都覺得還好，越到後面的王跑屍過程就越長。\n2.篝火的傳送點太少\n魂1的篝火每個篝火都能主動傳送，但不是每個篝火都能接受傳送，比如病村的底部下? 道的傳點就不能傳過去，只能選擇從蜘蛛女那邊過去，偏偏病村跑圖又不是件很有趣的 事情，會減弱我中途想要回去探索的慾望\n3.靈活度\n魂1的翻滾只能朝前後左右方向滾，所幸魂1大部分的boss都不太需要斜方移動，但操作 來就是卡卡的，而且負重要低於25%才能讓翻滾動畫像魂3那樣絲滑流暢，所以我幾乎都是裸體在玩的。\n至於魂1的優點，我想先老實說，因為我已經知道大家說黑魂1的地圖設計很神，所以在 的時候已經有主觀認知了，所以在玩的時候沒有真的很驚艷的感覺，不死鎮的電梯下來到祭祀場、病村接飛龍之谷接小隆德接祭祀場，這些我都覺得是很棒的設計，但沒有那種大腦震撼的感覺。當初我在玩空洞騎士的時候，還不知道空洞騎士的地圖探索也做得很強，當我偶然間從心血來潮，不選擇搭車，而是在繼續往右走，走到王國邊界時，真的覺得這遊戲的地圖設計真的太強了，所有的一切都環環相扣。但在魂1裡面我沒有感受到這種 感覺過，唯一一個比較接近的應該就是灰燼湖，我很後悔我是從攻略影片上面得知這個地點，我想如果我是自己偶然間走進樹洞，偶然間撞進幻影牆，順著路一路走，最後進入 灰燼湖，踏上古龍之道的話，我想我對魂1的地圖評價應該會更高，但真的很可惜，我透過Youtube、Twitch等等渠道，已經大略的知道魂1的地圖，所以我對於地圖的感受都已經是二手的，就像張愛玲說的「我們對於生活的體驗往往是第二輪的」，自然而然也沒有那麼感動了。\n但魂1還是有些地點是我覺得很有趣的，比如說賽恩古城、地下墓地。古城被譽為賽恩 快樂城、極限體能王，裡面的道路錯綜複雜、又有許多陷阱、埋伏、但實際在跑圖的時候，能感受到這個古城非常用心，怪物的配置、陷阱的位置都有給玩家對應的空間。地下墓地則是讓我體驗了一次神鬼傳奇的感覺，身後有無數隻骷髏士兵永無止盡的追著自己，而自己就要在這種情況下找到篝火，在這一區域每次找到篝火都會讓我有種鬆了口氣的感覺。\n文章差不多就打到這邊了，就像我一開始說的，如果你沒玩過魂3、也不知道魂1的地圖長啥樣，想體驗看看什麼叫地圖設計，那魂1可以嘗試看看，但如果你玩過魂3、或是知道魂1? 那我就覺得魂1不太適合玩了，畢竟也是十年前的作品有些地方都顯得有點過時，建議看看影片、看看實況補完就好，以我自己實際下去玩的感受，我覺得痛苦太多，收穫太少，有趣的點都因為預先知情而被淡化、無趣的點則因為玩過魂3而被無限放大，以上這些都是? 個人意見，如果版上有黑暗靈魂一代粉絲，我就在這邊說聲抱歉了。\n","date":"2022-10-06T23:16:34+08:00","image":"https://i.imgur.com/jQx4JF5.png","permalink":"https://Hoxton019030.github.io/p/%E9%BB%91%E6%9A%97%E9%9D%88%E9%AD%821%E5%BF%83%E5%BE%97/","title":"黑暗靈魂1心得"},{"content":"SpringBoot-Scheduling 用來做定期任務的東西，有兩種\nSpring schedule：只適合處理簡單的計畫任務，不能處理分散式的任務，當任務太多時，可能出現阻塞、崩潰、延遲啟動等問題 Quartz：更強大的一個排程器，能夠配置上百甚至上千的事務。 Spring Schedule 步驟 在啟動類上加上@EnableScheduling 1 2 3 4 5 6 7 @SpringBootApplication() @EnableScheduling public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 在方法上加上@Scheduled 1 2 3 4 5 6 7 @Component public class Task { @Scheduled(fixedDelay = 10 * 100) public void printLocalTime() { System.out.println(LocalTime.now().toString()); } } 1 2 3 4 @Scheduled(cron = \u0026#34;1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } 1 2 3 4 @Scheduled(cron = \u0026#34;0/1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } Cron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 Quartz 是一個開源的任務排程器，幾乎可以整合到任何Java應用程式中。\n它可以用來\n安排每個晚上把資料庫內容轉存到檔案 提供定時提醒服務 族繁不及備載\u0026hellip; 底層數據結構- 堆 介紹 堆是一種特殊的樹，滿足下面兩個條件，就是一個堆\n堆是一顆完全二元樹完整二元樹：除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..) 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 小頂堆\n完整二元樹的一些特性：快速定位父節點\n在排程器的框架中，每一個節點就是一個Job，越頻繁的Job會被放置在越上層的節點\n如何插入元素 尾插法，在尾部插入一個新的元素，然後上浮，浮到符合定義\n除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..)，且最後一層節點都靠左排列 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 如何刪除元素 將尾部(最後一個節點)放置到堆頂，然後下沉\n時間輪算法(Time Wheel) 再刪除元素的時候都需要下沉，當節點數很多時會造成性能延宕\nround 型的時間輪 任務上記錄一個round，遍歷到了就將round減一，為0時取出來執行\n分層時間輪 Cron表達式以及其他排程器所採用的底層架構，分成秒輪、分輪、小時輪、日輪、周輪、月輪、年輪\u0026hellip;，月輪迭代到了，就將任務取出放到天輪中執行\u0026hellip;，以此類推\nCron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 ​\n重要API及概念 記得Job類一定要是public class，不然Scheduler會讀不到\n釋例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Quartz { public static void main(String[] args) { MyJob myJob = new MyJob(); JobDetail jobDetail = JobBuilder.newJob(MyJob.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .build(); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;trigger1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); } catch (SchedulerException e) { throw new RuntimeException(e); } ; } } 1 2 3 4 5 6 public class MyJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;MyJob execute:\u0026#34; + new Date()); } } 釋例二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class HelloJob { public static void main(String[] args) { try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) //Job1是名字，具有唯一性，group1是這個Job屬於哪一組，同一組的Job可以共享相同的邏輯來處理Job。需要name與Job才可以組成一個JobKey .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); // scheduler.shutdown(); } catch (SchedulerException e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @NoArgsConstructor public class SayHello implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail jobDetail = context.getJobDetail();//從context中獲取屬性 JobKey key = jobDetail.getKey(); Class\u0026lt;? extends Job\u0026gt; jobClass = jobDetail.getJobClass(); String description = jobDetail.getDescription(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); String username = jobDataMap.getString(\u0026#34;username\u0026#34;); int age = jobDataMap.getIntValue(\u0026#34;age\u0026#34;); log.info(\u0026#34;\\nJobKey : {},\\n JobClass : {},\\n JobDesc : {},\\n username : {},\\n age : {}\u0026#34;, key, jobClass.getName(), description, username, age); } } Scheduler 生命週期由ScheduleFactory建立開始，呼叫shutdown方法結束。\n當Schduler建立，任何關於Schduling相關的事情，都由它控制\n新增 刪除 列出所有Job 暫停觸發器 在Start之前不會做任何事情\nJob 你希望被排程器排程的任務元件介面，定義如何執行，是正在執行的作業例項，一個Job可以建立多個JobDetail，擁有不同的JobDataMap。本身implement了Job類\n1 2 3 graph TD; Job ---\u0026gt; JodDetail1 \u0026amp; JodDetail2 \u0026amp; JodDetail3 \u0026amp; JodDetail... 1 2 3 4 5 6 public class SendEmail implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;SendEmail\u0026#34;); } } 當Job的觸發器觸發時，排程程式的工作執行將呼叫excute()方法 該方法接收一個JobExcutionContext物件，為Job提供了豐富的執行時環境，比如schduler,trigger,jobDataMap,job,calender,time 何謂Context(上下文)\n可以理解為環境、容器的意思會比上下文更具體一點，它提供了一個程式中全域性的資訊。\nJobDetail 用於定義Job的各種屬性、各種任務，還可以用來為Job儲存狀態資訊的JobDataMap，是將Job加入scheduler時，所需要創建的一個物件，它包含了各種屬性設置，以及用於存取job實例狀態訊息的JobDataMap，在創建JobDetail時，需要將欲執行的類名傳遞給JobDetail，這樣schedule就知道要執行何種類型的job。\n1 JobDetail jobDetail=JobBulider.newJob(Job.class).bulid(); JobDataMap 實作Map介面，因此具有Key-Value，儲存可序列化資料，供Job在執行時使用。也可以使用usingJobData(key,value)在建構JobDetail的時候傳入資料，使用JobDetail.getDataMap()獲取Map。可以再透過jobDataMap取出裡面的數據\n1 2 3 4 JobDetail job = JobBuilder.newJob(HelloJob.class) .withIdentity(\u0026#34;helloJob\u0026#34;, \u0026#34;hello\u0026#34;)//給job命名並分組 .usingJobData(\u0026#34;jobdd\u0026#34;, \u0026#34;hello job\u0026#34;)//通過JobBuilder的usingJobData方法給JobDataMap中塞入數據 .build(); 1 2 3 4 5 6 7 8 9 10 public class HelloJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.err.println(context.getJobDetail().getKey());// JobDetail的key又他的name和group組成 System.err.println(context.getTrigger().getKey());// Trigger的key又他的name和group組成 System.err.println(context.getJobDetail().getJobDataMap().get(\u0026#34;jobdd\u0026#34;)); System.err.println(\u0026#34;hello,quartz\u0026#34;); } } 會輸出\n`hello.helloJob\nhello.helloTrigger\nhello job\nhello, quartz\nTrigger 觸發任務執行，觸發器可能具有與Job有關的JobDataMap，以便將觸發器觸發的引數傳遞給Job，Quartz本身提供了幾種觸發器SimpleTrigger和CronTrigger是最常用到的。\nSimpleTriger 用於一次性執行作業或需要在給定的時間觸發一個作業並重複執行N次，且兩次執行時間有Delay。用在具體的時間點，並已指定的間隔時間重複執行若干次，它包含了幾種屬性：\n開始時間 結束時間 重複次數 重複間隔 釋例一：立刻觸發一次，然後停止\n1 2 3 4 5 Date date = new Date(); Trigger trigger1 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(date) .build(); 釋例二：指定時間觸發，每隔十秒執行一次，重複10次\n1 2 3 4 5 6 7 8 trigger = newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(myTimeToStartFiring) // if a start time is not given (if this line were omitted), \u0026#34;now\u0026#34; is implied .withSchedule(simpleSchedule() .withIntervalInSeconds(10) .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings .forJob(myJob) // identify job with handle to its JobDetail itself .build(); 釋例三：5分鐘以後開始觸發，僅執行一次\n1 2 3 4 5 trigger = (SimpleTrigger) newTrigger() .withIdentity(\u0026#34;trigger5\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future .forJob(myJobKey) // identify job with its JobKey .build(); 釋例四：立即觸發，每個5分鐘執行一次，直到22:00：\n1 2 3 4 5 6 7 trigger = newTrigger() .withIdentity(\u0026#34;trigger7\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(simpleSchedule() .withIntervalInMinutes(5) .repeatForever()) .endAt(dateOf(22, 0, 0)) .build(); 釋例五：在下一小時整點觸發，每個2小時執行一次，一直重複：\n1 2 3 4 5 6 7 8 9 10 11 trigger = newTrigger() .withIdentity(\u0026#34;trigger8\u0026#34;) // because group is not specified, \u0026#34;trigger8\u0026#34; will be in the default group .startAt(evenHourDate(null)) // get the next even-hour (minutes and seconds zero (\u0026#34;00:00\u0026#34;)) .withSchedule(simpleSchedule() .withIntervalInHours(2) .repeatForever()) // note that in this example, \u0026#39;forJob(..)\u0026#39; is not called which is valid // if the trigger is passed to the scheduler along with the job .build(); scheduler.scheduleJob(trigger, job); CronTrigger 希望以日期作為觸發任務的板機，就用CronTriger，實務上比較常用這個\n1 2 3 4 CronTrigger trigger2 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(CronScheduleBuilder.cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.how2java; import static org.quartz.CronScheduleBuilder.cronSchedule; import static org.quartz.JobBuilder.newJob; import static org.quartz.TriggerBuilder.newTrigger; import static org.quartz.SimpleScheduleBuilder.simpleSchedule; import java.util.Date; import org.quartz.CronTrigger; import org.quartz.DateBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SimpleTrigger; import org.quartz.impl.StdSchedulerFactory; public class TestQuartz { public static void main(String[] args) throws Exception{ Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); Date startTime = DateBuilder.nextGivenSecondDate(null, 8); JobDetail job = newJob(MailJob.class).withIdentity(\u0026#34;mailJob\u0026#34;, \u0026#34;mailGroup\u0026#34;).build(); CronTrigger trigger = newTrigger().withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;).withSchedule(cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); // schedule it to run! Date ft = scheduler.scheduleJob(job, trigger); System.out.println(\u0026#34;使用的Cron表达式是：\u0026#34;+trigger.getCronExpression()); // System.out.printf(\u0026#34;%s 这个任务会在 %s 准时开始运行，累计运行%d次，间隔时间是%d毫秒%n\u0026#34;, job.getKey(), ft.toLocaleString(), trigger.getRepeatCount()+1, trigger.getRepeatInterval()); scheduler.start(); //等待200秒，让前面的任务都执行完了之后，再关闭调度器 Thread.sleep(200000); scheduler.shutdown(true); } } JobBulider 用來建立JobDetail\n1 2 3 4 5 6 7 8 JobDetail jobDetail = JobBuilder.newJob(某個繼承了Job的類)... JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); TriggerBulider\n用於建立Trigger\nIdentity 當Job和Trgger在Quartz排程程式中註冊時，會獲得標示鍵，JobKey和TriggerKey置入group中，易於組織管理，其中name與group必須唯一\n為何要將Job和Trigger分開來? While developing Quartz, we decided that it made sense to create a separation between the schedule and the work to be performed on that schedule. This has (in our opinion) many benefits.\nFor example, Jobs can be created and stored in the job scheduler independent of a trigger, and many triggers can be associated with the same job. Another benefit of this loose-coupling is the ability to configure jobs that remain in the scheduler after their associated triggers have expired, so that that it can be rescheduled later, without having to re-define it. It also allows you to modify or replace a trigger without having to re-define its associated job.\nJob與JobDetail的一些說明 Job是正在執行的作業，JobDetail則是作業的定義 一個Job可以創建多個JobDetail，擁有不同的JobDataMap 舉例來說，今天寫了一個定時寄送信件的Job，叫做SendEmailJob，我們希望這個Job可以寄給客戶，然後在cc給你的主管，所以需要創建兩個不同的JobDetail，比如說SendEmailToClient、SendEmailToAdministor，並透過JobDataMap綁定參數傳遞至JobDetail中，這兩個JobDetail擁有各自獨立的JobDataMap，實現起來會更靈活。\n參考 官方文檔\n任務排程框架Quartz快速入門\nQuartz教學基礎\n觸發器詳細定義\n","date":"2022-10-06T23:14:21+08:00","image":"https://i.imgur.com/9or5BzU.png","permalink":"https://Hoxton019030.github.io/p/schduler/","title":"Schduler"}]