[{"content":"常用指令 查看目前的image\n1 docker image ls 或是\n1 docker images 執行docker image\n1 docker run [imageName] 打包成docker image\n1 docker build -t drink-more-water . -t 是 tag的縮寫，hello-docker是這個tag的名稱，.代表所有檔案(吧?\n​\n查看目前運作中的Container\n1 docker ps 或是\n1 docker ps -a 查看底下全部的Container不論啟動與否\n​\n在Docker啟動Ubuntu 下載 ubuntu 的image\n1 docker pull ubuntu 或是可以\n1 docker run ubuntu 就會自動從docker hub載下來了，但這樣只是把ubuntu的image拉到我們的docker裡面，它本身是沒有啟動的\n在docker中運行ubuntu\n1 docker run -it ubuntu 使用apt(advanced package tool)安裝nano(Linux text editor)\n用apt載任何東西前都建議先update\n1 apt update 1 apt install nano ","date":"2023-01-18T21:47:50+08:00","image":"https://i.imgur.com/JdDwgHn.png ","permalink":"https://hoxtonhsu.com/p/docker%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","title":"Docker學習筆記"},{"content":" 前陣子在網路上找看看有沒有什麼實用的Git指令，無意間看到這個功能。\n只要在Github的頁面按下 \u0026gt; ，就可以開啟網頁版的Vscode囉，不過有個小缺點就是，Vscode開啟時介面語言是依據你瀏覽器的語言所決定，所以如果想要使用英文版的Vscode就要把Chrome的語言設定成英文喔。\n這樣開啟後最直觀的好處就是可以直接在Github上以Vscode編輯程式碼，做快速的修改，瀏覽起來也比較快，不然原本網頁在看的話速度非常的慢！並且也可以在上面做衝突的處理。\n","date":"2023-01-11T23:27:27+08:00","image":"https://i.imgur.com/Gckim1N.png","permalink":"https://hoxtonhsu.com/p/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%97%8E%E7%8F%BE%E5%9C%A8github%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8vscode%E5%96%94/","title":"你知道嗎?現在Github上也可以使用Vscode喔！"},{"content":"前言 整理一下工作上有用過，並覺得實用、比較少人提過的一些Git指令。\nGit指令 退回到上一個Commit，數字可以更改，1就是上一次，改成三的話就是三次前的Commit 1 git checkout HEAD~1 退回上一次的Commit，重複輸入的話會往復循環 1 git checkout - 將本次修改合併至上次Commit，如果有漏掉的提交會常用這個指令 1 git commit --amend --no-edit ","date":"2023-01-06T14:15:51+08:00","image":"https://i.imgur.com/nCGDuUc.png ","permalink":"https://hoxtonhsu.com/p/%E5%AF%A6%E7%94%A8%E7%9A%84git%E6%8C%87%E4%BB%A4/","title":"實用的Git指令"},{"content":"開頭 Java中的例外分為受檢例外與非受檢例外(RuntimeExcetption)兩大類，可以先看到這張圖。\n所謂的非受檢例外就是指繼承了RuntimeException的Exception，這類的Exception發生，而非受檢例外就是指沒有繼承RuntimeException的Exception。可以看下列的圖片\n何謂受檢例外與非受檢例外 受檢例外之所以叫受檢例外，就在於這些例外是工程師必須明確檢查並處理的例外，例如讀取檔案時發生的FileNotFoundException，這類的Exception，JVM沒有辦法進行處理，因此需要工程師去做處理。而RumtimeException則是指那些工程師不需要去明確處理的Exception，比如說NullPointerException, ArrayIndexOutOfBoundsException，這類的例外都是繼承自RuntimeException，可以由JVM進行處理，當然要處理也是可以的，比如說這樣\n(可以看到左邊第13行的方法，沒有被try..catch包住也沒事，因為該方法拋出的例外是NumberFormatException，這個例外繼承了RuntimeException，因此不用try\u0026hellip;catch處理也沒關係，JVM會自動幫我們處理，如果要放到try\u0026hellip;catch的話，則是在catch段裡去catch NumberFormatException)\n將方法放入try\u0026hellip;catch之後，因為catch是抓RuntimeException，所以被抓到後會print出catch error。\n另外比較實務上的說法即是，受檢例外(checked Exception)是可被修復的例外，可以試看看retry，而不可修復的例外就是非受檢例外(RunTimeException)，這種時候就代表程式出了問題，有bug，需要工程師下來進行處理，把問題處理掉\n來源：2021 IT 鐵人 Day 09 單元測試與例外處理\n那如果一個method會拋出受檢例外，而在該method中又沒有做處理，則會需要呼叫它的那一個method進行處理。\n右邊的方法實際上不會拋出IOException，所以會顯示為灰色的，這邊只是作為Demo先寫上去。可以看到畫面左邊的地方，此時IDE跟我們報錯，說這個方法會拋出一個IOException，要我們進行處理，因為IOException是一個受檢例外，JVM本身沒有能力可以進行處理。\n大概先這樣，其他想到後補。\n","date":"2022-12-27T15:12:58+08:00","image":"https://i.imgur.com/dwbYvaF.png","permalink":"https://hoxtonhsu.com/p/java%E4%B8%AD%E7%9A%84throwthrowstry...catch%E5%8F%97%E6%AA%A2%E4%BE%8B%E5%A4%96%E8%88%87%E9%9D%9E%E5%8F%97%E6%AA%A2%E4%BE%8B%E5%A4%96/","title":"Java中的throw,throws,try...catch，受檢例外與非受檢例外"},{"content":"序言 參考資料：\nAgile Hsinchu 2022.11 - 〈你就是不寫測試，才會沒時間〉線上導讀\n測試有時間再寫？你就是不寫才會沒時間！\n你就是都不寫測試才會沒時間：Kuma 的 30 天 Unit Test 手把手教學，從理論到實戰 （Java 篇）\nTDD(Test-Driven Development)是一個軟體開發的模式，它的概念很簡單，就是先寫測試在寫程式，\n這樣的事情會讓我們覺得不可思議，因為我們一直以來寫程式的方式都是先寫程式，而測試則是有時間才再補的東西。那改成先寫測試會有什麼好處呢？這部分我們等等再來談，我們先討論TDD最核心的部分—單元測試(Unit Test)。\n單元測試在TDD的作用是什麼 ​\t一開始在認識單元測試的時候，許多人的想法都會認為說，單元測試可以避免Bug，可以提升程式碼的品質。確實這些都是Unit Test的好處，但卻不是最核心的關鍵，單元測試最重要的點在於幫助我們重構現有的程式架構。\n​\t我們在經手一個項目的時候，第二個月的理解一定會比第一個月的理解更深，第三個月的理解也一定會比第二個月的理解更加深刻，可能三個月前所使用的架構，在三個月後，隨著業務規模的擴展、需求的增加，而需要去新增新的程式，或是改變原有的設計，因而漸漸不敷使用，在這樣的情形下，若沒有單元測試的保護支持我們重構，讓我們確保每一步的Design都沒有破壞原有程式的設計，工程師會變得去害怕修改舊有的程式碼，因而導致不敷使用的架構繼續生長下去。\n(▲ 程式能跑，但還能在更好）\n​\t如果只是這樣子還沒什麼問題，畢竟就只是把東西一個接著一個地疊上去，頂多就是不好維護而已。但實際上的開發中，是很常出現改Ａ壞Ｂ這種情況的，在沒有單元測試的保護下，工程師在開發中是不會知道自己更新的這段程式碼會對某些程式造成影響，往往要等到合併後才能出現問題，所以會出現一種情況就是前期開發的都很順利，而越到後面Dead Line，效率就越發下降，因為工程師在開發的當下不知道自己新增的功能到底會不會對別人造成影響。而有了測試的保護，我們可以在寫程式的時候就知道現在程式的運行狀況，今天這樣子的修改會不會導致其他程式跑不起來，如果跑不起來那單元測試就不會過，這樣的回饋是立即性的回應，而不需要等到合併後大家才知道。\n(▲ 隨著開發時間的增加，TDD的優勢會更凸顯出來）\nAgile與TDD 講到Agile就會講到瀑布式開發(WaterFall)，但你知道嗎？其實從來都沒有瀑布式開發這種事情喔。\n瀑布式開發是來自於Winston Royce在1970所提出的論文Managing the Development of Larger Software Systems被提出，但事實上這個開發模式在這篇論文的下一行就被Winston Royce否決了。\nI believe in this concept, but the implementation described above is risky and inivites failure. The problem is illustrated in Figure 4 .\n我相信這個概念，但照著這上面的流程做的話是高風險且易導致錯誤的，原因就如第四張圖所示\n​\t(▲Figure 4)\nThe testing phase which occurs at the end of the development cycle is the first event for which timing, stotage, input/output transfers, etc, are experienced as distinguished from analyzed. These phenomena are not precisely analyzable. There phenomena are not precisely analyzable. They are not the solutions or the satndard partial differential quations of mathematical physics for instatnce. Yet if there phenomena fail to satisfy the various external constraints, then invariablt a major redesign is required . A simple octal patch or redo of some isolated code will not fix there kinds of difficulties. The required design changes are likely to be so disruptive that the software requiremnets upon which the design is based and which provides the rationale for everything are violated. Either the requirements must be modified, or a substantial change in the design is required. In effect the development process has returned to the origin and one can expect up to a 100-percent overrun in schedule and/or costs\n在開發流程的最後一個階段-測試，第一個遇到的事情就是時序、儲存，輸出輸入，這些現象情況無法準確的分析，這些不像數學物理的解答，或是標準偏微方程，然而，如果存在不能滿足各種外部約束的現象，則不可避免地需要進行重大的重新設計，一個簡單的八進制補丁或一些孤立代碼的重做不會解決這些困難，所需的設計更改可能會造成破壞，以至於違反了設計所基於的以及為所有事情提供基本原理的軟件要求。 要么必須修改要求，要么需要對設計進行實質性更改。 實際上，開發過程已經回到原點，預計進度和/或成本會超支 100%。\nWinston Royce在瀑布模型提出的當下其實就否認了它的意義，但後續被一些人拿來當作開發的窠臼，也導致了這種開發模式往往會在完工時出現重大的危害。Winston Royce認為，在最後的測試階段是充滿著未知與不確定性，到最後會反覆著在測試、程式修改、確認需求這三個階段來回擺盪，這樣三個階段的來回擺盪是不是有點似曾相似呢？沒錯，就是TDD的概念\n什麼是TDD TDD是一個開發模式而不是測試模式，TDD的測試模式是由\n寫一個會錯的測試 寫一個剛好會過的程式 重構 ​\t這三者循環，對應Winston Royce對瀑布模型提出的弊端，也就是測試、修改程式、確認需求，也因此TDD是一個可以讓問題早期浮上水面的開發方式，為什麼？因為這樣的開發方式要求我們對業務邏輯的需求有充分的了解，這樣我們才可以寫測試，一旦需求明確了，那麼寫出程式就只是時間的問題了。\n​\t另一方面，也是因為TDD的開發模式，我們每一個Code都有單元測試的保護，我們可以隨時重構我們的程式碼而毋須擔心程式被我們改錯，是的，沒錯，TDD的一個核心概念就在於任何時候都可以重構我們的程式碼，因為人對於系統的了解，會隨著開發時間的增加而了解的越深刻，半年前的Code到了現在可能越看越不順眼，另一方面，隨著業務規模的提升，我們早期的設計可能也會越不敷使用，若沒有單元測試的保護，我們重構的成本會隨著產品的規模的提升而提升，而發展到一定規模的情況下，重構變成遙不可及的夢想。\n​\t也是因為有單元測試的保護，我們才可以真正的去設計我們的程式，常見的S.O.L.I.D，以及23種設計模式的使用，如何根據不同的情境套用不同的設計模式，這就是工程師有價值的地方，可以說單元測試的撰寫完整了整個物件導向的程式設計。\n","date":"2022-12-04T22:22:06+08:00","image":"https://i.imgur.com/2xteh3C.png","permalink":"https://hoxtonhsu.com/p/%E6%B7%BA%E8%AB%87%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC/","title":"淺談測試驅動開發"},{"content":"在Junit5中，有對一些Junit的測試的註解進行調整\n比如說\nJunit4 Junit5 測試用框架的選擇 @RunWith(MockitoJUnitRunner.class) @ExtendWith(MockitoExtension.class) 當測試會使用到SprintBoot框架時，應該要使用@ExtendWith(SpringExtension.class)，@MockBean來調用\n若測試不想涉及SprintBoot的時候@ExtendWith(MockitoExtension.class)，以及@Mock, @InjectMocks，並且使用MockMvcBuilders.standaloneSetup來設置獨立測試，以下是Code的示範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; /** * @author Hoxton on 2022/11/30 */ @ExtendWith(MockitoExtension.class) public class UserControllerTest { @Mock //Controller調用的Service UserService userService; @InjectMocks //要測試的Cotroller UserController userController; MockMvc mockMvc; //模擬Mvc @BeforeEach public void setMockMvc(){ MockMvcBuilders.standaloneSetup(userController).build(); } } ","date":"2022-11-30T13:30:27+08:00","image":"https://i.imgur.com/4qePz5L.png ","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E5%B0%87junit%E7%9A%84%E6%B8%AC%E8%A9%A6%E7%B2%92%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%9C%A8%E6%9C%80%E5%B0%8F%E5%96%AE%E5%85%83/","title":"如何將Junit的測試粒度控制在最小單元"},{"content":"最近業配公司，讓公司老闆買了IDEA讓我們後端工程師來使用，因此技術分享做了一次IDEA的主題，在這邊把技術分享的一些內容做成文章，分享一下\n推薦的Plugin Plugin名稱 截圖 One Dark Theme\n佈景主題 按鍵提示 Rainbow Brackets\n括弧顏色顯示 Nyan Progress Bar\n讀取條改變 WakaTime\n工作的紀錄 要改的設定 Code Completion\nAlt+.\nSecond Basic Alt+/\nType-Match-Completion\nAlt+;\nRun F10\n就Run Terminal Alt+`\n更改Terminal Bash CMD or Window terminal 更改TODO 模板\n實用的快捷鍵 功能 預覽 sout,souv\n快速印出 搜尋 Shift+shift 快速列出所有可能，快速定位 切換分頁\nCtrl+E 預設快捷鍵，會列出最近開啟的分頁 選擇檔案\nAlt+F1然後按1\n若不想選擇按Esc退回Editor 快速選取區塊\nCtrl+W 快速選取方法\nAlt+↑ 查看根源\nCtrl+B 快速定位錯誤\nF2 查看變數提示\nCtrl+P 修改\nShift+F6 內建GitBlame功能\n對行數右鍵選擇gitBlame 萬能鍵Context Action\n引入變數、錯誤修正\u0026hellip; ","date":"2022-11-10T23:52:33+08:00","image":"https://i.imgur.com/zyn4XVp.png","permalink":"https://hoxtonhsu.com/p/idea%E7%9A%84%E4%BB%8B%E7%B4%B9/","title":"IDEA的介紹"},{"content":"推薦的Plugin Plugin名稱 截圖 One Dark Theme\n佈景主題 按鍵提示 Rainbow Brackets\n括弧顏色顯示 Nyan Progress Bar\n讀取條改變 要改的設定 Code Completion Alt+.\nSecond Basic Alt+/\nRun F10\n就Run Terminal Alt+`\n更改Terminal Bash CMD or Window terminal 更改TODO 模板\n實用的快捷鍵 功能 預覽 搜尋 Shift+shift 快速列出所有可能，快速定位 切換分頁\nCtrl+E 預設快捷鍵，會列出最近開啟的分頁 選擇檔案\nAlt+F1然後按1\n若不想選擇按Esc退回Editor 快速選取區塊\nCtrl+W 快速選取方法\nAlt+↑ 內建GitBlame功能\n對行數右鍵選擇gitBlame ","date":"2022-10-23T20:40:49+08:00","image":"https://i.imgur.com/Fx9nanx.png","permalink":"https://hoxtonhsu.com/p/intellij%E8%88%87eclipse%E7%9A%84%E6%AF%94%E8%BC%83/","title":"IntelliJ與Eclipse的比較"},{"content":"最近在研究C++，但發現我的CLion不知道為什麼只能有一個Main方法，後來網路上查了一下之後發現好像是因為CMake的關係。\n錯誤訊息\n後來研究了一下，發現只要在Project底下的CMakeList.txt加上這段就可以了\n1 2 3 4 5 6 file (GLOB files *.cpp) foreach (file ${files}) string(REGEX REPLACE \u0026#34;.+/(.+)\\\\..*\u0026#34; \u0026#34;\\\\1\u0026#34; exe ${file}) add_executable (${exe} ${file}) message (\\ \\ \\ \\ --\\ src/${exe}.cpp\\ will\\ be\\ compiled\\ to\\ bin/${exe}) endforeach () 完整的圖片如上\n加入之後記得要Reload CMake Project\n","date":"2022-10-17T18:09:43+08:00","image":"https://i.imgur.com/aGwtINt.png","permalink":"https://hoxtonhsu.com/p/clion%E7%9A%84mutilmain/","title":"CLion的MutilMain"},{"content":"前言 一直以來都把GitHub當成自己的筆記本在用，上傳了很多筆記，但最近心血來潮想把這些東西整理起來。最原先的想法是上傳到Medium，但發現Medium居然不支援Markdown的語法，索性放棄，後來某天看到之前高中同學有在用github.io的方式寫blog，於是也稍微研究了一下，原先以為可能一兩天就處理好，但最後發現弄了也快一個禮拜，於是想把這些坑記錄下來。\n創建GitHub Repository submodule是什麼? 從Hugo上下載自己想要的主題(thmem) 如何在本機預覽Hugo頁面 如何新增文章 hugo的檔案結構介紹 如何配置自己想要的模板(config.toml) 關於baseURL的細節 如何自定義文章模板 如何將自己的網站上傳到GitHub上面 如何push上去 在其他台電腦要怎麼clone下來 如何建立留言功能 GitTalk 如何購買自己的DNS Google Domain ","date":"2022-10-08T12:04:44+08:00","image":"https://i.imgur.com/WSwohcu.png ","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E5%9C%A8github%E4%B8%8A%E6%9E%B6%E8%A8%AD%E9%9D%9C%E6%85%8B%E7%B6%B2%E9%A0%81%E5%AE%8C%E6%95%B4%E6%95%99%E5%AD%B8/","title":"如何使用Hugo在Github上架設靜態網頁完整教學"},{"content":"前言 蓋塔生兵\n用蓋塔生兵這個詞彙有點不太準確，比較正確的說法是自動產兵型遊戲，這種類型的地圖一開始會給你一塊地，然後這塊地會隨著時間自動產兵，比如說兩秒產一隻士兵這樣，並且能用殺敵獲得的黃金來升級自己的士兵，不論是單純的加血加甲，或是升級成更高單位的士兵，而這類遊戲最大的樂趣就在於取消了部隊上限，能夠像是全面戰爭那樣，操控50~100多隻的士兵上場殺敵，代表的遊戲類型有：城堡大戰、刺蛇大戰，前者是玩家們分成兩個陣營，有點類似現在的DOTA，有路線有野怪，也有系統自動產生的兵線。後者則是最原汁原味的玩法，有些地圖會是刺蛇或是小狗，看地圖而定。 這個類型的遊戲不算熱門，但是非常好消磨時間，單機的情形下最後造出一堆高階兵種，比如說寒霜翼龍或是狼騎兵輾壓戰場，看著所有士兵車過去的感覺特別爽。\n鬼抓人（吸血鬼復蘇、巨魔與精靈）\n用鬼抓人這個詞彙也不太準確，正確來說比較接近現在的非對稱式生存遊戲。遊戲的玩法是有數名玩家擔任農民，少數玩家扮成鬼，一開始農民先行動，在地圖上找尋合適的地點，開始建立城牆、防衛塔、瞭望塔之類的防禦型設施，防範鬼的入侵。而鬼的玩法則是進攻人類的住所，扛著防衛塔的傷害努力打破城牆，進去殺死人類。以上是比較基本的規則，但隨著遊戲的更新也會增加越來越多功能，比如說鬼也能遠距離攻擊，隔著城牆殺死農民，或是農民死掉後會變成鬼，增加玩家留存率，代表的遊戲有：鬼抓人、樹人與炎魔、巨魔與精靈，這三者都各有特色，但後兩者我忘記具體有什麼差別。這種類型的遊戲也出現過很多變體，比如說貓抓老鼠之類的，但已經是比較後期的事情了。 這應該是我第一次接觸到的魔獸爭霸小遊戲地圖吧，也是我認為最經典的，放到現在看也不過時，非對稱式的遊戲方式與生存、建造的融合，讓這類型的遊戲一直都有人在開發，有件有趣的事情是，當時我記得我可能小二小三吧，那時候在網咖裡面加進去一個房間，地圖就叫做性愛鬼抓人，結果進遊戲之後發現只要有人被抓，畫面就會變成無碼色情圖，然後還會有超大聲的淫叫聲，當時的我也不知道那到底是什麼，玩了一下之後就跳出去了。\n金字塔大逃亡\n個人不知道這是不是台灣人做的地圖，但是應該算是目前還會被提到的魔獸小遊戲吧，知名實況主紹安就是在實況上玩這款遊戲的魔改版《性愛金字塔》，而被圖奇永Ban，從 此之後只要有實況主被ban臺就會被稱作「進金字塔」。 金字塔大逃亡本身是一個小遊戲總集，遊戲的主線就是玩家進場後可以從約30幾種小遊戲裡面選擇約8~10種小遊戲，全部完成後就可以通關這個金字塔。而這些小遊戲包刮但不限於 殺敵生存-玩家們重生在一個小競技場裡，會有各個波次的敵人依序產生，目標就 是活到最後。 機智問答-有點像是視力測驗的小遊戲，畫面上會有各種不同顏色的怪物數隻，隨機地走動 ，當時間結束後，會問你說「請問橘色的食屍鬼有幾隻?」「藍色的鬼魂有幾隻?」。 計步遊戲-一開始玩家會出現在一個類似棋盤的地圖上，接著會有一位系統npc在棋盤式的地圖上位移，而玩家的目標就是記住它是怎麼走的，必須要讓自己的步伐和npc吻合，不然就輸了 這遊戲我玩了很多次，但沒有一次有過關的。\n跳跳球\n「手殘復健專用」。遊戲的視角從魔獸的3D視角變成垂直90度的視角，畫面上看起來就是一款2D遊戲，實際遊玩方式很接近現在的CELESTE，都是在2D的地圖上用跳躍、蹬牆跳 之類的方式到達指定的地點。 雖然說這遊戲的玩法看起來不是特別有創意，但它是一款多人類型的地圖，遊戲裡面死掉後除了等全滅之後的復活外，還可以讓隊友碰觸到你的屍體來復活，我覺得這一點是很有創意的一點，但不知道為什麼沒看到有遊戲發行商做過類似的獨立小品。跳跳球的難體現在三點上，1.遊戲後期會有那種只要沒跳掉，就不會再出現的平台，除非等到所有人重生。2.遊戲會隨著時間，操作越來越延遲。3.手殘\n大屌大戰\n這款我很確定是臺灣玩家的地圖，因為從隊伍選擇裡面就可以看出作者的惡趣味， 藍方「來自東方的大屌」紅方「來自西方的洋屌」。而遊戲方式則是所有人重生在一個 開闊的鬥技場，對戰方式則是以指向技的方式丟擲槌子（遊戲裡叫大屌），如果累積足夠的經驗還可以放大招，丟出一個更巨大的槌子（遊戲裡叫笑傲飛屌）。遊戲裡面也可以購買各種不同的技能，比如說跳斬、大絕之類的，也有現在流行的「配件改變技能」系統，可以購買各種道具，讓自己的大屌解鎖不同的功能，比如說爆炸屌、時空屌、激流屌之類的技能。時不時出現在場上的隨機效果也會令人會心一笑，比如說中樂透（獲得大筆金錢）、動物園動物逃竄（地圖上出現許多動物經過，會有傷害）或是撿到鋼彈（遊戲裡面會有一台鋼彈讓你操作），我覺得最好笑的應該就是固樂沙敏，這個效果觸發後，會有一名玩家跑速變快，而背景音樂也會改成固樂沙敏的廣告「ㄎㄨˊ落，爬起來」。 當初在高中的時候邀身邊的同學一起玩，討論的內容都是「今天要不要玩大屌大戰」「我的屌超準」「我才不要玩，每次都被你的大屌噴死」之類的對話，不知道當時身邊的女同學都在想些什麼呢。\n神奇寶貝防衛戰\n這應該這幾年大家最熟悉的遊戲，Dota自走棋、LoL自走棋、爐石戰場之類的遊戲，都 是源自這款遊戲(應該啦，我也不確定)，遊戲方式就是從許多神奇寶貝裡面選出幾種，然後它們就會自動打怪，我們要做的事情就是升級神奇寶貝、選擇神奇寶貝而已，遊戲裡面的許多神奇寶貝都有獨立建模，印象最深的大概就是鯉魚王吧，因為它每個階段後面都是鯉魚王LV0(警告，這個單位很廢)鯉魚王LV30(警告，這個單位仍然很廢)，直到將它升級成暴鯉龍之後才不會顯示後面的詞綴，強度也是正常的。 神奇寶貝防衛戰當時還很簡陋，大概就像我上面介紹的那樣子，並且在加入一些屬性相剋的系統，後代的一些遊戲比如說爐石會有搭配系統，而神奇寶貝防衛戰就我所知應該是沒有的，使得遊戲一開始很新鮮，但玩久之後就缺乏深度，但是真的很好玩，我記得當初我有個朋友看到名稱叫做「神奇寶貝防衛戰」還萬般排斥，但玩了之後卻直喊真香。\n越獄\n這個遊戲其實算是鬼抓人的變體，但它改了太多的東西。遊戲方式是分成警察組 （兩人）與小偷組（八人），在一個城鎮裡面警察抓小偷，警察一開始擁有遠高小偷的火力，而小偷則是要在整個城市中逃竄，努力壯大自己，比如說去遠方的島嶼學習仙人術，或是進到城鎮底層變成血高傷痛的狂人最後攻進警察總部裡面殺死警察。遊戲裡面的地圖真的做的很棒，公園區、銀行區、森林區、市集區，比較常見的開局就是所有人進場分成搶劫組與修練組，搶劫組一開場就先去搶銀行，然後把金錢分給修練組的玩家，修練組的玩家在趕緊花錢購買裝備、拜師學藝，後面在反殺警察。而我最常的玩法就是偷偷地躲進森林區，利用物件把自己卡進森林裡面，在裡面蓋一個小型市集，當仲介商，負責造錢給其他玩家或是幫忙買東西。\n水之TD、守城遊戲 TD遊戲自從魔獸三沒落後，好長一段時間都沒有什麼類似的遊戲，雖然市場上陸陸續續都有在更新類似的遊戲，但總給人不溫不火的感覺。但在當時，TD類型的遊戲可謂是魔獸的大宗，舉凡元素TD、守望女神TD、害人守塔之類的TD遊戲佔據了小遊戲圖的半邊天。這類型的遊戲就是在固定的路線上製作防禦設施，目標就是在敵軍抵達終點前消滅它們。 而其中我最喜歡的TD守城就是水之TD，單純就只是這款特別簡單而已，而且操作也不複雜，而有其中一小關，我不確定是不是第64關，敵方是一群坦克，每次玩到這關的時候我都會在語音裡面大喊天安門事件。 守城遊戲則是占據了魔獸小遊戲圖的另外半邊天，這種遊戲類型會讓玩家扮演一名英雄，可能是魔獸爭霸裡面的，或者是某些動漫作品裡面，接著敵方會依照波次派遣軍隊過來攻擊我們的主堡，而我們的目標就是守住，地圖上會有商店、野怪、練功區之類的地方，讓玩家可以快速升級刷錢代表類型有：火影忍者的羈絆、神之墓地、守護女神之類的。 說起來好笑，這類型遊戲我覺得最大的樂趣就是無腦，遊戲裡面的角色初期大概就可以學一堆技能，舉凡分身術、劍刃風暴、大玉螺旋丸之類的大範圍高傷害技能，且攻速都快的離譜，每隻角色看起來都像本多開大一樣，所以常常看到自己的角色在練功場刷怪，只要怪一重生就立刻被秒掉，頗有現在免洗手遊的味道在裡面。\n術士大戰\n​ 這應該是這個表單裡面最冷門的一款吧，因為這款出的時候差不多2012，當時GGC的魔 獸房已經不用黃金會員就能擠進去了，玩魔獸的人銳減，使得這款遊戲並沒有獲得太多人的注意。遊戲玩法講簡單一點就是推人出去，地圖會越來越小，只要被推出去就會扣血，而玩家可以用許多技能讓攻擊對手，比如說火球術，被丟中就會後退，或是滾石術，擲出一個巨大的滾石，被擊中後就會被滾石的模組推著往外滾，也有一些技能比如說鎖鏈，可以勾住敵人並且扣血，或是勾住場上的物件讓自己勾回場上，而我發明的一種方式就是用滾石術配上鎖鏈，這樣子敵人一方面被滾石往外推，另一方面又被鎖鏈牽扯住受到持續傷害，四字「高手境界」。 而遊戲裡面還有更多更多的技能與道具可以使用，只可惜玩的人並不多而已。\n侏儸紀公園\n這張地圖也是我之所以想寫這篇文章的原因，這張圖我認為是小遊戲之王也不為過。遊戲方式是一群人降落在一個叢林裡，然後找尋一個適合自己的地方，築起電網、電牆，蓋起機槍哨塔之類的防禦設施，然後發展各種學院，比如說物理學院、機械學院、生物學院之類的，升級成激光哨塔、火箭炮塔、核子電牆之類的，甚至還能養恐龍，或是學習武術技巧與成年雷克斯暴龍PK。我會覺得這張地圖很好玩的原因，是因為這不像是鬼抓人那種類型遊戲，會給妳很多看起來就很適合蓋的地點，在侏儸紀公園裡面，很多時候你蓋的地方可能只有幾棵樹木當成天然屏障，很容易就會有小恐龍穿進縫隙進到你的家園，或是大型恐龍倒地後會使得樹木倒塌，門戶洞開。且遊戲裡面的氛圍營造的很好，大型恐龍在附近的時候會聽到許多恐龍的低吼聲，靠近的時候整個畫面會震動，我記得我小時候玩的時候覺得超恐怖的。而遊戲發展到後期，救援直升機就會抵達叢林，這時候我們就需要用我們之前研究的科技，比如說車輛或是機械部隊，殺出一條血路，搭上直昇機逃離這個侏儸紀公園。 綜合來說，侏儸紀公園是一張結合了生存、發展、營造、合作、探索的超強遊戲，簡陋的畫面仍然無法遮掩它極佳的遊戲性，缺點也是有的，首先成長期實在太久，雖然遊戲的時間可以選擇要30、60還是90分鐘，但過低的遊戲時數基本上沒辦法撐過最後一波的恐龍大進攻，使得玩家通常都是選擇60分鐘為一局，且遊戲裡面的物理學院實在太強，各種高科技設施和防禦工程，使得其他學院的技術就有點娛樂性質，但整體來說絕對是魔獸爭霸小遊戲的王者當之無愧。\n東京甩狗\n​ 太多人說要加東京甩狗了，趁有空的時候打一打。東京甩狗這遊戲有點複雜，其實很像團康遊戲的氣球爆在誰手上。地圖是一個空曠的場地，約有八名玩家，會有其中一名玩家持有球，而地圖上會有一隻「狗」去抓拿球的人，被追到就死了。 而這遊戲叫做東京甩狗的原因就是因為狗的運動方式不是直線，而是有點像甩尾一樣的方式靠近持球者，持球者「甩狗」的時間越久，則接下來把球丟給下一個人的時候，狗的速度就會變超快的衝向下一個人，而且背景也會有龜派氣功的集氣聲，配合上背景音樂的Linkin park -faint ，讓場面充滿緊張刺激的氣氛！\n後語： 這十大遊戲是我心目中的排名，不一定符合大多數人的看法 大概兩年前自走棋剛出來暴紅的時候讓我蠻震驚的，因為我好像十幾年前就玩過類 似的遊戲，當時就覺得怎麼一群人還在玩我小時候玩的遊戲還不亦樂乎？後來回顧了一下許多魔獸爭霸的小遊戲，其實都頗具潛力，比如說跳跳球就可以做成像Fall guys的同樂遊戲，越獄改一改其實也是另一種型態的非對稱競技、蓋塔生兵其實也可以做成像是全戰那種類型的RTS、侏儸紀公園如果用現在的技術重製的話應該也能掀起一波恐龍生存熱潮? 全部看完下來其實還有很多遊戲想要列上去，比如說臺灣人自己開發的EoU(End of Upotia)，也算大作，只可惜最後沒在更新，當時我還有記下我的登入碼。還有各種動漫人物大亂鬥、藍綠大戰、小兵的故事、卡牌大戰、勾肥大戰、亡者之夜、狼與羊、還有最白癡的誰是智障、強者大戰、海綿寶寶溜冰、歐洲大戰、坦克大戰、東京甩狗、神鬼戰士、你畫我猜、達爾文進化島、船難求生、森林大逃亡之類的，每款遊戲放到現在都是遊戲性很高的作品，當初淬鍊重生出來時，我以為會再掀起一波魔獸熱潮，結果淬鍊重生整個大爆死，最後不了了知。 想來寫一下這篇文章，原本是預計做成影片的形式的，但無奈很多地圖我都 已經找不到載點，BattleNet上面也都沒有活人、GGC老早也把連機房停掉了，現在要連的話好像也只能透過中國的平台連，無奈我有點懶得去理解要怎麼註冊，也怕註冊後根本沒人玩這些小遊戲，後來前陣子PTT開放註冊，就決定還是用寫文章的方式紀念一下這個陪伴 我國高中生活的遊戲。\n","date":"2022-10-08T03:13:34+08:00","image":"https://i.imgur.com/RALUdJZ.png ","permalink":"https://hoxtonhsu.com/p/%E5%8D%81%E5%A4%A7%E7%B6%93%E5%85%B8%E9%AD%94%E7%8D%B8%E5%B0%8F%E9%81%8A%E6%88%B2%E5%9C%B0%E5%9C%96/","title":"十大經典魔獸小遊戲地圖"},{"content":"無雷心得： 2013年的作品了，最近特價才把它買回來玩，如果要講無雷心得的話，我會建議遊戲直接開最低難度就好，然後留聲機(遊戲裡面的文本訊息)多收集，沒有字幕，但是點進去會有逐字稿，強烈建議看一下，不要像我一樣什麼都沒看，會有蠻多地方不太清楚的，無雷心得我就講到這邊，因為這遊戲的劇情只要稍微提一下就會有暴雷的成分，遊戲時長約為10小時，算是很短了，推薦嗎？推薦，因為超多人都說劇情很神，300元當作看一場電影也不虧，適合你周末時買來玩。\n有雷心得： ​\t其實原本是想打魂類遊戲心得的，但寫一寫發現怎麼寫都不喜歡，就決定來寫生化奇兵無限的心得，我劇情放在最後講，先講遊戲性的部分。 生化奇兵的遊戲性如果要我給個分數的話，我應該會給40~50分吧，不及格的原因是因爲我在玩的時候沒有一瞬間是覺得戰鬥是有趣的，會覺得不好玩的原因有以下幾點\n遊戲能攜帶的槍枝種類只有兩種\n雖然說大部分的FPS遊戲，能攜帶兩種槍枝算是基本設定，但由於我全程都是以最高難度的過程中，把子彈打空是家常便飯的事情，但遊戲裡面的特殊單位，比如說機甲華盛頓、大猩猩機器人等等，沒什麼難的，就只是血特別多，雖然說機甲華盛頓背後好像有啥弱點可以打的，但敵方目標全程都是鎖定在玩家身上，能繞背的場景真的太少，有時候打一打就沒子彈了，就必須得全場一直撿子彈，但這遊戲也沒有現在遊戲常見的滑鏟或是奔跑等要素，總是會覺得移動起來不夠俐落，很容易就變成靶子被敵人亂槍掃射，這也是為什麼 我會建議遊戲用簡單模式玩就好，痛苦太多，收穫太少，能簡單大家都不想複雜。\n遊戲的魔法都沒啥用\n我不確定這是不是我個人的感覺，但我感覺這遊戲的魔法有用的真的沒幾個，我最常用的應該就是把敵人吹起來的，還有把敵人吹走的，剩下什麼控制心靈、火球術之類的，在魔力條有限的情形下，不如控場住對面然後瞄頭射擊來的更有效率，魔法這個系統，以我自己的觀點來看，雖然沒有到「刪了也沒差」的程度，但確實沒有給我帶來太多顯著性的幫助，我期望的魔法，雖不像Dishonored那樣無所不行，但至少應該也要做到像隻狼的忍具那樣，不用不會怎樣，但用了會很不一樣，有看過人家抱怨，說是這代把魔法系統閹割掉太多，前幾代魔法很有用之類的。\n遊戲的敵方設計不夠有趣\n我破完這遊戲大概快兩個月了，我憑印象想到的敵人，就是普通士兵、機甲華盛頓、猩猩機器人，這三個的差別就是，會開槍；會開槍然後血很厚；會開槍然後血很厚還會衝過來扁你，其實差別並不大，所以我在玩高難度的時候腦袋基本上是放空狀態的，我不太需要知道我眼前的敵人有什麼弱點，或是要怎麼應對，我需要的就是不停開槍而已，講白話一點就是，我在打我的，敵人在打他的，我跟敵人沒有什麼太多互動的機會，我會希望我跟敵人之間更有互動，比如說可以打掉華盛頓的手臂，它的槍砲會掉落，然後會轉身去撿，我可以順便射背後，諸如此類的設計，讓戰鬥過程有點動腦的感覺。\n另外我常常在心得裡面看到有人說，伊莉莎白是他所見過，最栩栩如生的同伴，說她不止會丟補丟槍丟丟銅仔，還會針對場景中的物品互動。有可能是因為我玩的是最高難度，因此伊莉莎白大部分對我的幫助都還好，沒有真正意義上的幫助到我，更多時候她就開場丟了一個補之後就躲在掩體後面，然後掛機看我輸出。我會更希望伊莉莎白能做一些更積極性的行為，讓我感覺到她有在跟我冒險的感覺，說白了一點就是希望她可以像龍族教義的pawn一樣，能輸出能壓制能開戰，或者是像COD一樣會跟著玩家一起站在前線，我「個人」會更喜歡伊莉莎白一點，當然也許伊莉莎白不敢弄髒自己的雙手，只敢把子彈丟給布克叫他開槍，降低自己的罪惡感。\n最後要講的是劇情，我就先講了，我不太滿意，這原因可能有兩個，一個是因為我懶，遊戲裡面，不能說有大量的，但確實是有一定數量的留聲機散落在地圖各處，這些留聲機有的重要，有的又不太重要，在播放的時候也沒中文字幕，只能點進去留聲機裡面才能看到 歷史文本，我「個人」，再次強調我「個人」不太喜歡這種把劇情放進收集要素裡面的系統，因為這種系統一來是很麻煩，沒有提示我又要去找，又可能是反過來，我根本不知道有這個留聲機的存在，變成我每次撿到的留聲機都是隨緣的，他們可能是對於某個歷史事件、或是某個人物的介紹，但因為我漏掉了某個留聲機，我就不能知道這件事情、這個人到底從頭到尾發生了什麼事，比如說遊戲裡面的兄妹的背景故事有很大一部分就是藏在留聲機裡面，也是留聲機揭露出了他們不是兄妹，而是兩個平行時空的同一個人，只是性別不同罷了。\n有些人可能會很喜歡這種自己收集物品來拼湊故事的敘事方式，但我真的很抱歉我不是那麼優秀的人類，我會更希望隨著劇情，他會把那些文本直接丟給我。\n接下來要講結局，誠如我上面說的，我對於劇情，其實應該是說結局不太滿意，我會講一下我認為的好結局（魔女之家以及我個人認為的伏筆應該要怎麼樣會比較好（屍人莊殺人事件），如果有人沒有玩過魔女之家、沒有看過屍人莊殺人事件的朋友也可以先迴避一下。\n平心而論，生化奇兵３的前面鋪成是很好的，至少它解釋了伊莉莎白的能力起源，以及布克夢中的神祕敲門客時，我確實是有感覺到一點東西的，然後當最後伊莉莎白的限制器被解除，剎那間她超脫世界上所有一切，僅用轉瞬之間就洞悉了宇宙的光陰，過去發生的 ，現在存在的，未來注定的一切，全知全能的伊莉莎白。她帶著布克走進了燈塔，然後燈塔裡有更多的布克與伊莉莎白交錯來回走在不同的燈塔裡，「所有的一切都在不停地發生，但每次都會有些許不同」，伊莉莎白帶著布克回顧了故事開始的源頭．．．當布克了解一切後，要求伊莉莎白讓他殺死康斯姆托克，終結這一切，伊莉莎白眼裡閃過一絲猶豫，但最後還是打開了一扇新的大門，回到布克接受洗禮的那一天，布克不解，轉過身後發現有無數個伊莉莎白站在背後「所有的一切都在不停地發生，但每次都有些許的不同，現在的你，當時拒絕了洗禮，選擇背負自己的罪生活下去。但另一個時空的你，選擇忘記這一切，以康斯姆托克之名重生」，接著伊莉莎白們抓住了布克，在初始洗禮池之處淹死了布克，接著就結局。\n我會不滿這個結局的原因是因為，這個結局太快了，幾乎是在講完布克就是康斯姆托克，如果能帶一些畫面，說明康斯姆托克就是布克的一些伏筆會更好。比如說魔女之家的真結局，雖然不是100%相似，但都是在結局最後有一個大爆點，而這個大爆點可以貫穿整個遊戲，解釋所有的一切，當薇奧拉轉頭踢了魔女一腳，並說出「你煩不煩阿，這副身體已 經是我的了」的瞬間，在配合上後面的對白「雖然換了身體，但這棟房子還是知道誰才是真正的主人」，剎那間玩家就會回憶起所有在房子裡看見的「身體轉移祕法」「毒啞人的方法」到底是做什麼用的。但生化奇兵3的結局我並沒有這樣的感覺，遊戲過程中，我感覺不太到康斯姆托克與布克的關聯性在哪裡，他們語氣不同，外貌也不相似，也沒有一些共有的小習慣之類的，換言之，康斯姆托克跟布克的關聯性根本不高，這也有可能是因為遊戲中時不時在暗示你康斯姆托克不僅僅是康斯姆托克，比如說他預言了偽牧羊人、知道伊莉莎白的指頭，使得玩家很容易對他的背景有些預設立場，就有點像是看魔術時，大家的焦點都會注意在那杯被魔術師蓋起來的杯子一樣。我認為的一個好的伏筆，是屍人庄殺人事件，在故事的開頭主角戲水時把身上帶著的懷錶放在涼亭處，並要同學看好它，這件事情就只是一個很日常的描寫而已，但在故事的最後，在抓殺人嫌犯時，大家的報時都是1點32分、2點57分這樣精準的時間時，只有男主是說1點半左右，原因無它，因為旅館房間的時鐘都是電子式的，而當時男主根本不在房間裡，只能透過指針式的懷表查看時間，才會說出1點半這個模糊的答案。\n以上的內容濃縮起來就是，康斯姆托克的身份的伏筆不太好，結局也太快進結局，沒有適當的鋪陳告訴玩家為什麼康斯姆托克要是，且必須是布克。\n回顧整個遊戲，其實最讓我覺得很棒的伏筆是遊戲一開始進入哥倫比亞時，兄妹倆人 會要你猜人頭還是字，當你做出選擇後，哥哥會拿出一個早已畫上許多記號的記分板再加上新的一筆，但當你破完後再回頭看這段，會發現那些計分板上的痕跡，就是許多平行世界的布克都曾經猜過硬幣，都曾經在這計分板上畫上過一筆。 最後講一下結論，心得這種東西因人而異，我講的也只是我的看法而已，大家生長環境的解讀有出入是很正常的事情，我知道很多人都說生化奇兵3的劇情很神之類的，但我玩過之後真的覺得還好，我盡量把我覺得不滿意的地方寫出來，讓大家知道我不滿意的地方 在哪裡，僅代表個人意見而已。很多人覺得很爛的FF15我卻覺得結局很不錯，大家狂推的槍彈辯駁2我也覺得真的很神，綜上所述，如果還是有人對我有意見的話，我只想說「很抱歉，我就是爛，玩魔物獵人、惡魔獵人這種不用動腦的遊戲就好，不應該玩這種劇情遊戲」\n","date":"2022-10-08T03:02:43+08:00","image":"https://i.imgur.com/h13vjaO.png","permalink":"https://hoxtonhsu.com/p/bioshock3%E5%BF%83%E5%BE%97/","title":"Bioshock3心得"},{"content":"Operating-System 洪毅作業系統筆記區 Chapter1 Intruduction 管理硬體的軟體就是作業系統，硬體包含CPU，Memory，I/O設備等等…作業系統就是負責管理這些硬體的系統。一個電腦系統可以被粗略的劃分成下面四個組件：\n硬體(hardware) 作業系統(operating system) 應用程式(application programs) 使用者(user) Hardware 包括CPU(Central Processing Unit)，記憶體(Memory)，Input/output設備…提供給系統基本的計算資源\nOperating System 負責協調硬體與應用程式，給不同的使用者\nApplication Programs 例如Word，Excel，Chrome之類的應用程式，來處理使用者的計算問題(Computing Problems)\n補充：\nBare Machine(裸機): 純粹只有硬體組成，沒有OS及System Programs Extended Machine: Bare Machine加上OS/system programs In Memory Command Interpreter(命令解譯器) Multiprogramming System 定義：系統允許多個Jobs(Process)同時執行，即是Multiprogramming 主要目的：提高CPU Utilization 作法：透過Job Scheduling or CPU Scheduling技術達成 example：當執行中的process waiting for I/O completed, 則OS可將CPU切換給另一個process執行，避免CPU idle 。\n即只要系統內有夠多的工作存在，則CPU IDLE的機會就下降\nMulitiprogramming Degree之定義 系統內的Process的數目：一般而言，Degree越高，CPU利用率就越高。 (Note：Virtual Memory Thrashing狀況除外)\n多個Process的定義、以及如何執行\nConcurrent execution(並行)：一顆CPU，大家一起輪番使用 Parallel execution(平行)：多顆CPU或是Multi-core(多核)，各自執行 Time-Sharing System 分時系統\n定義：又叫Multitasking[恐龍本如是說]\nIt\u0026rsquo;s a logical extension of Multiprogeamming system\n與Multiprogramming的最大差異：CPU的切換頻率極高\nTime-Sharing System features\n強調對User Response的時間要短(\u0026lt;1秒) 適用於user interactive的Computing/ Environment 對每一個process都公平 Main Frame(主機)\nCPU Scheduling採取RR的排班法則(第四章會介紹) 使用Virtual Memory的技術，擴展Logical Memory Space 使用Spooling的技術(不太會考)實現I/O Device的共用，類似現代的Buffering技術，讓每個user，皆以為自己有專屬的的Computer Multiprocessors System 定義：又叫Multiprocessing or Paraller or Tightly-coupled system(緊密耦合系統)\nfaeture：\n一個機器(or MotherBoard)內，有多個Processors(or CPUs) 這些CPUs彼此共享此機器的Memory,Bus,I/O-Device, power-supplier etc\u0026hellip; 通常受同一Clock之時脈控制 由同一個OS管理 processors之間的溝通大都採shared Memory方式 Benefits(好處)：\nIncreased Throughput：產能增加 Increased Reliability：可靠度的提升 Economy Of Scale：運算能力的擴充比較好 分析如下：\nIncreased Throughput：\n可支持多個工作在不同CPU上平行執行(paraller Computing)，注意，N顆CPU之產能絕對小於1顆CPU產能xN倍，意即CPU數量的提升與產能的提升並非線性成長。原因是因為\nResource Contetion(資源的競爭) Processors間的Communication會抵消產能 Increased Reliability:\n某一顆CPU壞了，則System不會因此而停頓，因為其他CPU仍可運作\nGraceful degradation(漸進式的滅亡) System不至因為某些Hardward/Software之元件故障而停頓，仍然保有持續運作的能力，這性質就稱為fail-soft Fault-Tolerant system(容錯系統)考試不太會考\n具有graceful degradation性質之系統就叫做Fault-Tolerant system，想要達成容錯的技術需要有兩件事情的支援 要有backup的系統，切換也要流暢 Economy of Scale:\n運算能力擴充符合經濟效益\n∵N顆CPU在一部機器內，與N部機器相比，成本較便宜∵這些CPUs共享同一機器之Memory, Bus, I/O-Device, etc Two SubType in Multiprocessors System SMP(Symmetric MultiProcessors) 對稱的 ASMP(Asymmetric MultiProcessors) 非對稱的 SMP\n定義：每個Processor的工作能力是相同的(Identical)，且每個CPU都有對等、平等的權利來存取資源\n優點：\n可靠度較ASMP高，因工作能力相同，即使其中一個cpu掛了也可以被立刻取代 效能較高 缺點：\nSMP的OS設計開發較為複雜(互斥存取的機制設計,資源的競爭) ASMP\n定義：每個Processor之工作能力不盡相同，通常是採取Master-Slave的架構(恐龍本有時候會寫成Boss-Employee\nMaster-Processor負責工作分派及資源分配，監督Slaves等管理工作\nSlave Processors負責執行工作\n優點：ASMP的OS設計開發較為Simple，∵與Simple-Cpu Os版類似\n缺點：\n可靠度低，Master CPU如果壞了，就會停擺，直到另一顆CPU被Train接手 效能較低∵Master CPU是瓶頸 Multiprocessors System VS MultiCores CPU 從作業系統來看差異不大，主要差異是硬體的差異(主要)，以OS來看，你裝了一顆兩核的CPU，OS會視作兩顆CPU；裝四核的視作四顆CPU\nMultiProcessors MultiCores CPU 優點\nPower Saving：相較MultiProcessor，在一個CPU上提供兩個Core的能源耗損會比在一張板子上提供兩顆CPU的能源耗損還來得低。 Speed比較快(∵處在同一個晶片內資料傳輸速度較快) Distribute System 定義：又叫Loosely-Coupled system(鬆散耦合系統)，主要的Feature如下\n多部機器彼此透過Network(or Bus)相互串連\n每部機器之CPU有各自私有的Memory, Bus, I/O-Device, etc 並非共享\n各CPU之Clock時脈控制不一定相同\n各CPU上之OS也不一定相同\n各Processors之間的溝通大都採**\u0026ldquo;Message Passing\u0026rdquo;**方式\nMessage Passing (類似講電話)\nStep\n建立Communication Link Message 相互傳輸 釋放Link Advantage of Distribute-System Increased Throughput(支持Paraller Computing) Increased Reliability(一個掛掉，還有其他可以擋) Resource Sharing(資源共享因此成本降低) 支持\u0026quot;Client-Server\u0026quot; Computing Model之實施\nServer(伺服器)：提供某些服務的機器 example: mail server, file server ,DNS,printer server, computing server \u0026hellip; Client：本身不提供服務，且它需要某些服務時，則發請求至Server, Server服務完再將結果回傳Client Note\nPeer-to-Peer model：peer意指同時具有server及Client的角色，英文意思是同等的、對等的\nRemote sites Communication的需求被滿足 example：email, FTP via Internet Real-Time System (即時系統)\n分成兩種\nHard real-time System Soft real-time System Hard real-time system 定義：This system must ensure the critical tasks complete on time，即工作必須在規定的時間限制內完成，否則即算失敗\n舉例：軍事防衛系統、核能安控系統、工廠自動化生產\u0026hellip;\n設計考量：\n所有時間延遲之因素皆須納入考量 eg：sensor data 傳輸速度、運算速度、Signal的傳輸 etc，確保這些時間的加總能夠滿足時間deadline的要求 所有會造成處理時間過久或無法預測之設備或機制，盡量少採用或不用 eg：Disk不用或少用、Virtual Memory 絕對不採用 就CPU Scheduling設計(Ch4)而言，需先考量Schedulable與否，再進行排程(eg rate-monotonic, EDF scheduling)，確定CPU能負荷再進行排程 Time Sharing system 無法與之並存(Time sharing是屬於Multitasking，可以同時執行多個程序，並透過一些風勢去優先執行某些程序，而Hard real-time比較像單運算系統，要求在指定時間內完成，因此更專注於單一程序的執行，由於這兩個系統有這樣的差異，因此無法共榮) OS所造成的Dispatch latency etc. 宜降低(interrupt的處理, system call的請求)，一般實務上，hard-real-time system，鮮少有OS的存在(幾乎不存在)，尤其是embedded real-time system，因需要及時的響應 現行的商用OS不支援Hard real-time features 通常都是客製化的特殊設計eg : Linux, Unix, Window, Apple Os, Solaris etc ​\nSoft real-time system 定義：This system must ensure the real-time process get the hightest priority than the others and retain(維持) this priority level unit it completed\n舉例：Multimedia System, Simulation system, VR system, etc\n設計考量：\n就 CPU Scheduling 設計(ch4)而言， 必須支持preemptive priority scheduling 不可提供Aging技術(活得越久，priority越高) 盡量降低kernel的Dispatch latency time 可支援virtual memory 並存，但前提是real-time-process的全部pages必須皆待在memory中，直到完工，高優先權的Process不要使用virtual memory 與Time-sharing system 可以並存，eg：solaris 一般商用OS都支援Soft-real-time system Batch System 定義：將一些較不緊急，定期性、非交談互動性的Job，累積成堆，再分批次，送入系統處理\n舉例：庫存系統、報稅系統、掃毒、磁碟重組、清算系統\u0026hellip;\n主要目的：提高resource utilization，尤其是在冷門時段，不適合用在real-time-system, user-interactive application eg：電腦遊戲\nHand Held system 定義：單手可掌握操作的系統\nHardware 天生之限制，帶來software必須配合之處 Hardware天生限制 Software必須配合之設計 Slower processor\n(背後之限制)\n1. power 供應的問題，電供不足\n2. 散熱系統的設計 運算不能太複雜，要簡單 Memory空間有限 程式的Size要小，不用的記憶體要立刻釋放 DisplayMonitor很小 顯示的內容要有所刪減 Chapter2 Computer System Architecture I/O Operating And Hardware Resources Protection 學習路線 I/O運作方式\nPolling I/O\nInterrupted I/O\nDMA\nInterrupt機制處理與種類\nHW Resource Protection\n基礎建設\nDual Model Operation\nPrivileged Instruction\nI/O\nMemory Protection\nCPU\nI/O Operating Polling I/O I/O Polling(輪巡,詢問式) I/O\n定義：又叫Busy_waiting I/O or Programmed I/O\n步驟如下\nI/O Request 給 OS (執行中的Process不會自己做I/O) OS收到請求後，(可能)會暫停此Process執行，並執行對應的System Calls. Kernel 的 I/O-subsystem(專門用來處理I/O的請求，只是個過水而已)會Pass此請求給Device driver Divice Driver 依此請求，設定對應的I/O Commands參數給Device Controller Device Controller 啟動監督I/O-Device之I/O運作進行 在這段時間內，OS(可能)將CPU切給另一個process執行 然而，沒人主動去告訴CPU I/O的執行狀況，因此CPU在執行process工作過程中，卻要不斷去Polling Device Controller，已確定I/O運作是否完成或有I/O error 缺點：\nCPU耗費大量時間用於polling I/O Device Controller上，並未全用於process execute上，故CPU utilization低、throughput不高 Interrupted I/O Interrupted (中斷,中斷式)I/O I/O\n定義：\n步驟如下：\nI/O Request 給 OS (執行中的Process不會自己做I/O)\nOS收到請求後，(可能)會暫停此Process執行，並執行對應的System Calls.\nKernel 的 I/O-subsystem(專門用來處理I/O的請求，只是個過水而已)會Pass此請求給Device driver\nDivice Driver 依此請求，設定對應的I/O Commands參數給Device Controller\nDevice Controller 啟動監督I/O-Device之I/O運作進行\n在這段時間內，OS(可能)將CPU切給另一個process執行\n當I/O運作完成，Device Controller 會發出 I/O-Completed Interrupt 通知OS(CPU)\nOS收到中斷後(可能)會暫停目前Process的執行(因有些Interrupt優先權可能很低，可以先暫時不處理)\nOS必須查詢 Interrupt Vector，確認何種中斷發生，同時也要找到該中斷的服務處理程式(ISR：Interrupt Service Routine)的位址(每一個中斷都有一個對應的中斷處理服務程式\nJump to ISR位址 執行ISR\nISR完成後，return control to kernel，kernel也許做一些通知工作\n恢復(resume)原先中斷前的工作執行或交由CPU Scheduler決定\n優點：CPU不須耗費時間用於Polling I/O-Device，而是可以用於Process execute上，CPU utilization提升，throughout提高，improve the system performance\n缺點：\nInterrupt之處理仍需耗費CPU time，如果 I/O運作時間 小於 Interrupt處理時間，則使用Interrupt I/O就不划算，不如使用polling I/O 若中斷的頻率過高，則大量的中斷處理會占用幾乎全部的CPU Time，則系統效能會很差 CPU仍需耗費一些時間用於監督I/O-Divice與Memory之間的Data Transfer過程 DMA (Direct Memory Access) I/O 定義：DMA Controller 負責 I/O-Device(設備)與Memory 之間的Data transfer(傳輸)工作，過程中不需CPU之參與監督，因此CPU有更多時間用於Process execute上 優點：\nCPU Utilization更高 適合用在Block-Transfer oriented I/O-Device上(代表中斷發生的頻率不致於過高 eg:Disk, 磁碟的控制器會和DMA的控制器兩個會相互合作，磁碟控制器會去指揮磁碟的運作，讀出來的資料會通知DMA的控制器，DMA會把資料輸進Memory裡) 不是用於Byte-transger oriented I/O-Device 缺點：\n引進DMA Controller會增加HW設計複雜度(Complicated the HW design) 原因：DMA的Controller會跟CPU競爭爭奪Memory(記憶體)、Bus(匯流排)的使用權，若DMC Controller 占用了memory , Bus 時，CPU要被迫等待\n補充：DMA Controller通常採用\u0026quot;Cycle Stealing\u0026quot;技術 (or Interleaving)與CPU 輪番(交替)使用memory跟Bus，如果CPU與DMA Controller發生conflict(同時要用Memory 與 bus)，則會給DMA較高的的優先權\n通常系統會給予「對該資源需求量、頻率等較小」的對象有較高的優先權，這樣會獲得\n平均等待時間較小 平均產能較高 的好處\n機器指令的Stages (CPU執行的幾個階段)\nIF DE FO EX WM IF：Instruction Fetch 抓指令：根據Programming Counter的值，到記憶體去把指令抓出來 DE：Decode 解碼：知道這條指令到底做什麼事情 FO：Fetch Operands 抓取運算元：運算元可能來自記憶體、也可能來自暫存器 Ex：Execution　執行 WM：Write Result to Memory　將結果寫入記憶體 CPU會不會Memory Access（到記憶體抓東西） DMA要用Memory IF 會 衝突(Conflict) DE 不會（指令已經拿出來放到IRinstructor registor) OK，歡迎 FO 可能 (運算元有可能在Registor，也有可能放在Memory) OK，或有衝突 EX 不會 (ALU去做了) OK，歡迎 WM 可能 (結果有可能寫回Memory也有可能是暫存器) OK，或有衝突 Cycle Stealing：當CPU會使用或不會使用Memory Access時，DMA都會去爭奪Memory的使用權，亦為Stealing(偷)，因為DMA擁有最高使用權。\nDMA Six Steps (早:中央、清華、交大)\nDevice Driver User Process 告訴 I/O subsystem(kernel)告訴 Device Driveris told to transfer Disk data to Buffer address X Device Driver tells disk controller to transfer C bytes from disk to Buffer at address X從磁碟讀C byte的量，分配到記憶體位址X的地方 Disk controller initiates DMA Transfer Disk controller sends each byte to DMA controller DMA transfer bytes to Buffer X in creasing memory address and decreasing Counter utill Counter =0 When C=0, DMA interrupts CPU to signal transfer compeletion Life cycle of I/O-request via Interrupted I/O Blocking and Non-Blocking I/O Blocking(會暫停的) and Non-Blocking(不會暫停的)I/O\n所謂的Blocking的意思是，當User process發出I/O請求之後，接下來這個prcess就會suspend，直到這個I/O被完成\nBlocking-I/O: (等於Synchronous)：Process suspended until I/O completeed\n優：Easy to use and understand, process在waiting的時候，可以把CPU放出去給其他process做使用 缺：Insufficient for some needs Non-Blocking I/O： I/O calls returns as much as available I/O請求發出去後，控制權立刻返回給user process\nexample：user interface, data copy Implemented via multi-threading Returns quickly with count of Bytes read or written Asynchronous-I/O: (屬於Non-blocking)：Process runs while, I/O executes\nDifficult to use I/O subsystem signals process when I/O-completed Asynchronous與Non-Blocking的小差異 Asynchronous I/O：整個I/O完成，才通知Process\nNon-Blocking I/O：I/O完成Data return as much as possible (能回傳就回傳， 少量即可回傳)\n舉例說明：userProcess發出100 byte的I/O請求\nAsynchronous的方式，會將100byte的I/O做完後，才告訴Process做完了 Non-Blocking的方式，每讀25Byte就通知一次， 逐步回報給Process，會發出比較多次的Interrupt Interrupt Policy and 當Interrupt發生，OS之處理Steps如下： OS收到中斷後(若此中斷要被立即處理，則OS會暫停目前Process之執行，且保存其Status and Registers Contents) OS會依照Interrupt ID(No.)查詢Interrupt Vector中斷向量表，確認何種Interrupt發生，且找出其ISR的位址 Jump to ISR 位址，執行ISR ISR完成後，控制權返回Kernel OS會恢復(resume)中斷之前Process之執行 Interrupt種類\n早期恐龍分為三種\nExternal Interrupt：CPU以外的周邊設備、控制卡、etc，所發出的中斷 例：I/O-Completed, I/O-error, Machine-check,\nInternal Interrupt：CPU在執行Process過程中，遭遇重大錯誤而引發 例：Divide-by-zero除以零、執行非法的特權指令、etc\nSoftware Interrupt：user process 在執行中，若須要OS提供服務時，發出此類型的中斷，目的是通知作業系統，請它執行對應的服務請求 例：I/O-request 好比是KTV的服務鈕，按下去就會有人過來問你要幹嘛\n現在恐龍分為兩種\nInterrupt：硬體所產生就叫Interrupt Trap：軟體所產生的就叫Trap 例：設備發出I/O-Completed,I/O-Error,Machine-check,etc及Time-out by Timer\n用途主要有二\nCatch the arithematic error 例：Divide-by-zero, 執行非法特權指令, illegal memory access\nuser process 執行需要OS提供服務時，也會發trap通知OS 例：I/O　Request\n分成兩類背後哲學：中斷之間也有優先權高低之分 Maskable Interrupt遮罩：此類中斷發生後，可被Ignored或延後處理不一定要馬上處理 例如：Software-interrupt Non-Maskable不可遮罩：此類中斷必須立刻處理 Internal interrupt(重大error), I/O-error,etc Hardware Resources Protection 基礎建設 Dual-modes operation(雙重模式) Privilege instructions Dual-modes operation 定義：System之運作模式至少(可再往下分，依照系統設計的必要性)可被區分為2種modes\nkernel mode user mode kernel mode\n又叫做system mode, supervisor mode, privileged mode, monitor mode(早期有，現移除)，代表此刻是kernel取得系統控制(取得CPU執行權)，允許privilege instructions(特權指令)在此mode下執行\nuser mode\n代表user process取得CPU執行，在此mode,不允許執行privilege instructions(特權指令)，若執行則會發生trap的重大錯誤\n此外，Dual-modes必須要有HW的支持，才可實現\n例如：CPU內會有Mode Bit，用以區分現在是哪個mode當CPU在執行機器指令時，IF、DE...之類的階段，若解碼完發現是個特權指令，這時候Control unit就要檢查目前的mode bit，判斷是否可不可以執行，若不行就丟出一個interrupt，不允許執行\nPriveleged instruction(特權指令) 定義：任何可能會造成系統重大危害的指令，可設為特權指令(端看工程師如何設計)，只可以在Kernel Mode去執行，不可以再User mode下執行，一旦在User Mode下執行，會發Trap通知OS，將此user process terminates.\n如果把所有的指令設為特權指令，好處就只有超級安全，因為這些指令都只有OS可以做，如果user想做就只能委託OS執行，但這樣performance會很差，因為所有事情都要給OS處理\n例如：\nTurn-off(Disable) interrupt, clear memory, I/O instruction(for I/O protection),Timer值 set/change (for CPU protect)\nBase/Limit register 修改/set (for memory protection)\nChange mode from user mode to kernel mode\n1 2 3 4 5 6 7 8 1). Set value of Timer 2). Read the clock 3). Claer memory 4). Turn-off interrupt 5). Switch from user to monitor mode 哪些是特權指令? 1,3,4,5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1. Change to user mode 2. Change to monitor mode 3. Read from monitor memory 4. Write into monitor memory 5. Fetch an instruction from memory 6. Turn on timer interrupt 7. Turn off timer interrupt 哪些是特權指令? 2,4,7 詳解： 6. 本身就是打開的，因為要做CPU的保護 7. 但關掉不是 有爭議的部分 3. user process去讀kernel process的資料，恐龍認為是，因為kernel裡面掌管所有Process的information，而process間不應該各個process的狀態 5. 從Monitor memory(Kernel)裡面去讀指令出來，恐龍認為不是，因為就算抓了，但你的mode不是Privilege instruction就會把你擋掉 為什麼Dual-mode跟Privilege Isntruction可以構成保護基礎 所有會危害OS的操作都是在Kernel 發生，因此不可以放任user可以直接操作Kernel\nI/O-Protection 目的：由於I/O運作較為繁瑣複雜，為了降低user processes 操控I/O之複雜度`，讓user processes去處理應用的問題，I/O則交由OS去處理；及避免user process對I/O-Devices之不當操作，胡搞瞎搞，因此才有I/O protection。簡單來講就是不要讓user processes去操作I/O\n作法：把所有I/O指令皆設為privileged instruction配合Dual-modes, 一律讓user process委託 kernel執行I/O運作\nMemory Protection 目的：防止user process 存取其他user processes 之 memory area 及 kernel memory area\n作法：(以 contiguous Memory Allocatation 為例) 針對每個Process, kernel會提供一套Registers：叫base/limit register, 其中\nBase register紀錄Process之起始位址 Limit register紀錄Process之大小 將來Process執行，會進行下列的Checking\n為什麼Address的判斷是由Hardware來做而不是OS來做呢？\n因為交給OS來做就會產生中斷interrupt，又因程式在執行的時候對記憶體的存取是很頻繁的，兩個影響之下會導致你的CPU一直被interrupt打擾，因此交給Hardware來做會比較符合成本一點。\n並且，還要將 Base與Limit register 值之set/change須設為\u0026quot;Privilege Code(特權指令)\u0026quot;，避免user Process把Base跟Limit的位址直接改成無限，這樣就完成了Memory的Protection\nCPU Protection 目的：防止user process無限期/長期佔用CPU而不釋放\n作法：利用Timer實施，同時OS會規定Process使用CPU time之最大配額值(MAX. Time Quantum)\n當process 取得CPU後，Timer初值即設為Max Time Qauntum值，隨著Process執行 time增加, Timer值會逐步遞減，直到Timer值為0, Timer會發出 Time-out的interrupt通知OS，OS便可強迫此process放掉CPU，此外，Timer值之set/change 也須設為特權指令\nOS Structure Operating-System OS之Development\nOS應提供的服務項目\nOS之服務元件種類\nSystem Calls之介紹(使用者程式跟OS之間溝通的介面)\nOS之Structure種類\nSimple\nMore Complex than simple\nLayered Approach\nMicrokernel\nModule\nHybrid(混合?)\n設計原則：Policy與Mechanism policy管行為,比較常變，例如數值的變動; mechanism負責處理how,比較不會變,例如邏輯的判斷 Virtual Machine介紹\nSystem Call 定義：作為執行中user process與kernel之間的溝通界面，當user process需要OS提供某種服務時，會先trap通知OS，並帶入System call ID(No)及所需參數，然後OS執行對應的System call\nIt\u0026rsquo;s a programming Interface to the services privided by the OS\n用舉例來講的話\nTrap = 服務紐 System call = 服務項目 System Call的種類(中央考過類似的題目)\nProcess Control eg：建立、終止、暫停、恢復執行process, set/read attribute File Management eg：建立、read, write, open, close, delete \u0026hellip; Device Management eg：建立、read, write, open, close, delete \u0026hellip; Information of Maintenance eg：取得系統日期/時間、取得Process屬性 etc Communications eg: Processes之間的通訊而且只針對Message Processing方式提供服務 Protection　eg: Hw resources protection, File access contorller, etc System Call的參數(Parameters)傳遞方式：3種方式\n利用暫存器(Registers)保存參數 優點： 最簡單 存取速度最快( without memory access) 缺點: 不適用於大量參數之情況 利用Memory，以一個Block(Table)儲存這些參數，並將這些表格的起始位址置於1個Register中，Pass給OS 優點: 適用於大量參數 缺點: 存取速度較慢，且操作較為麻煩 利用Stack將參數push入此Stack, OS再pop from stack, 以取得參數 優點: 適用於大量參數之情況 也很簡單 缺點: Stack的空間須要預先準備，避免stackoverflow OS之系統架構分類 OS之Structure種類\nSimple: MS-DOS系統\nMore Complex than simple: UNIX系統\nLimited by Hardware functionality The original UNIX had limited structuring The UNIX 包含兩個Separate parts System Programs The Kernel Beyond simple but not fully layered(分層) Layered Approach\n定義：採取Top-Down方式，切割系統功能/元件，以降低複雜度。元件/模組之間呼叫關係分層\n即上層可以使用下層的功能，但下層不可以使用上層的功能。完成後要使用Bottom-up方式進行測試，debugging(由底層一路往外測)\n層次的劃分沒有明確規定\n優點：\n降低設計複雜度 有助於分工 測試、除錯、維護容易 缺點：\n很難做到精準的分層劃分 若Layer數太多，則System performance is very poor( 切到四層剛好、五層太多，極限中的極限是七層) Microkernel(微核心)：由CMU(卡內基-美隆大學)率先提出，代表產品：Mach o.s。它們認為UNIX的服務項目太多、太龐大，不利移植\n定義：將Kernel中一些Non-essential services(比較不是那麼基本、重要、必要)，自Kernel當中移除，改成在User Mode(Site)提供這些服務，以System programs方式存在，如此一來，可以得到一個比較小的kernel，稱之為microkernel, 一般而言，Microkernel提供下列三個minimum service： Porcess Controll Memory Management(不包括Virtual memory) Process Communications(提供message Processing服務而已) Benefits(好處) Easier to extend a microkernel 服務的增加/刪除是容易的，因為這些服務是在user site執行，所以服務的增、刪不需要牽扯到Kernel也要變更，即使要，也是少量 Easier to port the OS to new architectures 因為Kernel很小，所以移植到新的硬體平台之更改幅度不大(因為只有三個服務run在kernel) More Reliable 萬一某一個服務在執行中掛掉了，充其量只是相當於一個user process死掉而已，所以對HW, kernel, 其他user process沒有不良影響，因為把大部分的服務移到user mode去做了，因此更加安全、可靠 More secure 萬一某一個服務在執行中掛掉了，充其量只是相當於一個user process死掉而已，所以對HW, kernel, 其他user process沒有不良影響，因為把大部分的服務移到user mode去做了，因此更加安全、可靠 缺點 Performance overhead of user space to kernel space communication(效能較差)，因為process Communication充斥大量訊息傳遞 Note：microkernel的相反詞：Monolithic kernel\n定義：所有的Services皆須Run in kernel mode，大部分的商用OS幾乎都是Monolithic kernel，因為如果把所有的service移到user site去做，那它的控制就會很低。當這個控制力很低的時候，user或program就可以自己去Inhence一些東西，影響OS\n優點、缺點：和microkernel相反\nModule\nMany OS implement loadable(有需要才載入) kernel modules use Object-oriented approach Each core component is separate Each talks to the others over known interface Each is loadable as heeded within the Kernel 簡而言之：similar to Layers but with more flexible, 效能更好 例如：Linux, solaris, etc \u0026hellip;\nHybrid(混合?)：現在作業系統很難純粹歸屬於某一型\nLinux(中央考過) and Solaris 是 Monolithic (所有東西都run在kernel mode)，且也是Modular for dynamic loading 例：windows mostly monolithic，有時針對不同客戶需求，會再加上microkernel for subsystem 例：Apple Mac Os 也是混合的 kernel 包含\nMach microkernel\n部分的BSD UNIX\nI/O Kit\ndynamic Loadable module(叫做 kernel extension)\nVirtual Machine 定義：利用sofeware技術模擬出一份與底層HW一模一樣的功能介面之抽象代理器(abstract machine)，稱之Virtual Machine模擬的方式類似於CPU schdueling 名詞解析：\nHost：undelying hardware system, os\nVMM(Virtual Machine Manage)或Hypervisor：creates and managing/ runs virtual machines\nGuest：process provided with virtual copy of the host\n恐龍本之其他英文\nAbstract hardware of a single computer into several different execution environments Similar to layered approach, But layer crates virtual machine(VM) 優點\n作為測試開發中的OS，提供一個良好的負載平台，具有下列好處：\n其他user, user processes工作，仍可持續運作，不須暫停 萬一測試中的OS不穩定、掛掉/失敗了，也不會影響host Hw, OS, 其他user processes 之工作，因為只是相當於一個user process fails而已，不會對system有重大危害 同一部Host Hardware上可以執行多個OS running on 多個virtual machines，這樣可以節省成本\nConsolidation(合併)：在 Cloud computing environment，我們會用有限的機器，建立為數注眾多的virtual machines，我們可以依VM上的Applications之執行負擔輕重，調用Host machines資源，做因應的支援，有需要就在加開，沒需要就關掉，做資源的合併與調度\nVM較為安全(如果VM被病毒入侵，不致擴散，因為各VM之間是相互獨立的)\n可以Freeze, suspend, running VM, 及Clone(複製) VM\nVMM的Implementation\nHypervisor : 虛擬機管理程式\nType0 Hypervisor(硬體層次)：\nHardware-based solutions via firmware 例如：IBM LPARS and Oracle LDOMs Type1 Hypervisor(Kernel Mode層次)\nOS-like software\n例：VMware ESX, Joyent SmartOS, Crtrix XenServer general purpose OS that provide VMM functions (services)\n例如Microsoft Window Server with HyperV, Redhat Linux with KVM Type2 Hypervisor(user mode層次)：\nApplications level provides VMM functionality\neg. Paraller Desktop, Oracle VirtualBox\n還有一些其他的變形上面那三類都是要創造跟底層硬體(Host HW)一樣的Virtual Machine，但下面這些卻不是\nParavirtualization☆考試重點\nThe guest OS need modify to work in cooperation with VMM to optimize performance presents guest(run 在virtual Machine上的都叫guest) with similar but Not identical to Host Hardware Guest must be modified(必須要被修改才可以用) to Run ON Paravirtualization virtual hardware Programming-environment virtualization\nVMMs do not virtualize, HW but instead create on optimized virtual system .(創造全新的Virtual Machine)\neg. Java virtual machine(JVM), Microsoft .NET\nJVM is a SPECification(規格), not an implementation\n規範\nClass Loader(把bype code load下來) Class verifier(驗證器，驗證byte Code安不安全，比如是否包含pointer) Java interpreter(執行byte code) Emulators：Allow application written for one HW to run on a very different HW such as different type of CPU。例：PS4模擬器、3DS模擬器\nApplication containment (底層沒有Virtual Machine，而是 創造執行環境，而不是模擬)\neg. Oracle Solaris Zones BSD Jails, IBM AIX WPARs application\nPolicy(政策、策略 ) 與 Mechanism\nPolicy定義\n\u0026ldquo;What\u0026rdquo; to be proovided 經常改變、朝令夕改 Mechanism定義\nHow to do that The underlying(基本的) mechanism甚少改變或不變 設計原則：\nPolicy與Mechanism宜separate，以增進system flexibility\n舉例\n+ 運用Timer作為CPU protection \u0026gt; Mechanism + Max.Time Quantum大小制定 \u0026gt; Policy\r2. + CPU排版採Priority Scheduling 排班 \u0026gt; Mechanism\r+ Priority大小之定義 \u0026gt; Policy\rChapter4 Process Management And Thread Management Process 定義與Progeam比較\nPCB內容 考試重點\nProcess State Transition Diagram (S.T.D)考試重點\nScheduler的種類(解釋名詞)\n長期\n短期\n中期\nContext Switching (解釋名詞)\nDispatcher, Dispatch latency(較少考)\nProcess Controller Operations(UNIX, System Call為主的程式追蹤) 考試重點\n評估CPU Scheduling 效能的好或不好的5個Criteria(清大喜歡考)\n各種CPU 排班法則(7個)介紹及相關名詞(Starvation,Aging,Preemptive,Non-preemptive,Convoy effect) 考試重點\n特定System的排班設計\nMultiProcessors System\nReal-time System\nSoft (考申論題)\nHard(考計算題)\nThread Management\nProcess Definition 定義：A program in execution[恐]\nProcess 建立後，其主要組成有： Process No(ID): Process被生成出來時，會有一個Process Id，作為識別 Process State Code Section, Data Section：Process占用的 Memory Space Programming Counter(PC)：程式計數器，告訴我們現在這個Process執行到哪裡，裡面放下一條指令的位址 Stack CPU Register value 是OS 分配 **Resource(CPU,I/O-Divice, Memory) **之對象單位：跟Thread的差別 與Program(程式)的比較 Process Program 執行中的程式 Just a File stored in storage device \u0026ldquo;Active\u0026rdquo; entity(活動中、執行中) \u0026ldquo;Passive\u0026rdquo; entity(沒有活動的) Process Control Block (PCB內容)\n定義：OS為了管理所有Processes，會在Kernel memory中，替每個Process，各自準備一個Block(Table, 表格)，用來記錄Process之所有相關資訊\nPCB的主要內容有(要背，考選擇)：\nProcess No(ID)：是Unique(唯一的)\nProcess state：eg. ready, running, wait, etc\nProgramming Counter：內放 the next instruction\u0026rsquo;s address\n**CPU Registers：eg. 紀錄使用到的暫存器的值 eq. Accumulator, PSW(Process Status Word), Stack Top ,etc **\nCPU Scheduling Info：eg. Process 的優先權，First-In First-Out(FIFO)\nMemory Management Info(隨OS的記憶體管理方法不同，紀錄不同資訊)：eg. Base/Limit register或 Page Table 或 Segment Table\nAccounting Info：eg. Process已使用了多少CPU Time, 哪些資源, 還剩多少資源,多少CPU Time可以用 Note：目的\n計算使用量，記帳、收＄\nAdministrator 調教Performance的依據\nI/O Status Info：eg. process已經發出多少I/O-Request, 完成 狀況如何，占用那些I/O Resource(目前還沒釋放的)\nProcess State Transition Diagram 狀態轉換圖(S.T.D)\n目的：描述Process之Life Cycle，用來記錄Process建立，到它被終止之間，所發生的事\n各個版本的STD定義都不太一樣\n[恐] 5個State的STD [Stalling]7個State STD (比恐龍多兩個狀態) [Stalling] UNIX的STD 5 Steps of State Transition Diagram 要會畫，會說明，超基礎，考出來是送分題\nState Description New(Create) Process被建立，已分得PCB的空間，尚未載入記憶體、未取得記憶體資源，因應Batch的系統 Ready Process在記憶體了，且OS已經把它放到Ready Queue內，且具有資格爭奪CPU Running Process取得CPU 執行中 Wait(Block) 表示Process待在waiting Queue中，Waiting For I/O-Completed or event occurs, 不會與其他Processes 競爭CPU Exit(Terminate)(Zombie)(Abort) Process完成工作，正常結束或異常終止，可能其PCB尚未回收，因為要等其父親(Parent Process)Collect 該子process之成果後，才會回收PCB Space其他資源(Memory, CPU, I/O-Devices)已回收 Transition Description 1. 也叫Admit，當Memory Space足夠時，可由Long-term Scheduler(in Batch System，因為放在Job Queue裡頭)，決定將此Job載入到Memory中 2. 也叫Dispatch,由short-term scheduler(CPU Scheduler)決定，讓高優先權的Process取得CPU控制權 3. 也叫Time-Out/Interrupt，執行中的Process會因某些事件發生而被迫放棄(不是自願的)CPU，回去Ready Queue, eg. Time-Out, Interrupt發生,更高優先權的Process到達，插隊 4. 叫wait for I/O-Completed or event occurs(自願放棄CPU) 5. I/O-Completed 或 Event occurs 6. Process完工或異常終止 (自願放棄CPU) 7 Steps of State Transition Diagram[Stalling] 補上Middel Term Scheduler\n為了解決一個問題\n當記憶體被占滿了，有一個更高優先權的Process近來，該如何處理？\n把wait狀態的process踢出去，放到磁碟去保存\nState Description Blocked/Suspend Process被Swap Out到 Disk中暫存，即Blocked(asleep) in Disk Ready/Suspend event occurs or I/O-Completed, READY IN DISK Transition Description Suspend(Swap Out) 當Memory空間不足，又有其他高優先度的Process需更多Memory空間時，會由Medium-Term Scheduler決定將Blocked Process或低優先權的Process Swap out到Disk，以空出Memory Space Activate(Swap In) 當Memory space有空，Medium-term scheduler可將它們Swap In回memory中，Ready for execution Suspend(Swap Out) 支持此Transition之理由有二\n1.所有Blocked Processes皆Swap out後，Memory Space仍不足時\n2. 所有Blocked State Processes之優先權，皆高於Ready State Process時 Transition Description 1 把從在磁碟睡覺的process拉到記憶體裡面睡覺，This is a poor design，但仍可支持，理由如下：若所有Blocked/suspend` state之Processes優先權皆高於ready/ suspend processes, 且OS believes them will become ready soon 2 It\u0026rsquo;s also a poor design 但可支持之理由如下：若有一個高優先權的process從blocked/suspend變成ready/suspend時，則OS可以強迫低優先權但已執行的process放棄CPU的使用以及Memory的空間，供高優先權使用 UNIX STD[Stalling] Scheduler Type(Important) Long-term Scheduler\n定義：又叫Job Scheduler，目的是從Job Queue中挑選一些Jobs載入到Memory中 特色： 執行頻率最低，所以才叫長期 可以調控Multiprogramming Degree 可以調控 I/O-Bound Job與CPU-Bound Job之混合比例(下面有解釋) Batch System採用，但是real-time system以及time-sharing不會採用這種機制。因為real-time系統處理的process都是比較緊急的，因此就需要直接丟進memory去執行。而time-sharing系統要求對每一個user公平，沒有優先度需要處理，如果memory不夠則調用virtual memory，因此time-sharing系統只存在medium-term以及short-term Short-term Scheduler：\n定義：又叫CPU Schduler或Process Scheduler，目的是從Ready Queue中挑出一個高優先權的process，分派CPU，給CPU執行 特色： 執行速度是三者裡面最高的 無法調控Multiprogramming Degree，因為它不是負責將程式load進memory與Swap out出去的人 無法調控I/O-Bound Job與CPU-Bound Job之混合比例，頂多決定誰要先做，不能決定比例 所有的 System採用 Medium-term Scheduler(最常被考)：\n定義：Time-Sharing System採用，當Memory空間不足，且又有其他高優先權Processes需要Memory Space時，此Scheduler會啟動，它會挑選一些Processes(eg. Blocked Process, 低優先Process) 將其Swap Out到Disk中，保存，以空出Memory Space，供其他Process使用，將來等到有足夠的Memory Space released後，此Scheduler可再將它們Swap In 回Memory, ready for execution\n特色：\n執行速度是三者裡面居中的\n可以調控Multiprogramming Degree，因為它不是負責將程式load進memory與Swap out出去的人\n可以法調控I/O-Bound Job與CPU-Bound Job之混合比例，頂多決定誰要先做，不能決定比例\nTime-Sharing System採用\nMultiprogramming Degree：系統內的Process的數目：一般而言，Degree越高，CPU利用率就越高。\nI/O-Bound Job與CPU-Bound Job I/O-Bound(受限) Job\n定義：此類型工作大都是需要大量的I/O operation(resource)，但對於CPU Time(Computation)需求很少，因為其工作效能受限於I/O-Device之速度，稱之I/O-Bound，對CPU有最高優先權，因為它占用CPU的時間最短\n例如：Data Base Management, 財報的處理列印\nCPU-Bound(受限) Job\n定義：需要大量的CPU計算，產生數筆資料，對I/O有最高優先權，因為它占用CPU的時間最短\n例如：氣象預估、科學模擬\n如果OS發現I/O-Bound過多，則會透過Schduler來調控兩者之間的比例\nContext Switching 定義：當CPU要從Running Process切給另一個Process使用之前，Kernel必須**保存(Store) Running Process的目前狀態資訊(eg. Programming Counter的值，Stack的值，CPU Register的值，etc)，即存回此Process之PCB **。且要載入(restore)另一個Process之狀態資訊from此Process PCB，這樣的行為就叫做Context Switching，Context Switch本身是一個額外的負擔，因為需要花CPU的時間去做切換，不能用在Process的執行上，因此時間大多取決於硬體的因素居多(eg. Register的數量夠不夠，Memory存取指令速度\n如何將低Context Switching負擔\n如果Register的數量足夠多，則可以讓每一個Process皆有自己的(Private) Register Set，OS只要切換Point指向另一個process之Register Set 即可完成Context Swtitching without memory store/restore ，因為速度夠快。但這個方法不太切實際，因為Register的成本關係 使用Multithreading機制。 讓System process及User Process各自擁有自己的Register set，如此兩者之切換只要Registers Set的Pointer即可 Dispatcher And Dispatch Latency 分派器與分派延遲\n定義：Dispatcher，此一模組的目的是要將CPU控制權授予經由CPU Scheduler依據CPU排班法則所選出之Process，選好後CPU Scheduler會將工作交給CPU Dispatcher，主要的工作項有下列三項\nContext Switching Change Mode from to Kernel mode to User Mode Jump to the execution entry of that selected proces 上述這三個工作所耗費的時間總和就是Dispatch Latency\n希望Dispatch Latency越短越好，這些Process可以盡早開工\nProcess Control Operations☆☆☆☆☆ Lession 1 Theory 定義：Process建立、終止、暫停、恢復執行、設定／修改／讀取 Process Attributes值 etc.\n上述這些皆是OS應該提供的服務(i.e System Call)\nProcss是可以建立自己的Process(Child Process)，目的是要Child Process做工作\nChild Process所做的工作，可以分為2類：\n與Parent 相同的工作(子承父業) 特定工作(與Parent不同) Parent與Child之間的互動關係為：\nConcurrent execution(交錯使用，通常是執行第一類的工作(子承父業)) Parent waits for Child until child terminated(等著收割Child的成果) Child Process 所須的資源由何處取得?\nOS供應(這種情況OS會去限制每個process最大可產生多少個Child Process) Parent供應(整個家族Process的資源都是共享，Parent Process的Sharing Time有一小時，那麼整個家族的Sharing Time 就是一個小時 Parent 若終止，則Child Process會如何處理?\n一併終止(最常被使用) ：稱之為Cascading(層疊的) termination\nParent Process死了，但Child Process存活，那Child的資源由以下兩者提供\n向OS取得資源\n向祖先Process取得資源\nLession 2 Example - UNIX System Call fork()：此System call. 用以建立 Child Process，而fork()之傳回結果，對象如下 失敗：因為資源不足(記憶體不夠，PCB也不夠)，無法建立，會傳回負值(-1)給OS, then Pass to parent process，通常失敗的話，OS也會順便把Parent process砍死\n成功：OS會傳回一個值，用以區分child or parent：\n0值：給child process\n.\u0026gt; 0值：給Parent，且此值為Child Process ID\nwait()：此System Call用以暫停Process execute, 直到某個事件發生，eg. 父等子直到子終止 。\nexit()：此System Call用以終止Process的執行，回收其資源但PCB的空間可能還留著，直到父把子的結果回收回來才回收通常exit(0)表示正常終止，exit(-1)表示異常終止。子Process做完工作後，子Process要自己發出一個exit的System Call，讓OS來殺掉子Process。\nexeclp()或exec(), execve()：此system call用於請OS載入特定的binary code(可執行的檔案)，來執行。這個System call可以交由子process執行，讓子process執行特定的工作，去執行之後就不會再回來執行原程式下面的指令了，因為已經去執行特定的工作了\neg. execlp(\u0026ldquo;目錄名稱\u0026rdquo;,\u0026ldquo;檔名\u0026rdquo;,參數)\ngetpid()：此System Call用以取得Prcess的Id\n​\t說明：\n​\tOS會配置child process memory space, 此空間是占用不同的記憶體空間，且子process的Data section 及 code section內容均來自父process的copy, initially。\n​\t若子process所作之工作與父process相同，則fork()完，就已經達成目的。\n​\t若子process要做特定工作(與父process不同)，則子process必須執行execlp()這個system call\n​\tLession3 Programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //例題1；建立Child process執行ls命令檔，且父等子完成後才列印Child completed void main(){ int pid ; pid = fork(); if(pid\u0026lt;0){ printf(\u0026#34;fork fails \\n\u0026#34;); exit(-1); //爸爸自己自殺 }else if (pid ==0){ //兒子要做的事情 execlp(\u0026#34;/bin/ls\u0026#34;,\u0026#34;ls\u0026#34;,null); exit(); //這段code不會執行，原因是因為execlp()會把process指向/bin/ls的binary code，接著就是去執行那段binary code了，就不會回來執行這個exit(); }else //pid \u0026gt;0{ //爸爸要做的事情 wait(); //父Process子Process直到子Process終止 子Process做完工作後，子Process要自己發出一個exit的System Call，讓OS來殺掉子Process。 printf(\u0026#34;child Completed\u0026#34;); exit(); }; { //不管怎樣都會執行的地方 } }\t1 2 3 4 5 6 7 8 9 10 11 12 13 14 //例題2 假設Parent, child 之process ID為2600, 2603 求line A, B, C, D 印出值 void main(){ pid-t pid, pid1; //pid-t: 一個名為pid 的type，就是整數，是C語言的寫法 pid-fork(); //pid 放的是子process的ID， pid1放的是自己process的ID if(pid==0){ pid1=getpid(); printf(pid); //A 0 printf(pid1); //B 2603 }else if(pid \u0026gt;0){ pid1=getpid(); printf(pid); //C 2603 printf(pid1); //D 2600 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //例題3 問A的值value是多少 int value =5; void main(){ pid-t pid; pid = fork(); if(pid ==0){ value +=15; return 0; }else if(pid \u0026gt;0){ wait(null); print(value); //A=5 就算是global的變數，也是只能在自己的process作用 return 0; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //例題4 求列印結果 (1.) void main(){ int pid; pid =fork(); if(pid==0){ printf(\u0026#34;A\\n\u0026#34;); }else //pid \u0026gt;0{ printf(\u0026#34;B\\n\u0026#34;); } } Ans: 父與子是並行的，因為父process沒有wait(), 因此答案可能是AB或BA (2.) void main(){ int pid; pid =fork(); if(pid==0){ printf(\u0026#34;A\\n\u0026#34;); }else //pid \u0026gt;0{ printf(\u0026#34;B\\n\u0026#34;); wait(); } printf(\u0026#34;C\\n\u0026#34;); } Ans: ACBC,ABCC,BACC, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //例題5 假設Count，是一個父與子Process的共享變數 ，初值為5 (1.) void main(){ int pid; pid=fork(); if(pid==0){ count++; printf(count); }else if (pid \u0026gt;0){ wait(); count--; printf(count); } } Ans.6,5 (2.) //父與子並行 void main(){ int pid; pid=fork(); if(pid==0){ count++; }else if (pid \u0026gt;0){ count--; } printf(count); } Ans. 45,54,55 //這是基本情況 //以高階程式語言的角度來看，count++實際上是兩條code //count+1跟count=count+1 //先加然後再附值 //如果以組合語言的角度來看，就是三行code //LOAD R1, Count //INC R1, 1; //STORE Count,R1 //但Process沒有辦法保證這三條Code會連續做完，有可能做到一半就被另一個Process搶走了 //所以還有一種情況是+1完之後，還來不及Assign，CPU就被另一個Process搶走了 Ans.66,44,46,64 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 //例題6 (1.) How mant processes are created? (include main()) void main(){ fork(); fork(); fork(); } Ans.8 (2.) void main(){ if(fork()==0){ //等同於 pid=fork(); if(pid ==0) .... fork(); fork(); } fork(); } Ans.10 (3.) void main(){ fork(); if(fork()\u0026gt;0){ fork(); }else if(fork() ==0){ fork(); fork(); } } Ans.14 (4.) void main(){ for(i=0;i\u0026lt;3;i++){ if(fork()==0){ fork(); fork(); fork(); } } } Ans.729 (5.) void main(){ for(i=0;i\u0026lt;3;i++){ if(fork()==0){ fork(); }else if(fork() \u0026gt; 0){ if(fork()==0){ fork(); } } } } (6.) void main(){ int a =2; fork(); a--; printf(a); if(fork()==0){ a--; printf(a); fork(); }else{ a++; fork(); printf(a); } } (i.) printf(a)共做了幾次? (ii.)印出0的有幾次? (iii)印出1的有幾次? (iiii.)印出2的有幾次? 例題1\n例題2\n例題3\n例題4\nparse1\nparse2\nparse3\n例題5\nparse1\nparse2,3\n例題6\nEvalue CPU Scheduling Performance 5 criteria CPU utilization：cpu花在Process exec time / CPU total time(process exec time + context switching time+ idle time)\n舉例：Process平均花5ms在exec上 ,context switching = 1ms,則CPU utilization = 5/5+1 =5/6 Throughput(產能)：單位時間內完成的Job數目\nWaiting Time(等待時間，考試重點)：process花在ready queue中等待獲得CPU之等待時間加總\nTurnaround Time(完成時間)：從Process進入(到達)到它工作完成的這段時間差值\nResponse Time(回應時間)：自user(user process) input 命令/Data 給系統到系統產生第一個回應的時間差，沒有一個特定的量法去量它，稱之Time-sharing system, user-mteractive, application特別重視這一塊\n由上述得知，排班的目標必是，**利用度越高、產能越高，時間相關的東西越短越好 **\nCPU排班法則行為介紹 FIFO SJF SRTF Priority RR Multilevel Queues Multilevel Feedback Queues (MFQs) FIFO法則 定義：到達時間最小的process，優先取得CPU\n例如：\nProcess CPU(burst) Time 要花的CPU time P1 24 P2 3 P3 3 到達時間皆為0(從一開始就到了)\n到達順序為：P1, P2, P3(擺到ready queue的順序)\nQuestion\n畫出Gantt Chart 求Avg. waiting time 求Avg. Turnaround Time 分析\n排班效能最差，即Waiting time \u0026amp; Turnaround time 最長\n可能會有**Convoy Effect(護衛效應：許多Processes 均在等待一個需要很長CPU time之process 完成工作，才能取得CPU，造成Avg waiting time 很長之不良效應) **\n公平\nNo Starvation\n(沒有飢餓現象：Process因為長期無法取得完工所需各式資源，導致它遲遲無法完工，形成Indefinite Blocking 現象，稱之Starvation，容易發生在不公平對待之環境，若再加上Preemptive機制，則更是容易發生，補償方案：\u0026ldquo;Aging(老化)\u0026ldquo;技術，隨著Process待在System內的時間逐漸增加，我們也逐步提高此process的優先權，故可取得Process Resources完工，因為不會Starvation。注意：Soft real-time System不採用Aging，因為Soft real-time system是為了確保real-time process取得最高優先權，如果加入Aging機制，就有可能有process的priority高於real time process) Non-preemptive(不可插隊；不可搶奪)法則\n版本1(白話文)\nNon-preemptive法則\n定義：除非執行中的process自願放掉CPU，其他Process才會有機會取得CPU，否則就只能wait，不可逕自搶奪CPU 例如：完成工作、Wait for I/O-completed after issue I/O-request 優點： Context Switching的次數比較少，因為不可插隊，所以Switching的頻率小很多 process之完工時間點較可預期(Predictable)，因為不可插隊 比較不會有Race Condition Problem 缺點： 排班的效能較差，因為可能有Convoy effect 不適合用在Time-sharing System, Real time System，因為這兩個都需要插隊的機制 Preemptive法則\n定義：執行中的Process有可能被迫放棄CPU，回到ready Queue，將CPU切給別人使用，eg. Time-out, interrupt etc 優點： 排班效益較佳，平均waiting/ turnound Time較小，可以把耗時較長的Process Preemptive掉 適用於Real-time sysem(要能夠把real time 的process插入進去) 及Time-Sharing System 缺點： 完工時間較不可預期 Context Switching次數多，負擔較重 須注意Race Condition之發生 版本2：從CPU排班決策(啟動)之時機點來做區分(可以參考 State Transition，以下是五種情況做解說)\nRunning \u0026mdash;\u0026gt; Block eg: wait for I/O completed [自願放棄] Running \u0026mdash;\u0026gt; Ready eg: time-out [被迫放棄] Wait \u0026mdash;\u0026gt; Ready eg: I/O-completed [尊爵不凡的process醒來了，所以要啟動CPU scheduling，獲得CPU，低優先權的process被迫放棄CPU] Running \u0026mdash;\u0026gt; Exit eg:完成工作 [自願放棄] 所以若排班決策之啟動點只包含1,4，未包含2,4，則為Non-preemptive,否則preempt。\nNote：凡是 xxx \u0026mdash;\u0026gt; ready 皆列入preemptive元素(選項)，所以\nready/suspend \u0026mdash;\u0026gt; ready\nNew \u0026mdash;\u0026gt; Ready\n皆列入preemptive\nSJF(Shortest Job First)法則 定義：具有最小的CPU TIME之Process，優先取得CPU，若都一樣小，則採FIFO。\n例如：\nProcess CPU Time P1 6 P2 8 P3 7 P4 3 Process到達時間皆為0，求Avg waiting time\n分析：\n排班效益最佳(optimal)，即Avg waiting/ turnaround time最小\n說明：Why optimal?\n因為Short Job所減少的等待時間必定\u0026gt;= Long-Job所增加的等待時間，因為平均等待時間會最小\n不公平，偏好short Job\n可能會Starvation(for long Job)\n可以分成\nNon-preemptive \u0026mdash;\u0026gt; SJF做代表\nPreemptive \u0026mdash;\u0026gt; 另外叫做SRTF法則\n較不適合用在Short-term scheduler(比較不恰當啦，但你要用也是可，因為Short-term scheduler執行頻率太高，所以很難在極短的時間間隔內去預估出精確的CPU Burst time for each process 且排出最小值，不易真正呈現出SJF之行為，反倒是適合用long-term scheduler\nShort time scheduler是指專門負責處理短暫的工作的計劃程序。這些工作通常會在短短的時間內完成，並且有許多工作要求同時進行。在這種情況下，使用short job first（SJF）法則來處理工作可能不是最佳選擇。這是因為SJF法則是基於工作預計完成時間的，並假設工作的預計完成時間是可以預先知道的。但是，在short time scheduler中，大多數工作的預計完成時間都是未知的，因此無法準確地應用SJF法則。另一個原因是，SJF法則會將短工作放在優先執行的位置，因此會把許多短工作排在一起。在short time scheduler中，這可能會導致許多短工作之間的競爭，從而導致效率降低。總的來說，short time scheduler更適合使用其他計劃策略，例如基於先進先出（FIFO）或基於最短剩餘時間（SRT）的策略，來處理短暫的工作。)\n如何評估process之the next cpu burst time?\n公式(加權指數平均公式)\nt0 t1 t2 t3 實際值 20 10 40 20 預估值 20(一開始還沒預估，所以都是抓t0的值) ? T0 T1 T2 T3 T4 意義:　SRTF,SRJF,SRTN( Shortest Remaining-Time Job First(Next)) 定義：即為Preemptive-SJF法則，即剩餘CPU Burst Time(CPU完成一次短時間工作所需的時間)最小的 Process，取得CPU。也就是若新到達的Process其CPU Burst TIme 小於目前執行中process剩下的CPU time, 則新到達之Process可以**插隊(preemption)**執行。\n舉例：\nProcess 到達時間 CPU Time P1 0 8 P2 1 4 P3 2 9 P4 3 5 求Avg waiting Time for\nSRTF\nSJF(不可插隊)\nFIFO\n分析：\n與SJF相比，SRTF之平均waiting/Turnaround time會比較小(SRTF是SJF的一個子類，因為SRTF可插隊，所以會有最小的waiting time, 但是付出較大的Context Switching的overhead(負擔) 不公平，偏好Short remaining-time Job 會有Starvation的問題 Preemptive法則 Priority法則 定義：可參數化的法則，具有Highest Priority之Process，優先取得CPU，若多個Process權值相同，則以FIFO為準，也有分成Non-preemptive, Preemptive的差異。\n舉例：不可插隊\nProcess CPU time Priority No. P1 10 3 P2 1 1 P3 2 3 P4 1 4 P5 5 2 且，Priority No越小，優先權越大The Smaller Priority No. Implies the higher priority。求Avg waiting Time\n分析：\n是一個具參數化的法則，即給予不同的priority高低定義，可展現出不同的排班行為。\nPriority定義 行為 抵達時間越早，優先權更高 FIFO CPU　Time越小，優先權越高 SJF 剩餘時間越小，優先權越高 SRTF 因此FIFO, SJF, SRTF都是屬於Priority的一種\n不公平\n會有Starvation (可用Aging去解決)\n分為Non-preemptive, preemptive兩種\nRR(Round Robin)法則(考試重點) 定義：Time-Sharing System採用，OS會規定一個CPU time Quantun(or Slice)，當Process取得CPU執行後，若未能在此Quantum內完成工作，則Timer會發出\u0026quot;Time-out\u0026rdquo; interrupt通知OS，OS會強迫此process放掉CPU，且回到ready queue中，等待下一輪再取得CPU執行，每一輪之中，process是以FIFO排隊方式取得CPU\n舉例1：\nProcess Cpu time P1 8 P2 4 P3 9 P4 5 到達時間皆為0，順序是P1~P4, 使用RR(Quantum=4), 求Avg waiting time\n舉例2:\nProcess Arrival Time Cpu Time P1 0 10 P2 2 5 P3 7 3 P4 13 8 舉例3:\nProcess Arrival time 行為 P1 0 5CPU+6I/O+4CPU P2 3 15CPU P3 8 3CPU+10I/O+9CPU P4 14 8CPU Quantum= 5，問turnaound time ? waiting time ?\n注意：有些題目是有爭議的 ​\teg.\nProcess 到達 CPU time P1 0 6 P2 4 9 P3 8 6 ​\t採RR(Q=4)\n​\t分析：\nTime-sharing System 採用 也是一個可參數化的法則(ie. Quantum) 公平 No starvation preemptive法則(Real-Time, Time-Sharing適用，RR超過Quantum time後會被迫回到ready 舉例2\nQuantum=∞\n則RR會變成FIFO法則\u0026mdash;\u0026gt; 排班效能很差\n注意：也因此，FIFO屬於RR的一種\n舉例3\nQuantum =極小值\n則Context Switching太頻繁，CPU Utilization會很低\n依經驗法則，若Quantum值能讓**80%**的Job在Quantum內完成，效能較佳。\n補充：RR雖然是公平的，但也可支持差異化(優先權差異)之實現，How do you achieve this?\nAns.\n針對高優先權Process在ready Queue中置入多個PCB pointer 指向此Process，使得每一輪當中，它有多次取得CPU之機會 針對高優先權Process給予較大的Time Quantum MultiLevel Queues(多層佇列)法則 定義：\n將原本單一一條ready queue變成多條ready queues且高、低優先權不同 Queues之間的排班法則，通常採取Preemptive and Priority法則 每個Queue 可以有自己的排班法則 eg. RR Process一旦被置入於某個Queue中，就不可(不允許)在不同ready queues之間移動 舉例：I/O-Bound與CPU-Bound Job你會置於哪個Queue中?\nAns：I/O-Bound Job \u0026mdash;\u0026gt;Q1\n​ CPU-Bound Job \u0026mdash;\u0026gt;Q3\n分析：\n可參數化的項目眾多1. Queue的數目 2. Queue之間的排班法則 3. 每個Queue自己的排班法則 4. Process被放入哪個Queue之Criteria ，有助於排班設計及效能調校之Flexibility\n不公平\n有Starvation(被放在Q3 的Process永世不得翻身，因為Process一旦被置入於某個Queue中，就不可(不允許)在不同ready queues之間移動☆☆☆☆☆\nPreemptive\nMultiLevel Feedback Queues(MFQs)(多層回饋佇列) 定義：與MultiLevel Queue相似，差別：允許Process 在不同Queues 之間移動，可採取類似Aging技術，甚至可以搭配降級的做法，來避免Starvation 分析： 可參數化的項目眾多1. Queue的數目 2. Queue之間的排班法則 3. 每個Queue自己的排班法則 4. Process被放入哪個Queue之Criteria 5.Process在不同佇列之間移動的規則，有助於排班設計及效能調校之Flexibility 不公平 不會有Starvation(被放在Q3 的Process永世不得翻身，因為Process一旦被置入於某個Queue中，就不可(不允許)在不同ready queues之間移動☆☆☆☆☆ Preemptive 小結 哪些是Non-preemptive法則\nAns. FIFO,SJF,SRTF, Non-preemptive priority\n哪些是No Starvation\nAns. FIFO, RR, MFQs\n哪些包含於(∊)關係是錯的\n​\tA. FIFO ∊ Priority\n​\tB. SJF ∊ Priority\n​\tC. FIFO ∊ RR\n​\tD. SJF ∊ RR\n​\tE. RR ∊ MFQs 是喔，MFQs的參數可以設定成一條Queue\n​\tAns. (D)\n補充 CPU Utilization計算 例1.\n假設採RR排班\nTime Quantum值= Q\nContext Switch Time = S\nProcess 平均執行每隔T時間會發出I/O-request, 求下列Case之CPU Utilization(cpu花在Process exec time / CPU **total time(process exec time + context switching time+ idle time)** )\n0 \u0026lt; S \u0026lt; T \u0026laquo;Q\n0\u0026lt;S\u0026lt;Q\u0026laquo;T\n​\t0\u0026lt;S=Q \u0026laquo;T\nQ非常小\n例2. [恐] (看不懂)\n10個I/O-Bound Tasks(很花I/O)\n1 個CPU-Bound Tasks(很花CPU)\nI/O-Bound task執行每隔1ms 發出 I/O-request，每個I/O-運作花10ms\nContext Switching Time = 0.1 ms, 求CPU utilization, 採RR法則\nQuantum = 1ms\nQuantum = 10ms\n​\t寫完之後會發現有個info沒有用到「每個I/O-運作花10ms 」，因為有CPU-Bound的存在，所以不存在idle Time，如果不存在CPU-Bound，則可能存在idle的情形，就需要考慮這種情形\n特殊系統之排班設計考量 Multiprocessors System Multiprocessors分為\nASMP(非對稱的，Master-slave架構) \u0026mdash;\u0026gt; 沒有什麼特殊設計，嘻嘻，因為只有Master這個CPU去看ready queue以及job的assign，所以其實沒啥特殊設計\nSMP(對稱式) \u0026mdash;\u0026gt;\n每個CPU共享同一條Ready Queue，當CPU完成某Process後，就去存取ready Queue，取走一個Process執行。設計重點：必須提供ready queue的互斥存取機制，若未提供，則可能發生Process重複執行或Process被ignored(無人執行)之錯誤。\n例如：CPU去取得Process之工作如下\n1. 取得(read) Ready Queue, Frond End的process之PCB Pointer 1. 刪除此Process Pointer from Queue\nCPU1 CPU2 T1: step1: 取得P1 PCB pointer T2:step1取得P1 PCB pointer T3: Dequeue執行 T4: Dequeue執行 設計重點：\n必須提供ready Queue的互斥存取機制 不須考量Load Balancing 每個CPU有自己的Ready Queue\n每個CPU只會檢查自己的ready Queue, 有工作就執行，無工作就idle\n設計重點：\n不須有互斥存取的考量，一旦發生idle，則把其他CPU的queue調整過來 需考量Load Balancing，避免有CPU沒事，有CPU很忙。通常使用兩種機制來調整CPU Loading Push migration(移轉) Pull migration(移轉) Processor affinity 定義：在multiprocessors system中，當process已決定某CPU上執行，則在他執行過程當中，盡量不要將之移轉到其他CPU上執行(除非有其必要，eg. processor BAD, load Balancing, etc)避免CPU內之cache等內容要複製，且刪除，影響到效能表現，可以有 Hard affinity：規定process不可移轉 Soft affinity：盡可能不轉，但不強制限制，若有需要還是可以轉 Real-Time System排班設計考量 Hard real-time system 排班設計考量\nStep\n先確定這些工作是否schedulable(可排程化，CPU可以負荷的了)\n確定可schedulable後，然後在考慮是否可以滿足各工作的DeadLine\n兩個排班法則\nRate-Montonic scheduling EDF(Earliest Deadline First)法則 Schedulable與否之判斷公式：\n例：有下列4個Real-time event. 其CPU burst time,Period Time 分別是：\nCPU Burst Time Period Time 20ms 80ms 50ms 100ms 30ms 30ms Xms 1Sec ，則在Schedulable要求下，x不可超過?ms\nAns\n怎麼排程以滿足個工作DeadLine after Schedulable?\nRate-Monotonic法則\n採取Static priority(一旦process的優先權高低順序訂定了，就不會再改變) 且 preemptive 法則\nPeriod Time愈小，優先權越高\n舉例\nProcess Period Time CPU time P1 50 20 P2 100 35 Q1. schedulable與否?\nQ2. 若規定P2的優先高，且preemptive, 這樣是否滿足DeadLine?這題感覺怪怪的，不懂\n​\tQ3. 採用Rate-Monotonic, 是否滿足Deadline?\n​\t分析：\n並不保證可以滿足DeadLine 在Static priority要求下，它是Optimal(若它無法滿足DeadLine,其他Static priority 法則也是無法滿足 EDF(Earliest Deadline First)\n定義：採用Dynamic priority 且Preemptive\n規定：DeadLine越小(早)優先權越高\n舉例：\nProcess Period CPU Time P1 50 25 P2 80 35 是否滿足Deadline?\nRate-Monotonic\nEDF\n分析：\nEDF保證是optimal in the schedulable case(任何工作都可以滿足 DeadLine) 理論上，CPU utilization 可達100%，但實際上不可能，因為有Context switching, interrupt handling 等額外負擔 Soft real-time system 定義：這個系統要確保real-time的process取得最高優先權，同時，這個real-time的process priority不能做衰減\n就CPU Scheduling Design 而言，必須\n支援preemptive-priority 不支援Aging技術 盡可能降低Kernel Dispatch latency time, 使得real-time process可以及早開工 降低kernel Dispatch latency\n困難度(緣由) ：大部分的OS，皆不允許當kernel正在執行System Call or 其他System processes時，被user process任意插隊(preemption)，目的是為了確保kernel Data Structures的正確性(即不要有Race Condition)，然而此種做法，對於Soft real-time system極為不利\neg. 假設目前kernel 正在執行一個Long-time system call(eg. I/O operation)，而此時real-time process到達/fork(),它必須等到kernel完成此long-time system call後，才能取得CPU，所以\nDispache latency太長，要解決此一問題，原則是: 必須插隊kernel 且要保障kernel Data Structure之正確性\n方法\nPreemption Point：\n定義：在此System calls code中，加入一些Preemption Point(在此時點插隊時，Kernel是安全的)將來，System call執行時若遇到Preemption Point ，System call會先暫停，Kernel會檢查此時是否還有real-time process存在/到達，若有，則Kernel system call暫停執行，CPU分派給real-time Process使用，若無，則System Call繼續執行，直到遇見下一個Preemption Point 缺點：System Call中可以加入的Preemption Point數目不夠多，因為Dispatch Latency仍然很長。 Kernel可隨時被real-time process插隊，但要對於Kernel的共享Data Structure/resoruce提供嚴謹的互斥存取(Synchronization 機制)，以確保資料之正確性(當P1對某個Data進行操作，執行到一半時被real-time process給搶走，此時會把該Data給Lock住，不讓real-time process操作該Data，以保護資料)\n缺點：可能造成Priority Inversion問題(優先權反轉)，高優先權的Process所須的共享Data/resources恰好被一些低優先權的Process把持，無法存取(所以互斥存取控制之故)，造成高優先權等待低優先權Process之情況(即高process要等低process釋放這些共享Data/resource)\n當高優先權的Process因為遲遲等不到Lock解除，會因為time-out的關係而放棄CPU，此時可能有其他中優先權的Process取得CPU的使用權，因此低優先權的Process完成不了，進而完成對共享Data/resources之使用進而Release, 所以高優先權process被迫要等一段很久的時間\n解決方法：Priority Inheritance\n定義：讓低優先權的Process暫時繼承高優先權之權值，使得低優先權Process可以很快取得CPU完成對共享Data/Resouce之使用，並release them. 同時，也立刻恢復其原本的低權值 Real-time system之Dispatch Latency 組成 Dispatch Latency有兩個phase組成\nConflict Phase： Preempts kernel 低優先權realse高優先權所需之Data/resource Dispatch Phase Context Switching Change mode to user Mode Jump Thread Management(貝多芬) Thread( or Multithreading)定義、優點\nProcess(Single-Threaded) vs Thread (Multithreading)\nuser-level thread 與 kernel-level thread\nMultithreading Model(3種)\nMultithreading issue\nfork()\nsignal delivery\nThreads pool\n程式追蹤(PThread library)\nThread 定義：又叫lightweight-process(傳統的process就叫heavyweight process)，是OS分配CPU time 之對象單位**(恐：It\u0026rsquo;s a basic unit of CPU Library)**\nThread 建立後，其私有的(private)內容組成包含有(都是與執行相關的)\nProgramming Counter CPU registers value Stack Thread ID, State, etc \u0026hellip;(Note: record in TCB[Thread Control Block])此外，同一個Process內不同之Threads彼此共享此Process的 Code Section(合稱Memory space, address space) Data Section(合稱Memory space, address space) other OS resources eg. open files, I/O resources ,singal, etc \u0026hellip; 圖示\nMultiThreading Model\nProcess = Single-Threaded Model\nNote: 類比\nProcess \u0026mdash;\u0026gt; 汽車\nThread \u0026mdash;\u0026gt; 引擎\n汽車會有一個引擎，也可以有很多，MutliThread就像是一部車子有多個引擎，然後共享車子有的配件(儀表板、方向盤等等)。CPU Time是以Thread為對象在畫分\n優點(Benefits)\nResponsiveness：當Process內執行中的Thread被Blocked，則CPU可以切給此Process內其他available Threads 執行，故整個Process不會被Blocked，仍持續Going, 所以Multithreading用在user-interactive application, 可增加對User 之回應程度 Resource Sharing：因為Process內之多條Threads 共享此Process code section，所以在同一個Memory space上可有多個工作同時執行 Economy：因為同一個Process內之不同Threads彼此共享此Process的memory 及 other OS resources, 因為Thread 之 私有成分量少，故Thread之Creation, Context Switching fast, Thread management cost is cheap(fork一個Process的成本遠大於複製一個Thread) Scalability(Utilization of Multiprocessors Architecture)：可以做到同一個Process內之不同Threads可以在不同CPUs上平行執行，所以可以增加對Multiprocessors System之效益(平行程度)提升 Process Vs Thread 其實是在比Singal Thread and MultiThread\nThread的的優點\nProcess Thread Heavyweight process Lightweight process Single-Threaded Model MultiThreading Model 是OS分配Resource之對象單位 是OS分配CPU Time之對象單位 不同的Process不會有共享的Memory及Other Resources (除了Shared Memory溝通之外) 同一個Process內之Threads彼此共享此Process之memory 及Other Resources 若Process內的single Thread is Blocked, 則整個Process亦Blocked 只要Process內尚有Available Thread可執行，則整個Process不會被Blocked Process之Creation context Switching慢，管理成本高 Thread快，成本低 對於MultiProcessors架構之效益發揮較差 較佳 Thread的的缺點\nProcess Thread Process無此議題(除非是採用Shared Memory溝通) 因為同一個Process內之Threads彼此共享此process Data Section，因此必須對共享的Data 提供互斥存取機制，防止race Condition Philosophy Process與Thread沒有功能差異，只有效能差異(你會的，我也可以，你不會的，我也不會)。\n哪些工作適合用MultiThreads?\nAns. 一個時間點有多個工作要執行。例：Client-server Model(同時有人過來要檔案，看檔案)\n哪些工作不適合用MultiThreads?\nAns. 一個時間點最多只有一個工作可以做。例：命令解譯器(eg. UNIX 之 Shell)\nThread分類：user-Thread與Kernel-Thread 區分角度：**Thread Management工作(如：Thread Creation, Destroy, Suspend, wakeup, Scheduling, Context Switching, etc)**由誰負責\nUser-Level Thread\n定義：Thread Management是由在User Site之Thread Library提供APIs, 供User Process呼叫使用，進而管理，稱之 Kernel 完全不知道(is Unaware of) Use-Level Threads 之存在Note：只知有Process(Singal-Threaded) Thread management不須Kernel介入干預**(kernel unware user-thread)** 優點：There creation, context switching 等，Management is fast 成本較低 缺點： 當Process內某條執行中的user-thread is blocked(eg. i/o)，會導致整個Process亦被Blocked(即使process內還有其他available threads)這個process都是user Thread，發出一個blocking的system call, kernel會認為是這個Single process發出的請求，因為kernel不知道process裡頭還有其他user Thread的存在，於是就把整個process block住，CPU切到其他process去執行 MultiProcessors架構效益發揮較差(因為無法做到process內之多條user-threads平行執行，但這樣也是有好處的，整個thread的管理不需要kernel的干預，不需要再user, kernel間切換，降低管理的成本) 例：舉凡Thread library皆是user-threads(eg. POSIX 的 PThread library是規格，只在UNIX系統上, Mach的C-Thread Library, Solaris2以上的 UI Thread Library及Green Thread Library). Kernel-Level Thread\n定義：Thread Management完全由kernel負責，Kernel知道每一條Thread之存在並進行管理\n優缺點與user-thread相反\n例：大部分OS皆支援 (Windos系列 etc. 2000, Xp, UNIX, LINUX, Solaris)\n舉例：[Module版]\nCPU Time依分配對象數，平均分配(10個人就分10%，20個人就分5%) 則Pa, Pb各分到?%CPU Time，if All Threads are User Thread：kernel只知道有兩個Process要來搶CPU，來分CPU Time，Pa,Pb各分50% Kernel Thread：kernel知道有5條Thread要分CPU time，1條分20%，Pa分到3條，所以是60%, Pb是40% MultiThreading Model [恐龍本獨有] 恐龍本用來詮釋user Thread跟Kernel Thread的見解\n[user thread mapping kernel thread的數目]\nMany-to-One Model One-to-One Model Many-to-Many Model Many-to-One 定義：This model maps many use threads to one kernel Thread. Thread Management is done in use space 優、缺點：如同user thread 例：thread library皆是 圖示： One-to-One Model 定義：This model maps each use Threads to a kernel Thread. Thread Management is done in use space 優點：同kernel thread 缺點： Slower Process每建立一條user-thread, system就必須配合生一條kernel thread與之，所以user thread數目眾多，系統負擔會很重，耗資源 例：Window NT, Window2000, OS/2, Linux(個人電腦系列幾乎都是ONE-TO-ONE) Many to Many 定義：This model maps many use Threads to a small or equal number of kernel Thread. Thread Management is done in use space 優點：同前述kernel thread, 負擔也不像one to one的model來的重 缺點：1. slower 2. 製作設計上，較為複雜 MultiThreading Issue 原本Single Thread沒這問題\nfork() issue Signal delivery(傳送) issue\nSignal：it is used in UNIX to notify(通知) the process that a particular event has occurred 當process收到signal通知後，它必須處理(可由process自己處理或交給default signal handler處理)\nSignal的種類\nSynchronous signal[自作自受，這件事情是由你這個Process發生的，所以Signal就是發給你]eg. Divide-by-zero, illegal memory access, Asynchronous signal[池魚之殃，事情不是你做的，但別人發出，卻是砍你] eg. ctrl-c by administrator, time-out by timer Signal Delivery issue\n4個options\n發給那個thread 發給大家\n發給一些threads\n發給一個thread，這個thread再把signal轉派給大家\nThreads Pool\n緣由：在Client-Server Model中，當Server 收到Client\u0026rsquo;s request後，Server才建立Thread去服務此一請求，然而Thread creation 仍須耗用一些時間，所以對client 之回應不是那麼迅速 解法：採用Thread pool機制，process(server)先建立一些Threads，置於threads pool中，當收到Client\u0026rsquo;s request後，就從Thread pool中指派一條 available thread去服務此請求，不須creation回應較fast，當此Thread 完成工作以後，再回到Threads pool中Stand By 如果Threads Pool中無可用的Threads，則Client\u0026rsquo;s request 須等待 缺點： 萬一Process事先生出過多的Threads in the Thread pool, 對System resource耗用很高，Note:通常ＯＳ會限制Threads pool size Thread程式追蹤 (以PThread library為例)\n例：P4-49\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;Pthread.h\u0026gt; int sum; void *runner (void * param){ sum =0; for(int i=1;i\u0026lt;=upper;i++){ sum+= i; Pthread-exit(0); //thraed終止 } }; main(){ Pthread-t tid; //tid就代表Thread的id Pthread-attr_t arrt; //代表attribute屬性 Thread attributes set ... Pthread-attr-init(\u0026amp;attr) ;//取得attr 初始值 ★Pthread-create(\u0026amp;tid, \u0026amp;attr, runner, argv[1]); //根據attr 屬性值建立一條Thread，Id記在tid中，執行runner()副程式 Pthread-join(tid, NULL); //main() thread 在此等待，直到tid thread結束 printf(sum); } 例：P4-50 程式二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int value = 0; void main(){ int pid ; pthread-t tid; Pthread_arrt_t attr; pid = fork(); //create child process if(pid==0){ //子prcess要做的事情 pthread_create(\u0026amp;tid, \u0026amp;attr , runner,NULL); //子Process去create一條thread printf(value); //line C }else if(pid \u0026gt; 0){ wait(); printf(value); //line P } } void *runner(){ value =5; pthread_exit(); } 例 p4-70\n1 2 3 4 5 6 7 8 9 10 11 shared by threads A. static local variables(共享) B. program text/exec, binary (code sec)共享 C. register value of CPU(私有) D. heap memory (code+ Data sec memory space)共享 E. Programming Counter (私有) F. Stack memory(私有) G. Open Files(共享) H. I/O resources(共享) I. local variable(私有) J. Global variables(共享) Chapter 5 DeadLock 定義：成立的四個必要條件，例子, 與Starvation做比較\nDeadlock的處理方法\nDeadlock Prevention ★★★★ Deadlock Avoidance(Banker\u0026rsquo;s Algo★★★★★) Deadlock Detection and Recovery★★ Ignores it . 定理★★★★★：\n相關圖形\nResource Allocation Graph(RAG)+3點結論★★★★★\nClaim edgy+RAG(for Avoidance)\nwait for Graph(for Detection)★\nDeadLock 定義：系統中存在一組Processes彼此形成循環等待之情況，造成這些Processes皆無法往下執行(和starvation不同，Starvation還有一絲可能會做到)，並降低Throughput之現象。\n死結成立的4個必要條件(4 necessary condition)，即缺一個，死結就不會發生. Ex. if there 4 conditions are true, then the deadlock will arise. Ans. False，都有不代表一定會發生\nMutual Exclusion\n互斥性質，這是對Resource(正在搶奪的資源)而言，具有此性質的Resouce，在任何時間點最多只允許一個Process持有使用，不可多個process同時持有/使用。\n例：大多數的資源皆具此性質，eg. CPU, Memory, Disk, printer, etc \u0026hellip;\n例：read-only file：不具互斥性質\nHold \u0026amp; wait\n持有並等待，Process持有部分資源，且又在等待其他Process持有的資源\nNo preemption\n不可搶奪，**Process不可以任意剝奪其他Process所持有的資源，**必須等到對方釋放資源後才有機會取得資源若可Preemption，則必無DeadLock，頂多只有Starvation\nCircular Waiting\n循環等待，系統中存在一組Processes形成循環等待之情況，eg.\n恐龍本：4 implies 2\n其他版本：4 implies 1,2,3eeeee\nex. Why Singl-process不會造成DeadLock?\nA：因為Circular waiting 不存在，只少要有兩個process才可以形成循環等待，因此四個必要條件有一個不符合，即不會造成DeadLock\n例子：\n與Starvatiom比較\n不同點：\nDeadLock Starvation 一組Processes形成Circular waiting，造成這些Processes皆無法往下執行，Waiting forever Process因為長期無法取得完工所需的各式資源，造成它遲遲無法完工，有完工的機會喔，只是機會渺茫 會連帶造成throughput低落 與throughput高低無關 有4個必要條件，其中一定是No preemptive 容易發生在Preemption的環境(沒有一定，只是容易) 解法有prevention, Avoidance, Detection \u0026amp; recovery 採用Aging技術防止 相同點：\nDeadLock 7 Starvation 皆是資源分配管理機制設計不恰當相關。 Resource Allocation Graph(R.A.G) 資源分配圖\n定義：令Ｇ=\u0026lt;V,E\u0026gt; 有向圖代表RAG，其中\nVertex(頂點)：有兩個類型：\nProcess：以O來表示\nResource：以表示\n其中\u0026rdquo;·\u0026ldquo;數目代表The Number of instances\nEdge(邊)：分為２種edge：\nAllocation Edge： Requset Edge： 例子 ：\nRAG的三點結論☆☆☆☆☆必考 No Cycle則No DeadLock 有Cycle不一定有死結 例：因為P3一定可以完工，會釋放1個R2, 可佩給P2，此時圖無Cycle，No DeadLock 除非(若)每一類型的資源，皆為Single instance(單一數量)，則有Cycle必為死結 DeadLock處理方式 DeadLock Prevention DeadLock Avoidance(避免) Banker\u0026rsquo;s Algo DeadLock Detection \u0026amp; Recovery 1.2\n優點：\n保證System is Deadlock free (or never enters the deadlock state) 缺點：\n對Resource的使用/取得限制多，因為resource utilization 偏低，連帶throughput 也偏低 可能造成Starvation 3\n優點： Resources utilization相對較高. throughput也連帶較高 缺點： System有可能進入DeadLock state Detection \u0026amp; Recovery之cost相當高 DeadLock Prevention 原則：破除4個必要條件之其中一個，則死結必不發生 破除 \u0026ldquo;Mutual Exclusion\u0026rdquo; -\u0026gt; 兩個字「辦不到」！因為這是Resource與生俱來(inheritance)的性質\n破除 \u0026ldquo;Hold \u0026amp; wait \u0026quot; - \u0026gt; 兩個方法(protocols)可用，想辦法讓Hold不成立，或是讓Wait不成立\nOS實施規定：除非Process可一次取得全部所需資源，才准許持有資源，否則不得持有任何資源，但這樣子會有資源利用度低的問題(明明可用，但卻要等到全部都可以用才可以使用) OS實施規定：Process可先持有部分資源，但當Process要申請其他資源時，必須Release持有的全部資源(不再Hold)，才可提出申請。但資源利用率一樣很低，因為有可能會把即將要使用的資源釋放出去 破除\u0026quot;No preemption\u0026rdquo;　-\u0026gt; 改為\u0026quot;preemption\u0026rdquo; 即可, eg. based on priority-level\n☆☆☆☆☆破除\u0026quot;Circular waiting\u0026quot; -\u0026gt; 方法叫做\u0026quot;resource ordering\u0026quot; ，\nOS會賦予每一個類型資源一個Unique(唯一的)Resource id\nOS會規定Process必須按照Resource Id Ascending(遞增、遞減都行，你爽就好)的方式對資源提出申請\n持有的 欲申請的 允許或不允許 R1 R3 允許 R5 R3 必須先放到R5，才可提R3(因為不符合遞增) R1,R5 R3 必須先放到R5，才可提R3(因為不符合遞增) WHY?\npf：假設在這樣的規定下，系統仍存在一組Processes形成Circular waiting如下\n依規定，我們可以推導出資源ID大小關係如下\nr0 \u0026lt; r1 \u0026lt; r2 \u0026lt; \u0026hellip; \u0026lt;rn \u0026lt; r0\n竟推出 r0 \u0026lt;r此一矛盾式子，因此Circular waiting必不存在\nDeadlock Avoidance 定義：當某個Process提出某些資源申請時，則OS必須執行Banker\u0026rsquo;s Algorithm，以確定倘若分配給process其申請資源後，System未來處於safe state，若Safe則核准其申請，否則(unsage)則否決其申請，process必須等一段時間後，再重提申請。\nDeadlock是unsafe之subset\nBanker\u0026rsquo;s Algo ☆☆☆☆☆ 本章的計算題都在這 Banker's Alog and Safety Algo\n定義：使用的Data Structures\n看不懂的話直接看下面範例比較快\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 假設 n：process個數 m: resource種類數 1. Request i ：［1..m］of int -\u0026gt; Pi提出之各式資源申請量 2. Allocation : n*m martrix -\u0026gt; 各個process目前持有的各式資源數量 3. MAX: n*m martrix -\u0026gt; 各process完工所需之各式資源最大數量 4. Need：n*m martrix(自己算) -\u0026gt; 各process尚須(欠)各式資源數量才能完工，因此Need= MAX -Allocation 5. Avaliable：[1..m]of int -\u0026gt; 系統目前可用的，各式資源數量，因此Available=資源總量-Allocation 舉例說明：假設有人來貸款3,000萬，那麼Requesti =3000萬、Allocation就是自己的存款，假設這邊是2,000萬，想買一棟9,000萬的房子，這9,000萬就是他的MAX，那麼Need= 9,000-2,000= 7,000萬，Available 就是銀行目前金庫裡能借給你的錢，這邊假設是10,000萬。 Step1. Check Request \u0026lt;= Need ?若成立，則往下執行，若不成立，則終止Process。 Request=3,000萬，Need= 7,000萬。這樣就是合理的，但假設你今天需求7,000萬，可是卻貸了3,000兆，遠超於你的需求，那就有問題了 Step2. Check Request \u0026lt;=Available?若成立，則往下執行，若不成立，則Pi waits until resouce availalbe 概念就是你去貸3,000萬，可是銀行金庫目前的錢不夠，需要你稍等一下 Step3 (試算) 假設貸款成功 Allocation = Allocation + Request Need = Need - Request Available = Available - Request Step4 依上述試算值，必須執行 \u0026#34;safety\u0026#34; algo，若回傳\u0026#34;Safe\u0026#34; state則核准Pi此次申請。若回傳\u0026#34;unsafe\u0026#34; state，則否決Pi此次申請。Pi必須等一段時間再重提申請 Safety Algorithm Data Structures used 除上述之外，另外加入\nWork:[1..m] of int -\u0026gt; 表系統目前可用Resources之累計數量\nFinish:[1..m] of Boolean -\u0026gt; 針對Process\nFinish[i]=\nTrue: 表Pi可完工\nFalse: 表Pi尚未完工\n∀1\u0026lt;=i\u0026lt;=n\nProcedures\nStep\n設定初值\nWork = Available\nFinish[i]皆為False\n∀1\u0026lt;=i\u0026lt;=n\n看可否找到Pi滿足：\nFinish[i]為False且 Needi \u0026lt;= Work (我所需要的資源，) 若可找到，則進3,否則則進4\n設定Finish[i]=True，且Work= Work + Allocationi, then, 回到2\nCheck Finish Array, 若皆為True，則傳回Safe State，否則傳回Unsafe state\n範例\n1 2 3 4 5 6 5個Process(P0,P1,P2,P3,P4) 3種resource(A,B,C) 資源量(A,B,C) = (10,5,7) 1. 求出Need及Available 2. P1提出(A,B,C)= (1,0,2)申請，是否核准?Why? Ans.\nAllocation-各個Process身上所持有的資源 A B C P0 0 1 0 P1 2 0 0 P2 3 0 2 P3 2 1 1 P4 0 0 2 MAX- Process完成工作最多所需要的資源數量分別是多少 A B C P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Need= MAX-Allocation A B C P0 7-0=7 5-1=4 3-0=3 P1 3-2=1 2-0=2 2-0=2 P2 6 0 0 P3 0 1 1 P4 4 3 1 Available= 系統目前還剩的可用資源數，資源總量()-已經配置出去的(Allocation出去的) A B C 10-(2+3+2)=3 5-(1+1)=3 7-(2+1+2)=2 Request=(1,0,2), Banker\u0026rsquo;s Algo\nCheck Request \u0026lt;= Need ? (你所要求的小於你真正需要的，亦即你買東西只要500，不能跟銀行借到500萬)\nCheck Request \u0026lt;= Available (你要的借的錢是否小於銀行本身所持有的錢，亦即如果你要借1億，但銀行只有一百萬)?\n(試算)\nP1:\nAllocation = \u0026lt;2,0,0\u0026gt;+\u0026lt;1,0,2\u0026gt;(申請量) = \u0026lt;3,0,2\u0026gt;\nNeed = \u0026lt;1,2,2\u0026gt; - \u0026lt; 1,0,2\u0026gt;(申請量) = \u0026lt;0,2,0\u0026gt;\nAvailable = \u0026lt;3,3,2\u0026gt; - \u0026lt;1,0,2\u0026gt;(申請量) = \u0026lt;2,3,0\u0026gt;\n依上述調整值，來執行\u0026quot;Safety\u0026quot; Algo\nAllocation A B C P0 0 1 0 P1(要調整) 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 MAX A B C P0 7 5 3 P1 3 2 2 P2 9 0 2 P3 2 2 2 P4 4 3 3 Need A B C P0 7 4 3 P1(要調整) 0 2 0 P2 6 0 0 P3 0 1 1 P4 4 3 1 Available A B C 2 3 0 Safety Algo\n初值的設定\nWork = Abailable = \u0026lt;2,3,0\u0026gt;\nFinish\n0 1 2 3 4 F F F F F 尋找有沒有Process還沒完成工作，並且它的needi \u0026lt;= work的\n可找到P1滿足Finish[i]= False且Need \u0026lt;=work\n​\t設定Finish[i]=True，且Work= Work+Allocation = (2,3,0) + (3,0,2) = (5,3,2) , then goto 2 work = (2,3,0) \u0026gt; (5,3,2) ​\t選擇P3滿足 Need\u0026lt;= Work，且Finish[i] = False\n設定Finishj[3]=True，且Work=(5,3,2) +(2,1,1) = (7,4,3), then goto 2\n\u0026hellip; 以此類推，P0, P2, P4皆可Finish，直到大家都Finish，因此大家都滿足了。\nCheck Finish陣列，因為皆為True，所以傳回Safe State，因此核准P1此次的申請\n列出上述其中一組Safe SequenceSafe Sequence/ Safe State定義：至少可以找到\u0026gt;=1組，Safe Sequence，成為Safe State，否則unsafe state。代表OS未來依此Processes順序可分配各Process所need的資源，使得大家皆可順利完工\nAns. P1,P3,P0,P2,P4\n依現在狀況，若P4提出(3,3,0)申請，是否核准?why? (練習題)\nAns. Banker\u0026rsquo;s algo\nCheck Request (3,3,0) \u0026lt;= Need(4,3,1) 通過\nNeed A B C P0 7 4 3 P1 0 2 0 P2 6 0 0 P3 0 1 1 P4 4 3 1 ​\t2. Check Request4(3,3,0) \u0026lt;= Available (2,3,0)?\n​\t不成立，因為無法核准，可用資源不足\n依現在情況，若P0提出(0,2,0)，是否核准? Ｗhy?\nAns. Banker\u0026rsquo;s Algo\n快速跑過，確認可以過，資源分配改變如下\nAllocation\nA B C P0 0 3 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 2 2 Need\nA B C P0 7 2 3 P1 0 2 0 P2 6 0 0 P3` 0 1 1 P4 4 3 1 Available\nA B C 2 1 0 執行Safety\u0026rsquo;s algo\n設定初值，Work=(2,1,0) 找尋是否有符合Needi \u0026lt;= Work 的Process，且還有Process為False**(不通過)**，所以unsafe 範例二\nAllocation\nA B C P0 0 3 0 P1 3 0 2 P2 3 0 2 P3 2 1 1 P4 0 0 2 Need\nA B C P0 7 2 3 P1 0 2 0 P2 6 0 0 P3 0 1 1 P4 4 3 1 Available\nA B C 2 1 x 求x的最小值，使其成為Safety\n設置初值，work= (2,1,x) 找尋 Need \u0026lt;= work 找到了，P3，先暫定x=1 (2,1,1) P3因為可以完成，完成後資源就可以釋放出來，因此work (2,1,1) \u0026gt; (4,2,2) 繼續找尋Need \u0026lt;=work 找到了，P1 P1因為可以完成，完成後資源就可以釋放出來，因此work(4,2,2) \u0026gt; (7,2,4) \u0026hellip;往復循環，以此類推 ​\nx= 1;\nBanker\u0026rsquo;s Algo 之 Time Complexity 先講結論，複雜度就是O(n^2*m)\n(n: Process 數目, m:resource 種類數)\nBanker\u0026rsquo;s Algo Time Complexity\nStep\nO(m)Check Request \u0026lt;= Need O(m) Check Request \u0026lt;=Available O(m)試算 Run safety algo 設置初值work -\u0026gt; 1~m的一維陣列，因此複雜度為O(m)。Finish -\u0026gt;1~n的一維陣列，因此複雜度為 O(n) 先來看看Safety\u0026rsquo;s algo的步驟 ​\t第一次最多會檢查n次，再來第二次檢查n-1次\u0026hellip;\n​\t=(n+1)n/2個Processes。每次檢查Need \u0026lt;=Work 花O(m)的時\t間，最多花O(n^2*m) time\n花O(n) Check Finish 因此複雜度就是O(n^2*m)\n針對每一項類型資源，皆為Single-instance情況下，有較簡易的Avoidance作法 利用RAG，搭配Claim edge(宣告邊)使用\nClaim edge:\n代表Pi未來會對Rj提出申請(即表MAX/NEED之意義)\nSteps：\n當Pi提出Rj申請後\n檢查有無Pi對Rj的這條宣告邊(Claim edge)存在，若有，則goto2否則，終止Pi\nCheck Rj是否Available，若是，則goto3，否則Pi waits(變成申請邊)\n(試算)暫時把宣告邊改為配置邊\n執行safety\u0026rsquo;s Algo, check 圖中是否有cycle存在\n若沒有，則為safe -\u0026gt; 可核准\n有Cycle，則為unsafe -\u0026gt; 否決\n例：\n若P1提出R2之申請，是否核准?\nAns.\n若P2提出R2之申請，是否核准?\n補充：Deadlock是unsafe之subset(或unsafe有可能導致死結，也有可能不會導致死結)\n可能不會死結\nans. 搞不好P1在提出R2的申請時，就使用完R1了，這時就不會有死結。或是P2在P1提出申請之前就使用完R2了，此時也不會有死結。\n可能會有死結\nans. P1立刻對R2提出申請，此時RAG有Cycle，且資源都是Single Instance\n也就是說死結產生與否取決於宣告邊在哪個moment提出申請\n​\n定理 系統若有n個processes，m個resource量(單一種類)滿足下列2個條件：\n1≦MAXi≦m(每個process的最大需求量至少要有1個，最多不超過m)\n且所有n個process的Maxi加總，小於n+m\n$$ \\sum_{i=1}^nMAXi\u0026lt;(n+m) $$\n則System is Deadlock free.\n例1. 有6部printers被process使用，每個process最多需要2部printers才可以完工，則System 最多允許?個process執行以確保deadlock Free?\nans. m=6, Max=2\n開始跑定理\n1 ≦ Maxi ≦ m -\u0026gt; 1 ≦ 2 ≦ 6成立\n$$ \\sum_{i=1}^nMaxi\u0026lt;(n+m) $$\n​\t所以2n\u0026lt;n+6，n\u0026lt;6，Ans:　最多５個processes\n​\nProcess Co ncept 第一節 總覽 第一章 序言 第二章 Operating-System Strucutures(作業系統架構)★ OS Service 透過System Code去呼叫這些Service\nOS-Application Interface(最重要的) System call (使用組合語言撰寫) Operating System本身就是一個提供Service的Software，提供Process conmtrol, FIle management, Device management, Information maintenance, Communications。而System Call則是OS的Interface，透過System Call去進行Software的Interrupt。\nAPI 由於System call是使用組合語言來寫的，較不貼近人類，因此在多加一層API，來調用System call。這些API有些會使用到多個System Call，有些則連一個System Call都沒有，因為API本身就只是為了方面Programing，提供一個Interface去調用更底層的System call\nSystem Call傳送參數的三種方式\n透過Rigisters 透過Pointer 透過Stack Simple OS Architecture MS-DOS device driver和ROM BIOS device driver其實都是Driver，大部分的東西都還是塞在Resident system program裡面，也就是沒再分。\nLayer Os Architecture 基於Simple OS Architecture對於維護上的不便（所有東西都寫在一起），所以有人提出了分層的概念，在kerel依照subsystem的概念去劃分各個職責。外層的layer可以call裡面的layer，裡面的layer不能call外面的layer，概念有點像Mvc架構，這樣方便工程師去維護，但相對的也會帶來一些困難，比如說效能降低，因為需要由外面一層一層呼叫，因此效能會降低。另一方面，要去定義各個Layer也不是一件容易的事情。\nMicrokernel OS kernel的程式碼應該要越少越好，越少越小代表越Reliable。\n引入Modularize的概念，把Subsystem變成各種modular，中間的kernel是負責去溝通各種不同的Modular。\nkernel只負責去溝通和定義，但因為這個架構的每一個subsystem要溝通都要透過kernel，去interrupt它，效能又會在更低\nModular OS Structure 現在常見的作業系統大部分都遵循這個架構（linux），有點像OO的概念，把功能寫成各個在kernel裡面的Subsystem，可以去這張投影片下面的網址，會手把手教你怎麼撰寫kernel\nhttps://youtu.be/7pAiJeldUfk?t=700\n可以多看幾次。\ncritical instruction：一個instruction在user mode跟kernel mode執行的結果會不一樣，比如說user mode可能是a+b，但在kernel mode執行的結果是a+b+b\nVM的好處\n隔離各個使用著，保護system resouce 透過VM，可以在一台電腦因應不同的程式需求，建立不同的VM（window 98，windowXP） 幫助R\u0026amp;D測試開發， VM的技術\nFull Virtualization 一個guest的作業系統，可以不用做任何修改就可以直接安裝在一個作業系統，VM不知道自己是個VM，以為自己就是一個完整的作業系統\nPara-virtualization 會有一個Global zone，負責去調度、協調各個VM，Guest的作業系統需要被修改\nJava Virtual Machine 第二節 Process Management (進程管理) 第三章 Processes (進程) Process Management \u0026amp; Thread Management Process 定義與Progeam比較\nPCB內容 考試重點\nProcess State Transition Diagram (S.T.D)考試重點\nScheduler的種類(解釋名詞)\n長期\n短期\n中期\nContext Switching (解釋名詞)\nDispatcher, Dispatch latency(較少考)\nProcess Controller Operations(UNIX, System Call為主的程式追蹤) 考試重點\n評估CPU Scheduling 效能的好或不好的5個Criteria(清大喜歡考)\n各種CPU 排班法則(7個)介紹及相關名詞(Starvation,Aging,Preemptive,Non-preemptive,Convoy effect) 考試重點\n特定System的排班設計\nMultiProcessors System\nReal-time System\nSoft (考申論題)\nHard(考計算題)\nThread Management\nProcess 定義：A program in execution[恐]\nProcess 建立後，其主要組成有： Process No(ID): Process被生成出來時，會有一個Process Id，作為識別 Process State Code Section, Data Section：Process占用的 Memory Space Programming Counter(PC)：程式計數器，告訴我們現在這個Process執行到哪裡，裡面放下一條指令的位址 Stack CPU Register value 是OS 分配 **Resource(CPU,I/O-Divice, Memory) **之對象單位：跟Thread的差別 與Program(程式)的比較 Process Program 執行中的程式 Just a File stored in storage device \u0026ldquo;Active\u0026rdquo; entity(活動中、執行中) \u0026ldquo;Passive\u0026rdquo; entity(沒有活動的) Process Control Block (PCB內容)\n定義：OS為了管理所有Processes，會在Kernel memory中，替每個Process，各自準備一個Block(Table, 表格)，用來記錄Process之所有相關資訊\nPCB的主要內容有：\nProcess\nProcess Concept Program：被動的，可被執行的程式就叫Program，存在硬碟裡面 Process：主動的，一個程式正在執行就叫Process，是存在Memory裡面 code segment：把程式碼放到memory裡面的動作\nData section：globla variable存放的區域\nStack：區域變數及function存放的地方\nHeap：(待補)\n又稱做Lightweight process，是CPU的最小執行單位，它跟Process有八成像，Process可以被拆分成很多個Thread，許多Thread可以共用同一塊Memory Space。\n同一個Process下面的Thread，它的Code section，Data section，OS resource ，這三塊的memory空間是共用的。\n管理Thread的方式跟管理Process的方式都大同小異，區別不大，像Linux就沒有Process的概念。都只有Thread而已，當一個Process被執行起來時，會有下面這五個狀態\nNew：當這個Process被created出來，把Program load 進 Memory裡面，然後initialization。 Ready：把Process放進一個quoue裡面，等著被OS排程，放進CPU做使用。 Running：送instructions到CPU裡面做使用 Ｗating：有些instruction不需要CPU來做，例如IO，而等待其他事件執行完畢的這個過程就叫wating Terminated：釋放資源，把資源給其他的Process 管理Process的方式，就是會為每一個Process去建立一個Process Control Block，在Memory裡面紀錄這些Information，在Ready狀態的意思，就是只把PCB放進quoue的動作，這個PCB會存放下列資訊。\nProcess State\nProgram counter（CPU中的Register，用於指示電腦在其程式序列中的位置）\nCPU Register（CPU中，用來暫存指令、數據和記憶體位址的電腦記憶體，暫存器的容量有限，但讀寫速度快的飛起）\nCPU Scheduling Information\nMemory-management information\nI/O status information\nAccounting Information\n+++\nCPU被interrupt之後，把CPU上執行的Process切換成另一個Process的動作，就叫Context Switch，實際上就是在做PCB的Save還有Load的動作。\nContext Switch是一個overhead（浪費）的行為，但卻無可避免，因為我們要Share CPU 給所有的Process。\n提升Context Switch的速度有幾種方式\n提升momory的速度 減少Register的數量，數量減少了，需要存儲的資料也少了，但這件事情在現代很難做到 上面兩種都不是主流的方式\nHardware Support，有好幾個set的Register，可以在hardware裡面紀錄好幾個程式的狀態，所以在做Context Switch的時候，只是從一個Register切換到另一個Register，減少對memory的access Process Scheduling Process 也能產生 Process （parent跟child）\nCPU的數量很少，可能只有個位數或十幾個，但在Memory要執行的程式卻很多(multiProgram)，因此需要Scheduler，有分為三種Scheduler\nShort-term**(CPU Scheduler)**：選擇哪個Process要被執行，以及分配CPU Long-term**(Job Scheduler)**：決定哪些Processes能被Load進Memory，以及進入queue等待 Medium-term：決定哪個Processes被丟回Memory（從Ready state 變成 Wait state） Long-Term Scheduler 控制 degree of multiprogramming：目前電腦上有幾個程式在Memory裡面\n執行的頻率相較Short-term來講較低（只在process離開系統，或是每隔幾分鐘執行一次）\n選擇什麼Processes也很重要，因為我們希望CPU跟I/O可以overlap，不要完全偏向CPU或是I/O，而讓另一方沒事情做。\n在現在的OS裡面，因為Memory已經足夠，因此Job Schduler的功能逐漸淡化，直接先load進memory再說，\nShort-Term Scheduler 頻率極短(100ms) 要非常有效率 Medium-Term Scheduler 負責在DisK及Memory之間切換的Scheduler\nSwap Out：把Processes移出記憶體\nSwap In：把Processes移入記憶體\n每個Processor都有自己的ID(Processor identifier pid)，整台電腦一開始在執行的時候只會有一個Process，這個Process再去Create其他的Process\n這個指令可以列出所有啟動的Processes 1 ps-ael Process Creation Parent和Child雖然是兩隻不一樣的程式，但還是有某種程度上的關聯，這個關聯性的定義，分成下面三個比較重要的部分，這個關聯性是由OS的設計者去決定的\nResource Sharing之間的關聯性\nParent跟Child分享所有資源 Global共享，但Dynamic的不共享 全部都不分享 Processes執行的順序，當Child被創建後，哪個Process有優先執行的權力\n讓OS自己來決定 Chidren擁有較高的執行權 Process Address Space的狀態\nChild複製Parent的過去（連Code Counter，程式執行到哪一行都會複製過去，比如說Parent執行到第三行，那複製過去的Child就會從第三開始啟動。行為都一樣，但Address會不一樣）\nChild重新去Load Parent的程式碼。\nUNIX/Linux Process Creation fork system Call\n創建新的Child Process 是用複製(duplicates)的方式創建的 執行無先後順序之分 Fork的這個Code也是個System code，會return 一個 value，return的value會是它children的PID，若底下無children則return 0 （父母一定知道小孩是誰，但小孩不一定知道父母是誰） execlp system call\nParent跟Child是dupulicate，裡面的內容完完全全一模一樣，但今天create 一個新的process的目的不是為了做同樣的事情，因此execlp這個system call的目的，就是塞一個binary file（也就是program），就會把把child的process全部清空。**那為什麼不直接創造一個新的process？**因為需要跟OS註冊一個PID wait system call\n因為執行順序是concurrently，因此需要用wait來做順序的控制 這只是UNIX系統對Process的策略，不代表所有，實際還是要參照[Process Creation](# Process Creation)\n從A複製一份到A\u0026rsquo;s child，之所以A\u0026rsquo;s child會比較小的原因，主要是因為，如果是完整複製的話，其實大小是會一樣的，父Process有100 MB，子Process 就會有100MB，但這樣的事情很沒意義，因此現在會採用Copy-on-write，保存重要的資訊就好，其他的就不複製過去，比如說code counter，或是Local Variable都沒有變的話，則子Process會用一個Pointer指到父Process，但如果Runtime後發現不一樣，OS才真的會複製一份到子process。\n恩，這邊不太清楚，要再回頭看 不懂\nInterprocess Communication(IPC) 在OS的世界裡，有時候Process跟Thread是不分的\nIPC：不同或相同的Process裡面的thread要互相溝通 讀投影片就是完整的筆記了\n溝通的方式有兩種\nShared Memory\n有一塊Memoryd空間是share的，兩個人都可以用pointer去access它(會有synchronization的問題)\nMessage Passing\n​ 跨電腦的訊息溝通是Message Passing\n資料量小的話用Shared memory，資料量大的話用Message passing（避免synchronization問題），\n如何Message Passing呢？\nSocket：透過IP和Port來辨認使用者，Port Number(8080,5432)就是Process\nProcess ID是一個Process獨一無二的ID，用來辨認不同Process\nPort Number是作為網路連線的一部分\nSocket是個比較low level的傳遞方式，只能傳遞stream of bytes。\nRemote Procedure Calls\nShared Memory 完全看不懂\nMessage Passing 使用Memory copy的方式，溝通的方式有一點像打電話，有一個人要打電話(Send)另一個人要接電話(Receive)，訊息才可以交流，這一部分也隱含了同步化的操作，意即Message Passing雖然速度比較慢，但它其實幫你做了同步化這件事情。\n為了要溝通，所以需要先建立一個communication link，並提供一個Send跟receive的function code，實作一個communication link有分成physical跟logical兩個部分\nPhysical\n例如Shared memory, HW bus 或是 network的部分\nLogical(Program 在乎的事情)\n溝通的方向性(單向還是雙向)\nsymmetric and asymmetric 對稱與非對稱\nBlocking or non-blocking\nblocking：呼叫一個function，除非這個function全部做完才會做下一件事情，循序漸進的方法去執行程式\nNon-Blocking：呼叫一個function，如果有資料就回傳資料，如果沒有資料回傳就會得到一個Error，並執行下一個程式（大概啦）\n參考資料：淺談I/O Model\n\u0026hellip;. 參閱上面投影片\n傳遞訊息的時候，不是把訊息直接傳給一個人，而是放到一個Mail Box裡面，想要這個message的人自己到mailbox裡面拿，這種不知道雙方是誰的Communication就叫做indirect communication\nMailBox所遇到的問題\n如果很多人同時連線到MailBox該怎麼辦?\n解決方案\n限制這個communication只能有兩個人同時使用\n同一時間只能有一個Receiver\nMailBox不做限制，要幾個人來都可以，但當有人同時Access的時候，會有其中一方先被Delay Synchronization 不懂，Buffer是啥\nMessage在傳遞的時候一定是blocking或是non-blocking的狀態，要特別注意，Blcoking Send 不一定要對到Blocking Receive，它們之間沒有相對關係\nBlocking NonBlock Send 在Message被收到之前，Sender都是被blocked住的 Sender送出Messager，不管有沒有人收到訊息，都直接去做自己的事 Receive Receiver被blocked住，直到收到訊息 Receiver收到一個valid Message或null(因為是nonBlock) Sockets Accept之後會產生一個thread，所以這整體是一個MultiThread的架構\nRemote Procedure Calls：RPC 第四章 Thread \u0026amp; Concurrency (執行序與併發) 第五章 CPU Scheduling (CPU 行程) 第三節 Process Synchronization (進程同步) 第六章 Synchronization Tools (同步工具) 第七章 Synchronization Examples (同步範例) 第八章 Deadlocks(死鎖) 第四節 Memory Management(記憶體管理) 第九章 Main Memory(主記憶體) 第十章 Virtual Memory(虛擬記憶體) 第五節 Storage Management(儲存空間管理) 第十一章 Mass-Storage Structure (大型儲存架構) 第十二章 I/O System (輸入/輸出系統) 第六節 File System (檔案系統) 第十三章 File-System Interface (檔案系統介面) 第十四章 File-System Implementation (檔案系統實作) 第十五章 File-System Internals (檔案系統內部) 第七節 Security And Protected (安全性及保護) 第十六章 Security 安全性 第十七章 Protection 保護 第八節 Advenced Topics (進階主題) 第十八章 Vitual Machines (虛擬機) 第十九章 Networds and Distributed Systems (網路與分配系統) 第九節 Case Studies (案例學習) 第二十章 The Linux System (Linux系統) 第二十一章 Windows(Windows) 第十節 Appendices (附錄) 附錄A Influential Operating System (有影響力的作業系統) 附錄B Windows(Windows) 附錄C BSD UNIX 附錄D The Mach System 附錄A Influential Operating System (有影響力的作業系統) 附錄B Windows(Windows) 附錄C BSD UNIX 附錄D The Mach System ","date":"2022-10-08T03:02:43+08:00","image":"https://i.imgur.com/HJLk11O.png","permalink":"https://hoxtonhsu.com/p/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98/","title":"作業系統筆記"},{"content":"最近領到薪水後買了TYPORA後，想找如何上傳圖片的教學，發現網路上的教學蠻少的，台灣好像只有一篇，還是For mac的教學，剩下的都是中國的教學，但他們用的圖床，台灣也很多不能用，後來研究了幾天終於搞懂，所以決定寫一篇看看\n圖片空間有Github跟imgur，就看你想要用哪個就用哪個吧，其實沒差太多，但imgur會稍微簡單一點點點點點點，以下是步驟\n開始 先去安裝node.js，因為會需要裡面的npm https://nodejs.org/en/download/\n安裝好可以用系統管理員身分打開cmd，並輸入\n1 node 如果有成功安裝的話應該會顯示 接著安裝picGo-core\n1 npm install picgo -g 說出現錯誤，要我們執行\n1 npm audit fix -force 執行完之後就安裝好了，接著輸入\n1 picgo 來確認是否有安裝成功，有時候可能會出現\n1 檔案未經數位簽署這個指令碼將不會在系統上執行 之類之類的句子，這時候可以輸入\n1 Set-ExecutionPolicy RemoteSigned 來允許執行，這時候在輸入picgo應該就可以看到這樣子的畫面了\n到這一步本地端的設定已經完成80%了，接下來就是要選擇要使用哪種圖片空間\nGithub 首先先到Github創建一個公開的Repository，名字隨意就好 接著把這個Repository的URL複製下來 1 https://github.com/Hoxton019030/Typora 右上角個人頭像點開，選擇Settings 左側選項最下面有一個Developer settings 選擇Personal access tokens 選擇 Generate new token 輸入這個token的名稱，隨便取就好，Expiration看個人喜好，我很懶，所以我選擇永久，下面的select scopes勾選repo 接著會產生一組ghp開頭的token，這組序號只會在這裡以明碼出現一次，接下來永遠都不會再以明碼的方式呈現所以請好好記起來 然後到Typora的偏好設定裡打開開啟設定檔，通常會是用一個文本編輯器打開，通常都是vscode啦 接著把這串東西複製貼上去 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;github\u0026#34;: { \u0026#34;repo\u0026#34;: \u0026#34;Hoxton019030/Typora\u0026#34;, //這串對應的是使用者名稱+Repo名稱，改成自己的 \u0026#34;token\u0026#34;: \u0026#34;ghp_xxxxxxxxxxxxxxxxxxxx\u0026#34;, //這邊把剛剛產生的token貼上去 \u0026#34;path\u0026#34;: \u0026#34;data/\u0026#34;, //圖片要上傳到哪個資料夾，可以先不用設定， \u0026#34;customUrl\u0026#34;: \u0026#34;https://raw.githubusercontent.com/Hoxton019030/Typora/main\u0026#34;, //把Hoxton019030/Typora改成你自己的repo \u0026#34;branch\u0026#34;: \u0026#34;main\u0026#34; //應該也不用動 } }, \u0026#34;picgoPlugins\u0026#34;: {} } 完成之後應該長這個樣子，接著按存檔 接著回到設定，試著按看看測試圖片上傳 如果成功的話就會出現這樣的畫面\n就代表你成功了！\n如果你在按一次測試圖片上傳，由於上傳的圖片檔名一模一樣，會報錯，這樣是正常現象，請不要驚慌\nimgur 首先先辦帳號 https://api.imgur.com/oauth2/addclient 點擊這個網址 老樣子，名字隨意取就好，然後Authorization type選擇第二個 接著會跳出畫面，會告訴你你的Client ID是什麼，請複製下來 接著到偏好設定裡面打開開啟設定檔，通常會用vscode開啟 接著把這段複製貼上上去 1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;imgur\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;imgur\u0026#34;, \u0026#34;imgur\u0026#34;:{ \u0026#34;clientId\u0026#34;: \u0026#34;XXXXXXXXXXX\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} } 貼上去之後應該會長這個樣子\n然後存檔之後，回到偏好設定，按「測試圖片上傳」 跳出這個就代表成功上傳了！\n小結 這樣子只要在typora裡面貼上圖片，typora就會自動幫我們上傳圖片到圖片空間了。\n","date":"2022-10-08T01:02:04+08:00","image":"https://i.imgur.com/W6FAkN1.png","permalink":"https://hoxtonhsu.com/p/typora-%E5%A6%82%E4%BD%95%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E6%95%99%E5%AD%B8-%E4%BD%BF%E7%94%A8github-imagur%E4%BD%9C%E7%82%BA%E5%9C%96%E7%89%87%E7%A9%BA%E9%96%93/","title":"TYPORA 如何上傳圖片(教學 使用Github , imagur作為圖片空間)"},{"content":"​\t到底要不要進事務所？\n我想一開始就給出解答\n如果不知道做什麼就進事務所吧！\n​\t如果是會計系的學生，在大學期間一定有想過自己到底要不要進入所謂的四大（勤業、資誠、安侯、安永），我在大學的時候對於這個問題倒是沒太多想法，只覺得進入四大事務所好像很威風，出入信義區，西裝革履的樣子，名稱也是國際上有名公司，怎麼想都覺得很穩，能出什麼問題？\n當然實際進去之後我就後悔了，發現這樣的生活根本不是自己想要的，索性的待到一月，把年終獎金還有到職獎金，以及政府的青年就業補助的錢領一領之後，就趕緊跑回高雄準備轉換跑道，做什麼都行，但這輩子絕對不會在做會計了。\n但離職過後也快一年，轉換工作也算成功，但持續的一直有在Follow會計這個圈子，所以想說來分享一下自己的一些想法，希望可以幫助到一些會計系的學生。\n一份工作一定是有好有壞的，事務所的工作則是將好與壞的那非常極端，這篇文章先來講「我」覺得事務所好的地方，下一篇文章再來講我為什麼離職。\n事務所的名聲 事務所的名聲是我在離職之後最直接的感受，在自我介紹或是之後轉換跑道的面試，第一個被問的問題都是\n「你之前在資誠耶，很好的一間公司？怎麼會想要離職轉換跑道呢？」\n誠然四大在會計系學生的眼中已經是臭到不能再臭的公司，但出了事務所之後，只要待的公司不是太鳥的那種，基本上四大的經歷即使不到亮眼，但也絕對不會是一個看不上眼的經歷。\n事務所是一家很大的公司 在離職之後第二個很深的感受是，四大確實是一間很大的公司，在信義區的精華地段裡有很多層樓的辦公室，有包場的尾牙，會請藝人來唱歌，還有很完善的公司分工制度。我現在的公司就是一家在中山區普通商辦大樓裡面的辦公室，員工數大概也就十來人左右，也沒什麼完整的分工制度，有時候感覺一個人要身兼多職。\n而且我相信很多人離職之後，第二家公司的規模都不會再有四大那樣的規模，所以我覺得可以來四大體驗看看一家員工數破千的公司感覺是怎麼樣的。\n事務所的工作強度 這點其實很諷刺，我之前在的組別是最近很夯的資誠A11 AKA 獨立所疊字組。說實話當時也沒覺得什麼地不地獄的，當你看同事在加班，組長在加班，經理們也在加班，其實當下也會覺得沒什麼，反正大家就一起加班，有時候晚上六點多，同事們相約訂餐的畫面總讓我想起國小在讀安親班的感覺。\n我在事務所的上班的大概就是9月入職然後到1月初離職，唯一接觸到的忙季大概就是十月，那時候星期一到五大概都是9點10點那邊回家，差不多有三天是待到11點才走（11點就可以走是因為資誠是在國貿大樓，國貿大樓11點就要關門，所以才有機會回家Q_Q），星期六大概是10點11點進所內，然後可能晚上8、9點離開，至於星期天我是沒進過所內，快樂的小確幸～\n在這樣中強度的加班強度下，我離職之後，不管待哪家公司我都覺得好爽，這可能也是事務所很諷刺的一個好處吧，畢竟從四大出來的，每個都是見過地獄的人，到哪裡都像是天堂一樣。\n哈哈，可能真的太久沒寫文章了，感覺原本腦中有很多想法，突然要寫就寫不出什麼東西來，自己寫完再回頭來看自己列的這幾點，發現真的是蠻無聊的幾個點，也不構成什麼吸引力，但要問我後悔進入事務所嗎？其實還蠻慶幸我有進入事務所的，因為世界上真的找不太到比那更爛的工作了，我也是在那段期間真的很想離職，有這樣的念頭之後才知道自己到底想做的是什麼，這可能就是所謂的「在極大的痛苦中感覺精神甦醒吧」，總之我想說的是，不管你是台政北或是私科會計，不知道做啥就是選事務所，進去之後就會知道原來有這麼爛的工作，就會強迫自己去想自己到底要做什麼，如果做得下去那也很好，事務所的履歷還是有一點點用的（但我都建議最好是待到組長會比較有用一點）。\n接下來下一篇文章會聊聊我為什麼從事務所離職，應該蠻多可以談的～\n","date":"2022-10-08T00:36:13+08:00","image":"https://i.imgur.com/aHMlhAm.png","permalink":"https://hoxtonhsu.com/p/%E5%BE%9E%E5%85%A5%E8%81%B7%E5%88%B0%E9%9B%A2%E8%81%B7%E4%BA%8B%E5%8B%99%E6%89%80%E7%9A%84%E6%97%A5%E5%AD%90%E4%B9%8B%E8%A9%B2%E9%80%B2%E4%BA%8B%E5%8B%99%E6%89%80%E5%97%8E/","title":"從入職到離職，事務所的日子之《該進事務所嗎？》"},{"content":"目錄 Filter(過濾器)Interceptor(攔截器)AOP(剖面導向程式設計)之差異 Filter Interceptor AspectJ AspectJ 1 2 graph TD; AOP ---\u0026gt; SpringAop \u0026amp; AspectJ AOP (概念) 面向切面編程，利用AOP可以對業務邏輯的各個部分進行隔離，使得業務邏輯各部分之間的耦合度降低，提高程式的可重用性，同時提高開發的效率\n不修改原始碼，從而擴充新功能\nFilter(過濾器)Interceptor(攔截器)AspectJ(AOP)之差異 1 2 3 4 5 6 7 8 9 10 11 flowchart LR; 1((使用者))--發送請求 --\u0026gt;Filter\\n+統一設置編碼\\n+過濾敏感字\\n+登入驗證\\n+URL級別的訪問權限控制\\n+數據壓縮 --\u0026gt;dispatcher --\u0026gt;Interceptor\\n+權限驗證\\n+登入驗證\\n+性能檢測 --\u0026gt;AOP\\n+日誌紀錄 --\u0026gt;2(Controller) -1[粗糙]--能處理request的精細程度----\u0026gt;-2[細緻] Filter 1 2 3 4 5 flowchart LR; 1[瀏覽器]---\u0026gt;2{過濾器}---\u0026gt;3[Web資源] 3[Web資源]--\u0026gt;2{過濾器}--\u0026gt;1[瀏覽器] 在HttpServletRequest到達Servlet之前，過濾、處理一些資訊，本身依賴Sevlet容器，不能獲取SpringBean的一些資訊，它是javax.servlet.FilterChain的項目，不是Springboot\n可以做什麼\n修改Request, Response 防止xss(Cross-Site-SCripting跨網站指令碼)攻擊 包裝二進制流 自定義Filter 以註解方式製作Filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ @Slf4j @Component @WebFilter(filterName = \u0026#34;f1\u0026#34;,urlPatterns = {\u0026#34;*.html\u0026#34;,\u0026#34;*.jsp\u0026#34;,\u0026#34;/\u0026#34;}) //filterName就只是一個名稱可以，隨意就好，urlPattern是用來指定哪些url要經過這個過濾器 public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了 } } 結果如上\n以Java配置方式製作Filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Slf4j /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了 } } 1 2 3 4 5 6 7 8 9 @Configuration public class FilterConfig { @Bean public FilterRegistrationBean heFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(new HiFilter()); registration.addUrlPatterns(\u0026#34;/*\u0026#34;); //配置相關的路徑 return registration; } } 一些其他的config設置，僅供參考，與上面釋例無關\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration public class FilterConfig { //test @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logProcessTimeFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogProcessTimeFilter()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;logProcessTimeFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(0); //設定過濾器的執行順序 return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logApiFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogApiFilter()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;logApiFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(1); //設定過濾器的執行順序 return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; printResponseRequestFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new PrintResponseRequest()); //設定想要使用哪一個Filter bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到 bean.setName(\u0026#34;printResponseRequestFilter\u0026#34;); //設置要叫什麼名字 bean.setOrder(2); //設定過濾器的執行順序 return bean; } } SpringBoot本身也提供了許多不同的Filter供使用，參考如下\n常用的有以下幾個\nCharacterEncodingFilter(用於處理編碼問題) HiddenHttpMethodFilter(隱藏Http函數) HttpPutFormContentFilter(form表單處理) RequesrtContextFilter(請求上下文) 其他資訊可以詳閱Spring MVC中各个filter的用法\n其中以OncePerRequestFilter最常被使用，這個Filter會去過濾每一個Request請求，且不會重複執行，且這個Filter有一個doFilterInternal()的方法，供我們撰寫Filter邏輯因doFilter()的方法已在OncePerRequestFilter裡面實現了，可以用來做Jwtoken的登入驗證，程式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { @Autowired private JwtService jwtService; @Autowired private UserDetailsService userDetailsService; //注入JwtService UserDetailsService，分別用來解析Token與查詢使用者詳情 @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION); if (authHeader != null) { String accessToken = authHeader.replace(\u0026#34;Bearer \u0026#34;, \u0026#34;\u0026#34;); //從請求標頭中取得Authorization欄位中的值 Map\u0026lt;String, Object\u0026gt; claims = jwtService.parseToken(accessToken); //擷取出後面的JWT字串，接著解析它 String username = (String) claims.get(\u0026#34;username\u0026#34;); //從claims物件中取得username欄位的值 UserDetails userDetails = userDetailsService.loadUserByUsername(username); //並透過userDetailService查詢使用者詳情。這也代表JWT的內容(payload)必須包含username這個欄位 //在filter中查詢使用者的目的，是為了將該次請求所代表的驗證後資料(Authentication)帶進security中的Context。 //Context是一種較抽象的概念，可以想像成該次請求的身分狀態 Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); //為了將這個請求的使用者身分告訴伺服器，我們建立UsernamePasswordAuthenticationToken的物件，其中第三個參數放GrantedAuthority的List， 作為API的授權檢查 //第一個參數(principal)傳入使用者詳請(UserDetails)。 // 而第二個參數是credential，通常是密碼，但不傳入也無訪 //經由傳入principal，我們得以在業務邏輯中從Context輕易獲取使用者身分的資料 SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } } 配置完後再將這個Filter加入Security的過濾鍊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; /** * 協助帳號密碼認證的東西 * @return */ @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } //加入Security的過濾鍊 protected void configure(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .antMatchers(HttpMethod.GET, \u0026#34;/users/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name()) // .antMatchers(HttpMethod.GET,\u0026#34;/h2/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name()) .antMatchers(HttpMethod.GET,\u0026#34;/login/**\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST,\u0026#34;login\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST, \u0026#34;/users\u0026#34;).permitAll() .anyRequest().permitAll() .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) //於UsernamePasswordAuthenticationFilter進行認證 .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .csrf().disable() .formLogin(); http.headers().frameOptions().disable(); //讓spring Security可以和h2建立連線 } /** * * @param auth 配置全局驗證資訊，如Authentication Provider,UserDetailService等等資訊， * authenticationManager會接收到UsernamePasswordAuthenticationToken傳入的資料後 * 調用SecurityConfig中所配置的userDetailsService,passwordEncoder來協助驗證 * * @throws Exception */ protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); } } 一些Code的示範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LogProcessTimeFilter extends OncePerRequestFilter { /** * @param request 請求 * @param response 回應 * @param filterChain 過濾鏈 會將現有的filter給串聯起來，當請求進入後端，需要依序經過它們才會達到Controller，相對的，當回應離開Controller，則是按照相反的方向經過那些Filter * @throws ServletException * @throws IOException */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { long startTime = System.currentTimeMillis(); filterChain.doFilter(request, response); //doFilter:相當於將請求送至Controller。 long endTime = System.currentTimeMillis(); long processTime = endTime - startTime; System.out.println(\u0026#34;processTime = \u0026#34; + processTime); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /** * Controller收到的請求主體(RequestBody)和回應主體(ResponseBody) * 分別由HttpServletRequest與HttpServletResponse的InputStream、OutputStream轉化而來， * 但資料流只能讀取一次，如果在Filter層就被讀掉，可能會導致後面都收不到資料 * 為了保留主體中的資料，我們將請求主體與回應主體包裝成ContentCachingResponseWrapper ContentCachingRequestWrapper * 再如同往常傳入FilterChain * * 這兩個Wrapper的特色是會在內部備份一個ByteArrayOutputStream，我們只要呼叫這兩個Wrapper的 * getContentAsByteArray就可以無限制地取得主體內容 */ public class PrintResponseRequest extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request); ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response); filterChain.doFilter(requestWrapper, responseWrapper); // logApi(request, response); logBody(requestWrapper,responseWrapper); responseWrapper.copyBodyToResponse(); } private void logApi(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int httpStatus = response.getStatus(); //200,403,404之類的 String httpMethod = request.getMethod(); String uri = request.getRequestURI(); String params = request.getQueryString(); if (params != null) { uri += \u0026#34;?\u0026#34; + params; } System.out.println(String.join(\u0026#34; \u0026#34;, String.valueOf(httpStatus), httpMethod, uri)); } private void logBody(ContentCachingRequestWrapper request, ContentCachingResponseWrapper response) { String requestBody = getContent(request.getContentAsByteArray()); System.out.println(\u0026#34;Request: \u0026#34; + requestBody); String responseBody = getContent(response.getContentAsByteArray()); System.out.println(\u0026#34;Response: \u0026#34; + responseBody); } /** * @param content * @return 返回JSON字串 */ private String getContent(byte [] content){ String body = new String(content); return body.replaceAll(\u0026#34;[\\n\\t]\u0026#34;, \u0026#34;\u0026#34;); //去除換行\\n與定位符號\\t } } Interceptor 本身是AOP的一種應用，其實攔截器跟過濾器是可以互相替換的，功能其實差不多，只是攔截器可以在請求到達Controller或是回應回傳出Contrller時進行攔截，攔截成功時可以實做一些自定義的業務邏輯進行修改，且Interceptor是Springboot下的一個功能org.springframework.web.servlet.HandlerInterceptor\n可以用來\n性能監控：紀錄請求的處理時間，比如說請求處理太久（超過500毫秒） 登入檢測 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 graph LR; request--\u0026gt;id1 id1--\u0026gt;id2--\u0026gt;id4--\u0026gt;id3--\u0026gt;id6--\u0026gt;id5 subgraph 攔截器1 direction TB id1[\u0026#34;preHandle()\u0026#34;] id3[\u0026#34;postHandler()\u0026#34;] id5[\u0026#34;afterCompletion()\u0026#34;] end subgraph 攔截器2 direction TB id2[\u0026#34;preHandle()\u0026#34;] id4[\u0026#34;postHandler()\u0026#34;] id6[\u0026#34;afterCompletion()\u0026#34;] end 要實現interceptor有兩種方式\n實作HandlerInterceptor 繼承HandlerInterceptorAdapter 釋例\n自定義攔截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class LogInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); System.out.println(\u0026#34;\\n-------- LogInterception.preHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;Start Time: \u0026#34; + System.currentTimeMillis()); request.setAttribute(\u0026#34;startTime\u0026#34;, startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.postHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.afterCompletion --- \u0026#34;); long startTime = (Long) request.getAttribute(\u0026#34;startTime\u0026#34;); long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;End Time: \u0026#34; + endTime); System.out.println(\u0026#34;Time Taken: \u0026#34; + (endTime - startTime)); } } 註冊攔截器 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogInterceptor()); registry.addInterceptor(new OldLoginInterceptor()).addPathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); registry.addInterceptor(new AdminInterceptor()).addPathPatterns(\u0026#34;/admin/*\u0026#34;).excludePathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); } } AspectJ 屬於一種AOP框架\n動態代理(Spring5本身已經封裝了) 有兩種情況的動態代理 有介面(JDK動態代理)\n1 2 3 interface UserDao{ public void login(); } 1 2 3 4 class UserDaoImpl implements　UserDao{ public void login(){ } } 創建UserDao介面實現類的代理對象，代理對象會有被代理對象的所有方法，並且增強\n無介面(CGLIB動態代理)\n1 2 3 4 5 class User{ public void add (){ } } 1 2 3 4 5 class Person extends User{ public void add(){ super.add(); } } AOP(JDK動態代理) 使用JDK的動態代理，要使用Proxy類裡面的方法來創建出代理對象 newProxyInstance(類加載器,增強方法所在的類，這個類實現的介面,實現這個接口(InvocationHandler)\n編寫JDK動態代碼\n1 2 3 4 5 public interface UserDao { public int add (int a,int b); public String update(String id); } 1 2 3 4 5 6 7 8 9 10 11 12 public class UserDaoImpl implements UserDao{ @Override public int add(int a, int b) { System.out.println(\u0026#34;add方法執行了\u0026#34;); return a+b; } @Override public String update(String id) { return id; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.aop; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; /** * @author Hoxton * @version 1.1.0 */ public class JDKProxy { public static void main(String[] args) { Class[] interfaces = {UserDao.class}; UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); //此dao已經不是原本的dao，而是新的代理類dao了 int result = dao.add(1, 2); System.out.println(\u0026#34;result = \u0026#34; + result); } } //創建代理對象的代碼 class UserDaoProxy implements InvocationHandler { //1. 把創建的是誰的代理對象，把誰傳遞進來 // 有參建構子 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增強的邏輯 @Override public Object invoke(Object proxy, Method method, Object[] methodArgs) throws Throwable { //方法之前 System.out.println(\u0026#34;方法之前執行...\u0026#34; + method.getName() + \u0026#34;傳遞的參數...\u0026#34; + Arrays.toString(methodArgs)); //被增強的方法執行 Object res = method.invoke(obj, methodArgs); //方法之後 System.out.println(\u0026#34;方法之後執行...\u0026#34; + obj); return res; } } AOP專業術語 連接點\n一個類裡面中，能被增強的方法就叫連接點，下面這個類就有四個連接點\n1 2 3 4 5 6 class User{ add(); update(); select(); delete(); } 切入點\n實際被增強的方法，就叫切入點\n通知(增強)\n實際增強的邏輯部分稱為通知(增強)\n通知有多種類型\n前置通知\n在切入點前執行\n後置通知\n在切入點後執行\n環繞通知\n在切入點前後執行\n異常通知\n出現異常時執行\n最終通知\n執行到try\u0026hellip;catch的final時執行\n切面\n是一個動作\n把通知應用到切入點的過程，就叫切面 AOP(準備) Spring 框架一般都是基於AspectJ實現的AOP操作\n什麼是AspectJ\nAspectJ不是Spring的組成部分，是一個獨立的AOP框架， 一般把AspectJ和Spring框架一起使用，進行AOP操作 基於Aspect實現AOP操作\nxml配置文件實現 基於註解方法實現(主要使用) 再專案裡面引入AOP依賴\n切入點表達式\n切入點表達式的作用: 知道對哪個類的哪個方法進行增強\n語法結構:\nexecution( [權限修飾符] [返回類型] [類全路徑] [方法名稱] ( [參數列表] ) )\n權限修飾符: public, private, *(代表不論是public, private 都選)\n返回類型: String, int\n類全路徑: com.hoxton\u0026hellip;\u0026hellip;.\n方法名稱: 就方法名稱\n參數列表: 有哪些參數\n舉例\n對com.hoxton.dao.BookDao類裡面的add方法進行增強\n1 execution(* com.hoxton.dao.BookDao.add(..) ) 對com.hoxton.dao.BookDao類的所有方法進行增強\n1 execution(* com.hoxton.dao.BookDao.*(..)) 對com.hoxton.dao包裡的所有類，類裡面的髓有方法進行增強\n1 excution(* com.hoxton.dao.*.*(..)) within([package名].* )或( [package名]..*)\n舉例\n1. 1.\nAOP操作(Aspect J 註解) 創建類，在類裡面定義方法 1 2 3 4 5 6 public class User { public void add(){ System.out.println(\u0026#34;add\u0026#34;); } } 創建增強類(編寫增強邏輯)\n在增強類的裡面，創建方法，讓不同方法代表不同通知類型\n1 2 3 4 5 public class UserProxy { public void before(){ System.out.println(\u0026#34;before\u0026#34;); } } 進行通知的配置\n在Spring Log4j 2 1 2 3 flowchart TD; 8[\u0026#34;ALL(全輸出不留情)\u0026#34;]---\u0026gt;7[\u0026#34;Trace(更細的除錯資訊，通常用來追蹤城市流程的日誌)\u0026#34;]---\u0026gt;6[\u0026#34;DEBUG(除錯資訊的日志)推薦★\u0026#34;]---\u0026gt;5[\u0026#34;INFO(一般資訊的日志)推薦★\u0026#34;]---\u0026gt;4[\u0026#34;WARN(可能導致錯誤的日志)\u0026#34;]---\u0026gt;3[\u0026#34;ERROR(造成應用錯誤停止的日志)\u0026#34;]---\u0026gt;2[\u0026#34;FETAL(造成應用程式停止的日志)\u0026#34;]---\u0026gt;1[\u0026#34;OFF(不輸出任何日志)\u0026#34;] 參考 https://www.cnblogs.com/itlihao/p/14329905.html\nhttps://blog.csdn.net/fly910905/article/details/86537648\nSpringBoot攔截器(Interceptor)詳解\nSpring Boot使用過濾器和攔截器分別實現REST介面簡易安全認證\n","date":"2022-10-07T22:41:52+08:00","image":"https://i.imgur.com/B7GhSw1.png","permalink":"https://hoxtonhsu.com/p/%E5%9F%BA%E7%A4%8Eaop%E4%BB%8B%E7%B4%B9-filter-interceptor-aspectj/","title":"基礎AOP介紹-Filter Interceptor AspectJ"},{"content":"​\t如果你是好奇死亡擱淺這款遊戲到底好不好玩，擔心對不到電波，怕買了浪費錢的人可以聽看看我的想法\u0026ndash;「我覺得很難歸納出哪種類型的人會喜歡死亡擱淺」 我只能說，會比較推薦給至少能撥出個1、2小時玩遊戲的人才會比較適合玩。\n無雷心得：\n我本身不是小島秀夫的粉絲，他的作品我也只玩過幻痛而已，而且 我覺得幻痛超級無聊，遊戲評分鼓勵你不殺，所以你很多裝備是不能用 的，而且地圖設計也稱不上有趣，荒漠和草原的地形空蕩到很空虛，不太能理解 為什麼硬要做成開放地圖，A任務做完要到B任務就只能自己過去、或是叫直升機等等的。看完了儀式之人的影片後也沒有覺得躍躍欲試的感覺，玩了20個小時後真的撐不下去就 不玩了，所以我在買死亡擱淺前其實猶豫很久，因為我知道我可能會Get不到遊戲有趣的點? 後來還是抱持著是驢是馬遛看看的心情買了下去。\n純論遊戲心得，並且在不暴雷太多重要劇情的情形下，死亡擱淺最大的樂趣在於遊戲一開始剝奪你很多東西，初期會要求你背著大重量的貨物到有一段距離的地方，然後這路上可能有懸崖、陡坡之類的地形阻隔著你，所以初期會對於這些事情覺得很毛躁、等到遊戲中期，開始出現很多東西能輔助你送貨，能裝載更多重量的、加速的，會讓你覺得所有的一切不再那麼痛苦，而後期當你解鎖所有設施、道具之後，你會開始愛上送貨這件事情，我覺得這點蠻神奇的，因為在往常的遊戲裡面跑腿送貨是最無聊的環節，你會用快速旅行直接省略掉這個過程，但在死亡擱淺裡你會體認到，所有的一切都是自己努力而來的，是自己讓這件事情變得輕鬆，變得平易近人，就好比學習一項事物，從排斥到接受，再到學以致用，漸漸地愛上一件事情。\n​\t我記得有一個晚上我就上線，也沒推任何主線劇情，就很單純的從A點接單送到B點，再從B點接單送到C點，然後再從C點接單送到B點這樣往復巡還，聽起來很無聊，但我當時送完貨物跑出結算畫面，看到滿滿的SSS時，真的覺得送貨使我快樂。\n另一點我覺得有趣的是遊戲裡面的線上模式，會讓你的地圖裡出現其他玩家的建物，比如說休息站、涼亭之類的，或者是其他玩家的登山索、樓梯，這點不是死亡擱淺原創，但在這遊戲裡面卻是我最喜歡的一點，在爬山的時候爬著其他玩家的梯子，然後在山頂看到其他玩家撒尿的蘑菇叢、然後在拉著其他玩家的纜繩下山，雖然你無法看到那些玩家的身影，但它們在你的世界留下的足跡卻令他們的形象具體而鮮明，在你在河流底部發現散落的貨品、峽谷下方報廢的摩托車，宛若有一段故事被濃縮成一個小小的物品，而這個小小的物品又經由你的發現而解壓縮成一段送貨之旅，死亡擱淺大部分的遊戲時間都是獨自一人的，但這種設計讓這個世界不在那麼冰冷，而多了些許溫度。\n最後是這個遊戲的氛圍，死亡擱在某些地形出現的時候（比如說高山、平原、裂谷）會撥放一些很空靈感的歌，配合上游戲的畫面、眼前的景象，山姆苗小的身影形成強烈的對比，耳中響起的和聲與山姆亦步亦趨的步伐，行走在一望無際的大草原，所有的一切都是空的，但心中卻被滿滿的感動填滿著。\n死亡擱淺到底適合什麼樣的人，我覺得只有自己玩了才能知道，他就是一款這麼特別的遊戲，看起來很無聊，但玩起來卻比想像中的有趣。\n有雷心得：\n其實玩完之後，我原本是很期待劇情而對遊戲性無感，但玩完後我卻相反過來 ，因為我劇情看不太懂，但遊戲性卻是出乎我意料之外的好。遊戲到尾聲之前我是都看得懂的，大概就是我們要去救艾米莉，但有個叫希格斯的人百般阻饒，然後頑人藏著什麼秘密。但當艾米莉出來之後我就完全看不懂了，我只能理解到一個艾米莉在冥灘、另一個在總統府當總統，但不能理解為什麼她要希格斯又要山姆，也不能理解她是不是好人，因為從結尾畫面上看來，艾米莉是想要毀掉世界的，但當山姆放下槍後她卻又抱著山姆說了一段我不明所以的台詞：\n「我做過無數個夢，我不知道該相信哪一個，所以我才決定跟你和其他人分享我的夢境，但是為了讓點連成一條線，讓一切都弄清楚，你們需要看得更透徹。你們需要時間。時間對我沒有任何意義，我不是一條線，我是單獨存在的點\u0026hellip;(省略)\u0026hellip;你(山姆)找到了共通的線，把所有點串在一起，而且你用唯一可能的方式做到了，也就是努力活好每一天，謝謝你山姆。」 ​\t這邊我看不懂的原因，是因為不能理解為什麼山姆努力活好每一天就能把所有點串成一條線，也不能理解為什麼山姆把所有的點連城線之後就可以進行大滅絕，我聽得出來翻譯的字幕和語音是對的上的，沒有亂翻，但就是不知道到底發生了什麼事情，後來上網看之後發現日文版的意思比較直觀，比如說有一段我也看不太懂，但日文版就比較清楚 (中文版)艾米莉：\n「我是滅絕體，讓我們的種族滅絕是我們的命運，但在那一刻你也成為這個命運的一部分，你變成了回歸者，DOOMS將我們的惡夢擴散到了全世界」 (日文版)艾米莉：「我是滅絕體，為了將我們的種族引往滅絕才誕生的，當時你也成為了我的一部分，你成為了回歸者，而共享我滅絕夢能力的DOOMS能力者也誕生了」\n所以我後面的劇情是破完之後再去找解析影片才知道到底如何，可能是我資質駑鈍，真的看不懂遊戲最後的劇情吧，要看人家解析才看的懂，如果有人要留言說是我自己理解力有問題，他都看得懂的話，那我想跟你說聲抱歉，我是低能兒，我不配玩這個遊戲，發這篇文章真的是很對不起PTT對不起我的爸爸媽媽，生了一個連遊戲劇情都看不懂的小孩。\n原本還想打更多的，但發現該講的都講完，最後一點雞蛋挑骨頭的大概就是地圖可以再大一點點之類的，很多人說撐過第三章就會好玩，但我是到爬雪山的時候才覺得好玩，因為雪山就開始能針對地形攻略，而且你攻略的越透徹，爬起來就越輕鬆，所以我當初在爬的時候就帶了一堆建材，瘋狂蓋纜車，建材一沒就立刻搭纜車回家拿，這樣把雪山道路牽起來，最後結尾的時候我就是一路從雪山搭車搭到基地，連對話都還沒跑完就到家了。\n結尾就是，如果死亡擱淺有出2，我會買，有朋友要我推薦遊戲，我也會推薦死亡擱淺給他們，畢竟這應該是市面上唯一一款用3A規模製作的獨立遊戲風格的大作了。\n","date":"2022-10-07T02:44:36+08:00","image":"https://i.imgur.com/mg2syAL.jpg","permalink":"https://hoxtonhsu.com/p/%E6%AD%BB%E4%BA%A1%E6%93%B1%E6%B7%BA%E5%BF%83%E5%BE%97%E5%89%8D%E9%9D%A2%E7%84%A1%E9%9B%B7%E5%BE%8C%E9%9D%A2%E6%9C%89%E9%9B%B7/","title":"死亡擱淺心得，前面無雷，後面有雷"},{"content":"如果你沒有看過黑暗靈魂1代的任何影片，比如說boss介紹、地圖跑法之類的\n也沒有玩過魂3，那我會覺得黑暗靈魂1代很值得玩 但如果你已經看過很多實況主玩過黑暗靈魂，知道怎麼從傳火祭祀場走到灰燼湖 知道怎麼走到不死鎮底層\u0026hellip;諸如此類的事情，那我會建議你不要玩黑魂 因為黑魂1真正有趣的是地圖探索，如果你地圖都知道怎麼跑 那我不建議你玩魂1\n我先從抱怨的地方開始好了，我以下的抱怨都是針對黑暗靈魂1 大部分我抱怨的事情都在魂3有改善了\n1.打Boss的跑屍路程\n魂1裡面有些boss的跑屍路程我覺得是設計的不錯的，比如說守鐘的石像鬼、翁斯坦與? 摩等等，這種路程落在30秒內，路上的阻礙不會嚴重到殺死你的，我覺得是個合格的跑屍流程，這種長度可以在每次跑屍的路上，想看看上次犯的錯要如何修正、哪些招該怎麼閃之類的。但有些boss的跑屍流程我就覺得有點誇張了，比如說墓王尼特、烏薪王葛溫、 混沌的溫床這類型的，跑屍流程大於30秒，路上又不是說特別好跑，比如說初始火爐卡在橋上的黑騎士，或是溫床路上的楔型石惡魔、墓王尼特要先跑過一堆有的沒的的區域才能進霧門，使得我後期越玩越煩躁，前面剛開始打的時候都覺得還好，越到後面的王跑屍過程就越長。\n2.篝火的傳送點太少\n魂1的篝火每個篝火都能主動傳送，但不是每個篝火都能接受傳送，比如病村的底部下? 道的傳點就不能傳過去，只能選擇從蜘蛛女那邊過去，偏偏病村跑圖又不是件很有趣的 事情，會減弱我中途想要回去探索的慾望\n3.靈活度\n魂1的翻滾只能朝前後左右方向滾，所幸魂1大部分的boss都不太需要斜方移動，但操作 來就是卡卡的，而且負重要低於25%才能讓翻滾動畫像魂3那樣絲滑流暢，所以我幾乎都是裸體在玩的。\n至於魂1的優點，我想先老實說，因為我已經知道大家說黑魂1的地圖設計很神，所以在 的時候已經有主觀認知了，所以在玩的時候沒有真的很驚艷的感覺，不死鎮的電梯下來到祭祀場、病村接飛龍之谷接小隆德接祭祀場，這些我都覺得是很棒的設計，但沒有那種大腦震撼的感覺。當初我在玩空洞騎士的時候，還不知道空洞騎士的地圖探索也做得很強，當我偶然間從心血來潮，不選擇搭車，而是在繼續往右走，走到王國邊界時，真的覺得這遊戲的地圖設計真的太強了，所有的一切都環環相扣。但在魂1裡面我沒有感受到這種 感覺過，唯一一個比較接近的應該就是灰燼湖，我很後悔我是從攻略影片上面得知這個地點，我想如果我是自己偶然間走進樹洞，偶然間撞進幻影牆，順著路一路走，最後進入 灰燼湖，踏上古龍之道的話，我想我對魂1的地圖評價應該會更高，但真的很可惜，我透過Youtube、Twitch等等渠道，已經大略的知道魂1的地圖，所以我對於地圖的感受都已經是二手的，就像張愛玲說的「我們對於生活的體驗往往是第二輪的」，自然而然也沒有那麼感動了。\n但魂1還是有些地點是我覺得很有趣的，比如說賽恩古城、地下墓地。古城被譽為賽恩 快樂城、極限體能王，裡面的道路錯綜複雜、又有許多陷阱、埋伏、但實際在跑圖的時候，能感受到這個古城非常用心，怪物的配置、陷阱的位置都有給玩家對應的空間。地下墓地則是讓我體驗了一次神鬼傳奇的感覺，身後有無數隻骷髏士兵永無止盡的追著自己，而自己就要在這種情況下找到篝火，在這一區域每次找到篝火都會讓我有種鬆了口氣的感覺。\n文章差不多就打到這邊了，就像我一開始說的，如果你沒玩過魂3、也不知道魂1的地圖長啥樣，想體驗看看什麼叫地圖設計，那魂1可以嘗試看看，但如果你玩過魂3、或是知道魂1? 那我就覺得魂1不太適合玩了，畢竟也是十年前的作品有些地方都顯得有點過時，建議看看影片、看看實況補完就好，以我自己實際下去玩的感受，我覺得痛苦太多，收穫太少，有趣的點都因為預先知情而被淡化、無趣的點則因為玩過魂3而被無限放大，以上這些都是? 個人意見，如果版上有黑暗靈魂一代粉絲，我就在這邊說聲抱歉了。\n","date":"2022-10-06T23:16:34+08:00","image":"https://i.imgur.com/jQx4JF5.png","permalink":"https://hoxtonhsu.com/p/%E9%BB%91%E6%9A%97%E9%9D%88%E9%AD%821%E5%BF%83%E5%BE%97/","title":"黑暗靈魂1心得"},{"content":"SpringBoot-Scheduling 用來做定期任務的東西，有兩種\nSpring schedule：只適合處理簡單的計畫任務，不能處理分散式的任務，當任務太多時，可能出現阻塞、崩潰、延遲啟動等問題 Quartz：更強大的一個排程器，能夠配置上百甚至上千的事務。 Spring Schedule 步驟 在啟動類上加上@EnableScheduling 1 2 3 4 5 6 7 @SpringBootApplication() @EnableScheduling public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 在方法上加上@Scheduled 1 2 3 4 5 6 7 @Component public class Task { @Scheduled(fixedDelay = 10 * 100) public void printLocalTime() { System.out.println(LocalTime.now().toString()); } } 1 2 3 4 @Scheduled(cron = \u0026#34;1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } 1 2 3 4 @Scheduled(cron = \u0026#34;0/1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); } Cron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 Quartz 是一個開源的任務排程器，幾乎可以整合到任何Java應用程式中。\n它可以用來\n安排每個晚上把資料庫內容轉存到檔案 提供定時提醒服務 族繁不及備載\u0026hellip; 底層數據結構- 堆 介紹 堆是一種特殊的樹，滿足下面兩個條件，就是一個堆\n堆是一顆完全二元樹完整二元樹：除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..) 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 小頂堆\n完整二元樹的一些特性：快速定位父節點\n在排程器的框架中，每一個節點就是一個Job，越頻繁的Job會被放置在越上層的節點\n如何插入元素 尾插法，在尾部插入一個新的元素，然後上浮，浮到符合定義\n除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..)，且最後一層節點都靠左排列 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值 如何刪除元素 將尾部(最後一個節點)放置到堆頂，然後下沉\n時間輪算法(Time Wheel) 再刪除元素的時候都需要下沉，當節點數很多時會造成性能延宕\nround 型的時間輪 任務上記錄一個round，遍歷到了就將round減一，為0時取出來執行\n分層時間輪 Cron表達式以及其他排程器所採用的底層架構，分成秒輪、分輪、小時輪、日輪、周輪、月輪、年輪\u0026hellip;，月輪迭代到了，就將任務取出放到天輪中執行\u0026hellip;，以此類推\nCron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n秒 分 時 日 月 周 年(可選) 1 * * * * ? ? 秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年 想像一個時鐘\u0026hellip;\n當每次秒針指向一秒時 1 * * * * ? 當每次時針指向12時 * * 12 * * ? 每個月 1 號中午 12 點 0 0 12 1 * ? 1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ? 字元 意義 * 表達任意值，所有值都可以匹配 ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值 - 指定範圍，前後接數字: 10-12 , 指定離散的選項: 1,5,6,8，或者的概念 / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位 L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二 W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後 LW 用在日的值域，表示最後一周的工作日 # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三 C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天 ​\n重要API及概念 記得Job類一定要是public class，不然Scheduler會讀不到\n釋例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Quartz { public static void main(String[] args) { MyJob myJob = new MyJob(); JobDetail jobDetail = JobBuilder.newJob(MyJob.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .build(); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;trigger1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); } catch (SchedulerException e) { throw new RuntimeException(e); } ; } } 1 2 3 4 5 6 public class MyJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;MyJob execute:\u0026#34; + new Date()); } } 釋例二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class HelloJob { public static void main(String[] args) { try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) //Job1是名字，具有唯一性，group1是這個Job屬於哪一組，同一組的Job可以共享相同的邏輯來處理Job。需要name與Job才可以組成一個JobKey .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); // scheduler.shutdown(); } catch (SchedulerException e) { throw new RuntimeException(e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @NoArgsConstructor public class SayHello implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail jobDetail = context.getJobDetail();//從context中獲取屬性 JobKey key = jobDetail.getKey(); Class\u0026lt;? extends Job\u0026gt; jobClass = jobDetail.getJobClass(); String description = jobDetail.getDescription(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); String username = jobDataMap.getString(\u0026#34;username\u0026#34;); int age = jobDataMap.getIntValue(\u0026#34;age\u0026#34;); log.info(\u0026#34;\\nJobKey : {},\\n JobClass : {},\\n JobDesc : {},\\n username : {},\\n age : {}\u0026#34;, key, jobClass.getName(), description, username, age); } } Scheduler 生命週期由ScheduleFactory建立開始，呼叫shutdown方法結束。\n當Schduler建立，任何關於Schduling相關的事情，都由它控制\n新增 刪除 列出所有Job 暫停觸發器 在Start之前不會做任何事情\nJob 你希望被排程器排程的任務元件介面，定義如何執行，是正在執行的作業例項，一個Job可以建立多個JobDetail，擁有不同的JobDataMap。本身implement了Job類\n1 2 3 graph TD; Job ---\u0026gt; JodDetail1 \u0026amp; JodDetail2 \u0026amp; JodDetail3 \u0026amp; JodDetail... 1 2 3 4 5 6 public class SendEmail implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;SendEmail\u0026#34;); } } 當Job的觸發器觸發時，排程程式的工作執行將呼叫excute()方法 該方法接收一個JobExcutionContext物件，為Job提供了豐富的執行時環境，比如schduler,trigger,jobDataMap,job,calender,time 何謂Context(上下文)\n可以理解為環境、容器的意思會比上下文更具體一點，它提供了一個程式中全域性的資訊。\nJobDetail 用於定義Job的各種屬性、各種任務，還可以用來為Job儲存狀態資訊的JobDataMap，是將Job加入scheduler時，所需要創建的一個物件，它包含了各種屬性設置，以及用於存取job實例狀態訊息的JobDataMap，在創建JobDetail時，需要將欲執行的類名傳遞給JobDetail，這樣schedule就知道要執行何種類型的job。\n1 JobDetail jobDetail=JobBulider.newJob(Job.class).bulid(); JobDataMap 實作Map介面，因此具有Key-Value，儲存可序列化資料，供Job在執行時使用。也可以使用usingJobData(key,value)在建構JobDetail的時候傳入資料，使用JobDetail.getDataMap()獲取Map。可以再透過jobDataMap取出裡面的數據\n1 2 3 4 JobDetail job = JobBuilder.newJob(HelloJob.class) .withIdentity(\u0026#34;helloJob\u0026#34;, \u0026#34;hello\u0026#34;)//給job命名並分組 .usingJobData(\u0026#34;jobdd\u0026#34;, \u0026#34;hello job\u0026#34;)//通過JobBuilder的usingJobData方法給JobDataMap中塞入數據 .build(); 1 2 3 4 5 6 7 8 9 10 public class HelloJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.err.println(context.getJobDetail().getKey());// JobDetail的key又他的name和group組成 System.err.println(context.getTrigger().getKey());// Trigger的key又他的name和group組成 System.err.println(context.getJobDetail().getJobDataMap().get(\u0026#34;jobdd\u0026#34;)); System.err.println(\u0026#34;hello,quartz\u0026#34;); } } 會輸出\n`hello.helloJob\nhello.helloTrigger\nhello job\nhello, quartz\nTrigger 觸發任務執行，觸發器可能具有與Job有關的JobDataMap，以便將觸發器觸發的引數傳遞給Job，Quartz本身提供了幾種觸發器SimpleTrigger和CronTrigger是最常用到的。\nSimpleTriger 用於一次性執行作業或需要在給定的時間觸發一個作業並重複執行N次，且兩次執行時間有Delay。用在具體的時間點，並已指定的間隔時間重複執行若干次，它包含了幾種屬性：\n開始時間 結束時間 重複次數 重複間隔 釋例一：立刻觸發一次，然後停止\n1 2 3 4 5 Date date = new Date(); Trigger trigger1 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(date) .build(); 釋例二：指定時間觸發，每隔十秒執行一次，重複10次\n1 2 3 4 5 6 7 8 trigger = newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(myTimeToStartFiring) // if a start time is not given (if this line were omitted), \u0026#34;now\u0026#34; is implied .withSchedule(simpleSchedule() .withIntervalInSeconds(10) .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings .forJob(myJob) // identify job with handle to its JobDetail itself .build(); 釋例三：5分鐘以後開始觸發，僅執行一次\n1 2 3 4 5 trigger = (SimpleTrigger) newTrigger() .withIdentity(\u0026#34;trigger5\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future .forJob(myJobKey) // identify job with its JobKey .build(); 釋例四：立即觸發，每個5分鐘執行一次，直到22:00：\n1 2 3 4 5 6 7 trigger = newTrigger() .withIdentity(\u0026#34;trigger7\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(simpleSchedule() .withIntervalInMinutes(5) .repeatForever()) .endAt(dateOf(22, 0, 0)) .build(); 釋例五：在下一小時整點觸發，每個2小時執行一次，一直重複：\n1 2 3 4 5 6 7 8 9 10 11 trigger = newTrigger() .withIdentity(\u0026#34;trigger8\u0026#34;) // because group is not specified, \u0026#34;trigger8\u0026#34; will be in the default group .startAt(evenHourDate(null)) // get the next even-hour (minutes and seconds zero (\u0026#34;00:00\u0026#34;)) .withSchedule(simpleSchedule() .withIntervalInHours(2) .repeatForever()) // note that in this example, \u0026#39;forJob(..)\u0026#39; is not called which is valid // if the trigger is passed to the scheduler along with the job .build(); scheduler.scheduleJob(trigger, job); CronTrigger 希望以日期作為觸發任務的板機，就用CronTriger，實務上比較常用這個\n1 2 3 4 CronTrigger trigger2 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(CronScheduleBuilder.cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.how2java; import static org.quartz.CronScheduleBuilder.cronSchedule; import static org.quartz.JobBuilder.newJob; import static org.quartz.TriggerBuilder.newTrigger; import static org.quartz.SimpleScheduleBuilder.simpleSchedule; import java.util.Date; import org.quartz.CronTrigger; import org.quartz.DateBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SimpleTrigger; import org.quartz.impl.StdSchedulerFactory; public class TestQuartz { public static void main(String[] args) throws Exception{ Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); Date startTime = DateBuilder.nextGivenSecondDate(null, 8); JobDetail job = newJob(MailJob.class).withIdentity(\u0026#34;mailJob\u0026#34;, \u0026#34;mailGroup\u0026#34;).build(); CronTrigger trigger = newTrigger().withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;).withSchedule(cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); // schedule it to run! Date ft = scheduler.scheduleJob(job, trigger); System.out.println(\u0026#34;使用的Cron表达式是：\u0026#34;+trigger.getCronExpression()); // System.out.printf(\u0026#34;%s 这个任务会在 %s 准时开始运行，累计运行%d次，间隔时间是%d毫秒%n\u0026#34;, job.getKey(), ft.toLocaleString(), trigger.getRepeatCount()+1, trigger.getRepeatInterval()); scheduler.start(); //等待200秒，让前面的任务都执行完了之后，再关闭调度器 Thread.sleep(200000); scheduler.shutdown(true); } } JobBulider 用來建立JobDetail\n1 2 3 4 5 6 7 8 JobDetail jobDetail = JobBuilder.newJob(某個繼承了Job的類)... JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); TriggerBulider\n用於建立Trigger\nIdentity 當Job和Trgger在Quartz排程程式中註冊時，會獲得標示鍵，JobKey和TriggerKey置入group中，易於組織管理，其中name與group必須唯一\n為何要將Job和Trigger分開來? While developing Quartz, we decided that it made sense to create a separation between the schedule and the work to be performed on that schedule. This has (in our opinion) many benefits.\nFor example, Jobs can be created and stored in the job scheduler independent of a trigger, and many triggers can be associated with the same job. Another benefit of this loose-coupling is the ability to configure jobs that remain in the scheduler after their associated triggers have expired, so that that it can be rescheduled later, without having to re-define it. It also allows you to modify or replace a trigger without having to re-define its associated job.\nJob與JobDetail的一些說明 Job是正在執行的作業，JobDetail則是作業的定義 一個Job可以創建多個JobDetail，擁有不同的JobDataMap 舉例來說，今天寫了一個定時寄送信件的Job，叫做SendEmailJob，我們希望這個Job可以寄給客戶，然後在cc給你的主管，所以需要創建兩個不同的JobDetail，比如說SendEmailToClient、SendEmailToAdministor，並透過JobDataMap綁定參數傳遞至JobDetail中，這兩個JobDetail擁有各自獨立的JobDataMap，實現起來會更靈活。\n參考 官方文檔\n任務排程框架Quartz快速入門\nQuartz教學基礎\n觸發器詳細定義\n","date":"2022-10-06T23:14:21+08:00","image":"https://i.imgur.com/9or5BzU.png","permalink":"https://hoxtonhsu.com/p/java%E5%85%A7%E7%9A%84%E6%8E%92%E7%A8%8B%E5%99%A8%E4%BB%8B%E7%B4%B9/","title":"Java內的排程器介紹"}]