[{"content":"前言 前一陣子花了65,000買了一台Macbook，不得不說，使用體驗還是覺得像一坨答辯一樣，很多東西都要自己來。用了快一個月左右，還是有很多地方不適應，最直觀的體驗就是Terinal吧，Windows有一個非常強的Termianl介面叫做Window Termianl，它的畫面設計還有使用體驗，海放了Iterm不知道幾條街吧，尤其是window鍵+`，快速開啟Terminal的功能至今讓我難以忘懷。換到Mac上，我試著熟悉左右切換視窗的方式來模擬那熟悉的感覺，但切換的動畫的那一秒還是讓我煩躁不已。於是搜尋了一下，發現Iterm本身就有內建如同Window Terminal快速開啟Terminal的方式。｀\n設定 將Exculde from Dock\u0026hellip;的設定打開\n再將A hotkey opens a dedicated window \u0026hellip;打開\n設定你自己想要的快捷鍵，我就設成跟window一樣的設定了\n","date":"2023-06-15T16:32:19+08:00","image":"https://i.imgur.com/w12QKbR.png","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E8%AE%93iterm2%E6%93%81%E6%9C%89%E5%A6%82window-terminal%E8%88%AC%E7%9A%84%E7%B5%B2%E6%BB%91%E9%AB%94%E9%A9%97/","title":"如何讓Iterm2擁有如Window Terminal般的絲滑體驗"},{"content":"","date":"2023-06-15T16:31:38+08:00","permalink":"https://hoxtonhsu.com/p/ans/","title":"%Ans%"},{"content":"教學 可以先輸入\n1  env   來查看自己目前的環境變數有什麼\n再來透過\n1  vim ~/.bash_profile   來編輯bash_profile，編輯裡面的內容\n1  export DESKTOP=\u0026#34;$HOME/Desktop\u0026#34;   之後再輸入\n1  source ~/.bash_profile   這樣就可以囉！\n之後可以再輸入一次env，來確認環境變數有被加入到系統中\n結果展示 ","date":"2023-06-14T15:34:15+08:00","image":"https://i.imgur.com/O9emCTx.png","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E7%82%BAmac%E8%A8%AD%E5%AE%9A%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8/","title":"如何為Mac設定環境變數"},{"content":"在遠端的電腦上輸入\n1  sudo ufw allow 8081   將8081 Port曝露出來\n這樣外部就可以透過\nhttp://{ip-address}:8081/\n來訪問網站了\n","date":"2023-05-20T11:40:25+08:00","image":"https://i.imgur.com/qKt7ANw.png","permalink":"https://hoxtonhsu.com/p/%E5%B0%87linux%E7%9A%84port%E6%89%93%E9%96%8B%E8%AE%93%E5%A4%96%E9%83%A8%E5%8F%AF%E4%BB%A5%E8%A8%AA%E5%95%8F/","title":"將Linux的Port打開，讓外部可以訪問"},{"content":"前一陣子買了Mac，讓Mac可以用Terminal開啟IntelliJ，關於Mac的設定可以查看這篇文章，但這是一直遲遲沒有把windows也設定起來，但今天它來啦！\n實際演示 教學  將IntelliJ的bin加到Path中   PATH是一個包含多個路徑的環境變數，系統使用它來尋找執行檔案。當你在命令提示字元或終端中輸入一個命令時，系統會檢查這些路徑，看是否有包含該命令的可執行檔案。\n 1  setx PATH \u0026#34;%PATH%;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1.2\\bin\u0026#34;   切到IntelliJ的資料夾中  1  cd C:\\Program Files\\JetBrains\\IntelliJ IDEA 2023.1.2\\bin   ​\t其實做到這邊就差不多了，你已經可以使用\n1  idea .   ​\t來開啟檔案了，但如果這樣子你會發現你的termianl在啟動專案的時候就\t被佔用了，原因是因為這個指令是在用\\bin底下的idea.bat啟動，於是我\t們要改成用idea64.exe的方式來開啟檔案，需要做以下的步驟\n將名稱為idea的bat檔命名為idea64   其實要命名成什麼都沒差，不要再叫idea就好\n 將idea64.exe的檔案命名為idea  將idea64.exe.vmoptions命名為idea.exe.vmoptions   如果不改的話，會出現找不到intelliJ 找不到vm option的問題\n 這樣就可以用idea .來 開啟檔案了\n注意事項 這樣的修改會導致桌面的捷徑出現問題，因為我們把啟動的程式從idea64.exe重新命名成idea.exe了，所以需要重新建立一個新的桌面捷徑\n","date":"2023-05-19T20:56:38+08:00","image":"https://i.imgur.com/fkzGuEX.jpg","permalink":"https://hoxtonhsu.com/p/windows%E7%B3%BB%E7%B5%B1%E4%B8%AD%E4%BD%BF%E7%94%A8terminal%E9%96%8B%E5%95%9Fintellij/","title":"Windows系統中，使用Terminal開啟IntelliJ"},{"content":"前言 一直以來都覺得要在資料夾內搜尋是一件很麻煩的事情，原因是這樣的，我文章的資料夾長這樣\n他的排序基本上就是依照英文字母(或ASCII)的方式排序，但我更希望的是他可依照我創建的時間排序。我是可以在windons總管和Finder內指定想要的排序方式，但我在線上的Github.dev不能，於是我就想讓我的每篇文章在創建的時後，能夠在前面的資料夾內加上排序，最早創立的是1，其次是2，以此類推\u0026hellip;\n實際操作 詳細的shellscript語法如下\n1 2 3 4 5 6 7 8 9 10 11  echo \u0026#34;請輸入文章標題\u0026#34; read title # cd content/post/$title # 讀取資料夾內的檔案數量，為文章資料夾命名 file_count=$(ls -1 content/post| wc -l) file_count=\u0026#34;${file_count// /}\u0026#34; # 去除file_count包含的空白 titleWithNumber=$file_count-$title hugo new post/$titleWithNumber/index.md cd content/post/$titleWithNumber open index.md cd ../../..   需要關注的就是那個file_count，那段就是去讀資料夾內當前的檔案數並回報，值得注意的是他取出來的值前面是會帶一個空白的，比如說\n1  51   這樣子，所以需要再把它的空白去掉，這樣就可以在後面以字串串接的方式將文章的標題自動帶上編號了\n","date":"2023-05-19T15:06:55+08:00","image":"https://i.imgur.com/mdbKbaT.png","permalink":"https://hoxtonhsu.com/p/%E4%BD%BF%E7%94%A8shellscript%E8%AE%80%E5%8F%96%E8%B3%87%E6%96%99%E5%A4%BE%E4%B8%AD%E7%9A%84%E6%AA%94%E6%A1%88%E5%80%8B%E6%95%B8/","title":"使用shellScript讀取資料夾中的檔案個數"},{"content":"前言 前陣子買了Mac，影響我最大的應該就是不能再像Window一樣，使用右鍵開啟專案了！因為公司的產品有兩個專案，我也常常把專案砍掉重抓，如果不能用右鍵開啟，那就得從中手動匯入，這樣子一來一往真的是靠北麻煩。\n如何使用Terminal開啟 其實網路上我看了很多教學，大概看了4、5天吧，到最後我才發現其實官網就有寫了，原來幸福的青鳥一直就在身邊，唉垃圾Mac\nhttps://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html\n切換至/usr/local/bin/ 首先先切換至\n1  cd /usr/local/bin/   創建idea檔案 1  touch idea   編輯idea檔案中的內容 1 2 3  #!/bin/sh  open -na \u0026#34; IDEA.app\u0026#34; --args \u0026#34;$@\u0026#34;   這一步我個人覺得算是「寫一個script腳本」然後讓terminal去運行，可以輸入\n1  env   發現我們的PATH變數中有包含\n1  /usr/local/bin   也就是我們idea腳本所儲存的位置\n存擋後使用Chmod調整權限 輸入指令\n1  chmod 755 idea   \u0026ldquo;chmod 755\u0026rdquo; 是一個用於設置檔案或目錄權限的命令。在 Linux 和其他類 Unix 系統中，\u0026ldquo;chmod\u0026rdquo; 是改變檔案權限的指令，而 \u0026ldquo;755\u0026rdquo; 是一個表示權限的數字。\n在 \u0026ldquo;chmod 755\u0026rdquo; 中，\u0026ldquo;755\u0026rdquo; 是由三個數字組成的權限表示法。每個數字代表了不同的使用者類別和他們對檔案的權限。\n第一個數字（7）表示檔案所有者的權限。在這種情況下，7 表示所有者具有讀取、寫入和執行的權限（4 + 2 + 1）。 第二個數字（5）表示檔案所屬群組的權限。在這種情況下，5 表示群組具有讀取和執行的權限，但沒有寫入的權限（4 + 1）。 第三個數字（5）表示其他使用者（非所有者且非群組成員）的權限。在這種情況下，5 表示其他使用者具有讀取和執行的權限，但沒有寫入的權限（4 + 1）。 因此，\u0026ldquo;chmod 755\u0026rdquo; 的含義是將檔案設置為擁有者具有讀取、寫入和執行權限，群組成員和其他使用者具有讀取和執行權限，但不具有寫入權限。\n刷新頁面 確認mac os的檔案icon是否有更改成exec\n如果更改成功，就可以透過\n1  idea .   使用開啟檔案了 ！\n以下內容作廢，請勿參考，這是我錯的紀錄 如何在Mac中設置環境變數開啟IDEA\n在Terminal中輸入\n1  vim ~/.bash_profile   進入輸入畫面後，輸入以下資訊\n1  export PATH=\u0026#34;/Applications/ IDEA.app/Contents/MacOS:$PATH\u0026#34;   儲存後退出，並輸入\n1  source ~/.bash_profile   即可使用\n1  idea .   用Idea開啟當前目錄\n也可在terminal輸入\n1  env   來查看目前的環境變數，確定是否有加入PATH中\n1  open -na \u0026#34; IDEA.app\u0026#34; --args \u0026#34;$@\u0026#34;   ","date":"2023-05-18T21:22:51+08:00","image":"https://i.imgur.com/AEhodYS.png","permalink":"https://hoxtonhsu.com/p/%E5%9C%A8macbook-m1%E7%92%B0%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8terimnal%E9%96%8B%E5%95%9F/","title":"在MacBook M1環境下使用Terimnal開啟"},{"content":"導因 M1的CPU是使用ARM架構，而有些電腦則是使用x86架構，並且因Docker是Run在OS上方，所以在執行Image時也要考慮作業系統的問題\n1  The requested image\u0026#39;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested   解決方法 在docker run啟動參數後加上--platform linux/amd64即可解決這個問題\n1  docker run --platform linux/amd64 -p 8080:8080 fe744192d855   解決方法二 幹你媽的，我發現run的時候還是不行，還是要在build就控制它的架構\n1  docker build . --platform linux/x86_64   ","date":"2023-05-13T19:09:41+08:00","image":"https://i.imgur.com/8XJ9XWE.png","permalink":"https://hoxtonhsu.com/p/arm%E6%9E%B6%E6%A7%8B%E8%88%87x86%E6%9E%B6%E6%A7%8B%E4%B8%8Bdocker%E5%95%9F%E5%8B%95%E5%95%8F%E9%A1%8C/","title":"ARM架構與x86架構下，Docker啟動問題"},{"content":"簡介 最近要換新工作了，正好新工作的公司有電腦補助，就趁這個機會把Macbook也買了，一拿到手之後發現超級難用，難用到靠北，真的不懂為什麼一堆人說好用。\n如何更改Termial預設路徑 預設情況下，Terminal路徑都是\n1  /Users/[使用者名稱]   但我希望他開啟的路徑是\n1  /Users/[使用者名稱]/Desktop   因此要到.zshrc去更改\n通常這個檔案都會放在\n/Users/[使用者名稱]底下，如果沒有的話可以自己創一個就好\n然後編輯裡面的內容，加上這段\n1  cd /Users/hoxtonashes/Desktop   這樣下次開啟的時候，預設的Terminal路徑就會是Desktop了\n","date":"2023-05-13T17:44:38+08:00","image":"https://i.imgur.com/ieJ6kkK.png","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9mac-terminal%E7%9A%84%E9%A0%90%E8%A8%AD%E8%B7%AF%E5%BE%91/","title":"如何更改Mac terminal的預設路徑"},{"content":"在IntelliJ開啟以下的路徑\nSetting \u0026gt; Editor \u0026gt; File and Code Templates \u0026gt; Includes \u0026gt; File Header\n即可在這邊編輯創建Class的模板，一旦設定好後，當你創建一個新的Class時，IntelliJ就會在你的Class上插入這些資訊\n","date":"2023-05-12T15:41:07+08:00","image":"https://i.imgur.com/dEvsZm3.png","permalink":"https://hoxtonhsu.com/p/%E5%9C%A8intellij%E4%B8%AD%E8%A8%AD%E5%AE%9Aclass%E6%A8%A1%E6%9D%BF/","title":"在IntelliJ中設定Class模板"},{"content":"介紹 最近公司提倡使用rebase而非merge來合併分支，但在rebase的情況下，常常出現多種commit會有重複confict的情形發生，往往可能要解個2,30個conflict，一來一往可能會耗費許多時間，於是上網查了一下，發現有\n1  git rerere   這種神奇的指令\n這是由3個單字縮寫所組成的指令，分別是reuse、recorded 與 resolution。git rerere有點像是一個記憶吐司的概念，能夠記錄你之前解Conflict的方式，然後自動幫你套用到相同的地方。\n而這個rerere的行為預設是關閉的，想要打開的話可以輸入\n1  git config --global rerere.enabled true   來啟用，若不想要使用的話可以輸入\n1  git config --global --unset rerere.enabled   ","date":"2023-05-12T11:05:10+08:00","image":"https://i.imgur.com/FJcgPVI.png","permalink":"https://hoxtonhsu.com/p/git-rerere%E4%B9%8B%E4%BB%8B%E7%B4%B9/","title":"Git-rerere之介紹"},{"content":"最近換了一份新工作，發現我一直以來平淡無情的Maven原來也是有很多細節的（我一直以為就只是一個拿來自動下載Jar的無情機器而已），其實Maven的pom.xml的名稱其實就已經隱含了它的功能\nProject Object Model（專案物件模型）\n望文生義其實也可以感受到它就是用來管理專案、或專案與專案之間關係的一個檔案，這篇文章的主題是我想要了解Maven Module管理的部分\nMaven項目結構 超級POM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603  pom作为项目对象模型。通过xml表示maven项目，使用pom.xml来实现。 主要描述了项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt; \u0026lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;!--被继承的父项目的构件标识符--\u0026gt; \u0026lt;artifactId/\u0026gt; \u0026lt;!--被继承的父项目的全球唯一标识符--\u0026gt; \u0026lt;groupId/\u0026gt; \u0026lt;!--被继承的父项目的版本--\u0026gt; \u0026lt;version/\u0026gt; \u0026lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--\u0026gt; \u0026lt;groupId\u0026gt;asia.banseon\u0026lt;/groupId\u0026gt; \u0026lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。--\u0026gt; \u0026lt;artifactId\u0026gt;banseon-maven2\u0026lt;/artifactId\u0026gt; \u0026lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--项目的名称, Maven产生的文档用--\u0026gt; \u0026lt;name\u0026gt;banseon-maven\u0026lt;/name\u0026gt; \u0026lt;!--项目主页的URL, Maven产生的文档用--\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--\u0026gt; \u0026lt;description\u0026gt;A maven project to study maven.\u0026lt;/description\u0026gt; \u0026lt;!--描述了这个项目构建环境中的前提条件。--\u0026gt; \u0026lt;prerequisites\u0026gt; \u0026lt;!--构建该项目或使用该插件所需要的Maven的最低版本--\u0026gt; \u0026lt;maven/\u0026gt; \u0026lt;/prerequisites\u0026gt; \u0026lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;!--问题管理系统（例如jira）的名字，--\u0026gt; \u0026lt;system\u0026gt;jira\u0026lt;/system\u0026gt; \u0026lt;!--该项目使用的问题管理系统的URL--\u0026gt; \u0026lt;url\u0026gt;http://jira.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;!--项目持续集成信息--\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;!--持续集成系统的名字，例如continuum--\u0026gt; \u0026lt;system/\u0026gt; \u0026lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--\u0026gt; \u0026lt;notifiers\u0026gt; \u0026lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--\u0026gt; \u0026lt;notifier\u0026gt; \u0026lt;!--传送通知的途径--\u0026gt; \u0026lt;type/\u0026gt; \u0026lt;!--发生错误时是否通知--\u0026gt; \u0026lt;sendOnError/\u0026gt; \u0026lt;!--构建失败时是否通知--\u0026gt; \u0026lt;sendOnFailure/\u0026gt; \u0026lt;!--构建成功时是否通知--\u0026gt; \u0026lt;sendOnSuccess/\u0026gt; \u0026lt;!--发生警告时是否通知--\u0026gt; \u0026lt;sendOnWarning/\u0026gt; \u0026lt;!--不赞成使用。通知发送到哪里--\u0026gt; \u0026lt;address/\u0026gt; \u0026lt;!--扩展配置项--\u0026gt; \u0026lt;configuration/\u0026gt; \u0026lt;/notifier\u0026gt; \u0026lt;/notifiers\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--\u0026gt; \u0026lt;inceptionYear/\u0026gt; \u0026lt;!--项目相关邮件列表信息--\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;!--邮件的名称--\u0026gt; \u0026lt;name\u0026gt;Demo\u0026lt;/name\u0026gt; \u0026lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--\u0026gt; \u0026lt;post\u0026gt;banseon@126.com\u0026lt;/post\u0026gt; \u0026lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--\u0026gt; \u0026lt;subscribe\u0026gt;banseon@126.com\u0026lt;/subscribe\u0026gt; \u0026lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--\u0026gt; \u0026lt;unsubscribe\u0026gt;banseon@126.com\u0026lt;/unsubscribe\u0026gt; \u0026lt;!--你可以浏览邮件信息的URL--\u0026gt; \u0026lt;archive\u0026gt;http:/hi.baidu.com/banseon/demo/dev/\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;!--项目开发者列表--\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;!--某个项目开发者的信息--\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;!--SCM里项目开发者的唯一标识符--\u0026gt; \u0026lt;id\u0026gt;HELLO WORLD\u0026lt;/id\u0026gt; \u0026lt;!--项目开发者的全名--\u0026gt; \u0026lt;name\u0026gt;banseon\u0026lt;/name\u0026gt; \u0026lt;!--项目开发者的email--\u0026gt; \u0026lt;email\u0026gt;banseon@126.com\u0026lt;/email\u0026gt; \u0026lt;!--项目开发者的主页的URL--\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--\u0026gt; \u0026lt;roles\u0026gt; \u0026lt;role\u0026gt;Project Manager\u0026lt;/role\u0026gt; \u0026lt;role\u0026gt;Architect\u0026lt;/role\u0026gt; \u0026lt;/roles\u0026gt; \u0026lt;!--项目开发者所属组织--\u0026gt; \u0026lt;organization\u0026gt;demo\u0026lt;/organization\u0026gt; \u0026lt;!--项目开发者所属组织的URL--\u0026gt; \u0026lt;organizationUrl\u0026gt;http://hi.baidu.com/banseon\u0026lt;/organizationUrl\u0026gt; \u0026lt;!--项目开发者属性，如即时消息如何处理等--\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;dept\u0026gt;No\u0026lt;/dept\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--项目开发者所在时区， -11到12范围内的整数。--\u0026gt; \u0026lt;timezone\u0026gt;-5\u0026lt;/timezone\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;!--项目的其他贡献者列表--\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;!--项目的其他贡献者。参见developers/developer元素--\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name/\u0026gt;\u0026lt;email/\u0026gt;\u0026lt;url/\u0026gt;\u0026lt;organization/\u0026gt;\u0026lt;organizationUrl/\u0026gt;\u0026lt;roles/\u0026gt;\u0026lt;timezone/\u0026gt;\u0026lt;properties/\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--\u0026gt; \u0026lt;license\u0026gt; \u0026lt;!--license用于法律上的名称--\u0026gt; \u0026lt;name\u0026gt;Apache 2\u0026lt;/name\u0026gt; \u0026lt;!--官方的license正文页面的URL--\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon/LICENSE-2.0.txt\u0026lt;/url\u0026gt; \u0026lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--\u0026gt; \u0026lt;distribution\u0026gt;repo\u0026lt;/distribution\u0026gt; \u0026lt;!--关于license的补充信息--\u0026gt; \u0026lt;comments\u0026gt;A business-friendly OSS license\u0026lt;/comments\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--\u0026gt; \u0026lt;connection\u0026gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) \u0026lt;/connection\u0026gt; \u0026lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--\u0026gt; \u0026lt;developerConnection\u0026gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \u0026lt;/developerConnection\u0026gt; \u0026lt;!--当前代码的标签，在开发阶段默认为HEAD--\u0026gt; \u0026lt;tag/\u0026gt; \u0026lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--\u0026gt; \u0026lt;url\u0026gt;http://svn.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;!--描述项目所属组织的各种属性。Maven产生的文档用--\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;!--组织的全名--\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;!--组织主页的URL--\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;!--构建项目需要的信息--\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--\u0026gt; \u0026lt;sourceDirectory/\u0026gt; \u0026lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--\u0026gt; \u0026lt;scriptSourceDirectory/\u0026gt; \u0026lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--\u0026gt; \u0026lt;testSourceDirectory/\u0026gt; \u0026lt;!--被编译过的应用程序class文件存放的目录。--\u0026gt; \u0026lt;outputDirectory/\u0026gt; \u0026lt;!--被编译过的测试class文件存放的目录。--\u0026gt; \u0026lt;testOutputDirectory/\u0026gt; \u0026lt;!--使用来自该项目的一系列构建扩展--\u0026gt; \u0026lt;extensions\u0026gt; \u0026lt;!--描述使用到的构建扩展。--\u0026gt; \u0026lt;extension\u0026gt; \u0026lt;!--构建扩展的groupId--\u0026gt; \u0026lt;groupId/\u0026gt; \u0026lt;!--构建扩展的artifactId--\u0026gt; \u0026lt;artifactId/\u0026gt; \u0026lt;!--构建扩展的版本--\u0026gt; \u0026lt;version/\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/extensions\u0026gt; \u0026lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--\u0026gt; \u0026lt;defaultGoal/\u0026gt; \u0026lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!--这个元素描述了项目相关或测试相关的所有资源路径--\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--\u0026gt; \u0026lt;targetPath/\u0026gt; \u0026lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--\u0026gt; \u0026lt;filtering/\u0026gt; \u0026lt;!--描述存放资源的目录，该路径相对POM路径--\u0026gt; \u0026lt;directory/\u0026gt; \u0026lt;!--包含的模式列表，例如**/*.xml.--\u0026gt; \u0026lt;includes/\u0026gt; \u0026lt;!--排除的模式列表，例如**/*.xml--\u0026gt; \u0026lt;excludes/\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath/\u0026gt;\u0026lt;filtering/\u0026gt;\u0026lt;directory/\u0026gt;\u0026lt;includes/\u0026gt;\u0026lt;excludes/\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;!--构建产生的所有文件存放的目录--\u0026gt; \u0026lt;directory/\u0026gt; \u0026lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。--\u0026gt; \u0026lt;finalName/\u0026gt; \u0026lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--\u0026gt; \u0026lt;filters/\u0026gt; \u0026lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;!--使用的插件列表 。--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述插件所需要的信息。--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--插件在仓库里的group ID--\u0026gt; \u0026lt;groupId/\u0026gt; \u0026lt;!--插件在仓库里的artifact ID--\u0026gt; \u0026lt;artifactId/\u0026gt; \u0026lt;!--被使用的插件的版本（或版本范围）--\u0026gt; \u0026lt;version/\u0026gt; \u0026lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--\u0026gt; \u0026lt;extensions/\u0026gt; \u0026lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;!--execution元素包含了插件执行需要的信息--\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--\u0026gt; \u0026lt;id/\u0026gt; \u0026lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--\u0026gt; \u0026lt;phase/\u0026gt; \u0026lt;!--配置的执行目标--\u0026gt; \u0026lt;goals/\u0026gt; \u0026lt;!--配置是否被传播到子POM--\u0026gt; \u0026lt;inherited/\u0026gt; \u0026lt;!--作为DOM对象的配置--\u0026gt; \u0026lt;configuration/\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;!--项目引入插件所需要的额外依赖--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--任何配置是否被传播到子项目--\u0026gt; \u0026lt;inherited/\u0026gt; \u0026lt;!--作为DOM对象的配置--\u0026gt; \u0026lt;configuration/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;!--使用的插件列表--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId/\u0026gt;\u0026lt;artifactId/\u0026gt;\u0026lt;version/\u0026gt;\u0026lt;extensions/\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id/\u0026gt;\u0026lt;phase/\u0026gt;\u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--在列的项目构建profile，如果被激活，会修改构建处理--\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!--根据环境参数或命令行参数激活某个构建处理--\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--\u0026gt; \u0026lt;id/\u0026gt; \u0026lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--profile默认是否激活的标志--\u0026gt; \u0026lt;activeByDefault/\u0026gt; \u0026lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--\u0026gt; \u0026lt;jdk/\u0026gt; \u0026lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--\u0026gt; \u0026lt;os\u0026gt; \u0026lt;!--激活profile的操作系统的名字--\u0026gt; \u0026lt;name\u0026gt;Windows XP\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的操作系统所属家族(如 \u0026#39;windows\u0026#39;)--\u0026gt; \u0026lt;family\u0026gt;Windows\u0026lt;/family\u0026gt; \u0026lt;!--激活profile的操作系统体系结构 --\u0026gt; \u0026lt;arch\u0026gt;x86\u0026lt;/arch\u0026gt; \u0026lt;!--激活profile的操作系统版本--\u0026gt; \u0026lt;version\u0026gt;5.1.2600\u0026lt;/version\u0026gt; \u0026lt;/os\u0026gt; \u0026lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--\u0026gt; \u0026lt;property\u0026gt; \u0026lt;!--激活profile的属性的名称--\u0026gt; \u0026lt;name\u0026gt;mavenVersion\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的属性的值--\u0026gt; \u0026lt;value\u0026gt;2.0.3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--\u0026gt; \u0026lt;file\u0026gt; \u0026lt;!--如果指定的文件存在，则激活profile。--\u0026gt; \u0026lt;exists\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/\u0026lt;/exists\u0026gt; \u0026lt;!--如果指定的文件不存在，则激活profile。--\u0026gt; \u0026lt;missing\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/\u0026lt;/missing\u0026gt; \u0026lt;/file\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;!--构建项目所需要的信息。参见build元素--\u0026gt; \u0026lt;build\u0026gt; \u0026lt;defaultGoal/\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;targetPath/\u0026gt;\u0026lt;filtering/\u0026gt;\u0026lt;directory/\u0026gt;\u0026lt;includes/\u0026gt;\u0026lt;excludes/\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath/\u0026gt;\u0026lt;filtering/\u0026gt;\u0026lt;directory/\u0026gt;\u0026lt;includes/\u0026gt;\u0026lt;excludes/\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;directory/\u0026gt;\u0026lt;finalName/\u0026gt;\u0026lt;filters/\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId/\u0026gt;\u0026lt;artifactId/\u0026gt;\u0026lt;version/\u0026gt;\u0026lt;extensions/\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id/\u0026gt;\u0026lt;phase/\u0026gt;\u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId/\u0026gt;\u0026lt;artifactId/\u0026gt;\u0026lt;version/\u0026gt;\u0026lt;extensions/\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id/\u0026gt;\u0026lt;phase/\u0026gt;\u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals/\u0026gt;\u0026lt;inherited/\u0026gt;\u0026lt;configuration/\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--\u0026gt; \u0026lt;modules/\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。--\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--参见repositories/repository元素--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled/\u0026gt;\u0026lt;updatePolicy/\u0026gt;\u0026lt;checksumPolicy/\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled/\u0026gt;\u0026lt;updatePolicy/\u0026gt;\u0026lt;checksumPolicy/\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id/\u0026gt;\u0026lt;name/\u0026gt;\u0026lt;url/\u0026gt;\u0026lt;layout/\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled/\u0026gt;\u0026lt;updatePolicy/\u0026gt;\u0026lt;checksumPolicy/\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled/\u0026gt;\u0026lt;updatePolicy/\u0026gt;\u0026lt;checksumPolicy/\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id/\u0026gt;\u0026lt;name/\u0026gt;\u0026lt;url/\u0026gt;\u0026lt;layout/\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素.--\u0026gt; \u0026lt;reports/\u0026gt; \u0026lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--\u0026gt; \u0026lt;reporting\u0026gt; ...... \u0026lt;/reporting\u0026gt; \u0026lt;!--参见dependencyManagement元素--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--参见distributionManagement元素--\u0026gt; \u0026lt;distributionManagement\u0026gt; ...... \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--参见properties元素--\u0026gt; \u0026lt;properties/\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--\u0026gt; \u0026lt;modules/\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。--\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--包含需要连接到远程仓库的信息--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--如何处理远程仓库里发布版本的下载--\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\u0026gt; \u0026lt;enabled/\u0026gt; \u0026lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--\u0026gt; \u0026lt;updatePolicy/\u0026gt; \u0026lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--\u0026gt; \u0026lt;checksumPolicy/\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled/\u0026gt;\u0026lt;updatePolicy/\u0026gt;\u0026lt;checksumPolicy/\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--\u0026gt; \u0026lt;id\u0026gt;banseon-repository-proxy\u0026lt;/id\u0026gt; \u0026lt;!--远程仓库名称--\u0026gt; \u0026lt;name\u0026gt;banseon-repository-proxy\u0026lt;/name\u0026gt; \u0026lt;!--远程仓库URL，按protocol://hostname/path形式--\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.169:9999/repository/\u0026lt;/url\u0026gt; \u0026lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--\u0026gt; \u0026lt;pluginRepository\u0026gt; ...... \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!--依赖的group ID--\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;!--依赖的artifact ID--\u0026gt; \u0026lt;artifactId\u0026gt;maven-artifact\u0026lt;/artifactId\u0026gt; \u0026lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。--\u0026gt; \u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt; \u0026lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--\u0026gt; \u0026lt;classifier\u0026gt;\u0026lt;/classifier\u0026gt; \u0026lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。--\u0026gt; \u0026lt;systemPath\u0026gt;\u0026lt;/systemPath\u0026gt; \u0026lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素.--\u0026gt; \u0026lt;reports\u0026gt;\u0026lt;/reports\u0026gt; \u0026lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--\u0026gt; \u0026lt;reporting\u0026gt; \u0026lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--\u0026gt; \u0026lt;excludeDefaults/\u0026gt; \u0026lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。--\u0026gt; \u0026lt;outputDirectory/\u0026gt; \u0026lt;!--使用的报表插件和他们的配置。--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述报表插件需要的信息--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--报表插件在仓库里的group ID--\u0026gt; \u0026lt;groupId/\u0026gt; \u0026lt;!--报表插件在仓库里的artifact ID--\u0026gt; \u0026lt;artifactId/\u0026gt; \u0026lt;!--被使用的报表插件的版本（或版本范围）--\u0026gt; \u0026lt;version/\u0026gt; \u0026lt;!--任何配置是否被传播到子项目--\u0026gt; \u0026lt;inherited/\u0026gt; \u0026lt;!--报表插件的配置--\u0026gt; \u0026lt;configuration/\u0026gt; \u0026lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--\u0026gt; \u0026lt;reportSets\u0026gt; \u0026lt;!--表示报表的一个集合，以及产生该集合的配置--\u0026gt; \u0026lt;reportSet\u0026gt; \u0026lt;!--报表集合的唯一标识符，POM继承时用到--\u0026gt; \u0026lt;id/\u0026gt; \u0026lt;!--产生报表集合时，被使用的报表的配置--\u0026gt; \u0026lt;configuration/\u0026gt; \u0026lt;!--配置是否被继承到子POMs--\u0026gt; \u0026lt;inherited/\u0026gt; \u0026lt;!--这个集合里使用到哪些报表--\u0026gt; \u0026lt;reports/\u0026gt; \u0026lt;/reportSet\u0026gt; \u0026lt;/reportSets\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/reporting\u0026gt; \u0026lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。--\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素--\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--\u0026gt; \u0026lt;distributionManagement\u0026gt; \u0026lt;!--部署项目产生的构件到远程仓库需要的信息--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--\u0026gt; \u0026lt;uniqueVersion/\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;banseon maven2\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;file://${basedir}/target/deploy\u0026lt;/url\u0026gt; \u0026lt;layout/\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;uniqueVersion/\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Banseon-maven2 Snapshot Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot\u0026lt;/url\u0026gt; \u0026lt;layout/\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;!--部署项目的网站需要的信息--\u0026gt; \u0026lt;site\u0026gt; \u0026lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--\u0026gt; \u0026lt;id\u0026gt;banseon-site\u0026lt;/id\u0026gt; \u0026lt;!--部署位置的名称--\u0026gt; \u0026lt;name\u0026gt;business api website\u0026lt;/name\u0026gt; \u0026lt;!--部署位置的URL，按protocol://hostname/path形式--\u0026gt; \u0026lt;url\u0026gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \u0026lt;/url\u0026gt; \u0026lt;/site\u0026gt; \u0026lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--\u0026gt; \u0026lt;downloadUrl/\u0026gt; \u0026lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--\u0026gt; \u0026lt;relocation\u0026gt; \u0026lt;!--构件新的group ID--\u0026gt; \u0026lt;groupId/\u0026gt; \u0026lt;!--构件新的artifact ID--\u0026gt; \u0026lt;artifactId/\u0026gt; \u0026lt;!--构件新的版本号--\u0026gt; \u0026lt;version/\u0026gt; \u0026lt;!--显示给用户的，关于移动的额外信息，例如原因。--\u0026gt; \u0026lt;message/\u0026gt; \u0026lt;/relocation\u0026gt; \u0026lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。--\u0026gt; \u0026lt;status/\u0026gt; \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是\u0026lt;name\u0026gt;value\u0026lt;/name\u0026gt;。--\u0026gt; \u0026lt;properties/\u0026gt; \u0026lt;/project\u0026gt;   常用指令 顯示版本訊息  1  mvn -version    編譯Source Code  1  mvn compile   清除編譯完文件  1  mvn clean   打包成jar, war  1  mvn pakage   執行測試  1  mvn test   將打包的jar, war放到本地的repository,供其他項目使用  1  mvn install   查看啟用的profile  1  mvn help:active-profiles   Maven 命令參數 -D 傳入屬性參數 跳過單元測試 1  mvn pakage -Dmaven.test.skip=true   -P 使用指定的Profile配置 詳細請參考此影片\nhttps://www.bilibili.com/video/BV1Fz4y167p5?p=6\u0026amp;spm_id_from=pageDriver\u0026amp;vd_source=422eafa6570139128e44a83238959fa0\n在POM裡面定義了這些東西\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!--不同环境Profile的唯一id--\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!--profiles.active是自定义的字段（名字随便起），自定义字段可以有多个--\u0026gt; \u0026lt;profiles.active\u0026gt;dev\u0026lt;/profiles.active\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;profiles.active\u0026gt;prod\u0026lt;/profiles.active\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;test\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;profiles.active\u0026gt;test\u0026lt;/profiles.active\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  server.port=8080 spring.h2.console.enabled=true spring.h2.console.path=/h2 spring.sql.init.mode=always spring.datasource.url=jdbc:h2:~/dev;AUTO_SERVER=true spring.datasource.driver-class-name=org.h2.Driver spring.datasource.username=sa spring.datasource.password=sa spring.jpa.database-platform=org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update   在編譯project時\n使用\n1  mvn clean package -Pdev   則可使用dev環境的properties來打包專案\n不需要再手動在application.properties中修改\n配置MultiModule ☆☆☆☆☆ 可參考至此Repository\nhttps://github.com/Hoxton019030/SpringBoot-MultiModule-MVC-Structure/tree/main\n在原有的專案中新增Module\n根目錄的POM檔就會有相應的Module引入\n1 2 3 4 5 6 7  ... \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;service\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;dao\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;controller\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; ...   而子模塊的POM檔會紀錄副模塊的資訊\n1 2 3 4 5 6 7 8  ... \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;Maven_MultiModulePractice\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; ...   如果不特別設置的話，Parent的dependency會被child-module的project給繼承使用，所以例如Lombok這種東西就可以配置在parent module中，而gson這種東西，就可以專門配置在service-module中，避免POM檔無限制的增長\n指定不同開發環境 https://github.com/Hoxton019030/SpringBoot-MultiModule-MVC-Structure\n在開發中，常常會需要不同的開發環境，比如說本地開發時，可能會連接本地的Database，當上線到雲端後，可能會需要連接雲端的VM，於是就可以在POM裡面去指定不同的環境、不同的情況、不同的作業系統會執行不同的application.properties，相關的配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;hoxton.multimodule\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;major\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources/resource-${env}\u0026lt;/directory\u0026gt; \u0026lt;!-- 這邊的env對應到(1)--\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;env\u0026gt;dev\u0026lt;/env\u0026gt; \u0026lt;!--(1)--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;local\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;env\u0026gt;local\u0026lt;/env\u0026gt; \u0026lt;!--(1)--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;env\u0026gt;prod\u0026lt;/env\u0026gt; \u0026lt;!--(1)--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--這邊還有更多設定可以設定，比如說指定JDK版本、OS等等，但我現在懶得研究了--\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;artifactId\u0026gt;application\u0026lt;/artifactId\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;hoxton.multimodule\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;controller\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;   接著就可以用\n1  mvn clean package -Pdev   1  mvn clean package -Pprod   1  mvn clean package -Plocal   來打包成不同的jar了\n","date":"2023-05-09T09:47:13+08:00","image":"https://i.imgur.com/VcZp2b7.png","permalink":"https://hoxtonhsu.com/p/maven%E8%A9%B3%E7%B4%B0%E7%A0%94%E7%A9%B6/","title":"Maven詳細研究"},{"content":"依賴如下\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   配置如下\n1 2 3 4 5 6 7 8 9 10  server.port=8080 spring.h2.console.enabled=true spring.h2.console.path=/h2 spring.sql.init.mode=always spring.datasource.url=jdbc:h2:~/dev;AUTO_SERVER=true spring.datasource.driver-class-name=org.h2.Driver spring.datasource.username=sa spring.datasource.password=sa spring.jpa.database-platform=org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  server:port:8080spring:h2:console:enabled:truepath:/h2sql:init:mode:alwaysdatasource:url:jdbc:h2:~/test;AUTO_SERVER=true# ??????C/user/userName?????driver-class-name:org.h2.Driver#??driverusername:sapassword:sajpa:database-platform:org.hibernate.dialect.H2Dialecthibernate:ddl-auto:update  ","date":"2023-05-06T00:13:33+08:00","image":"https://i.imgur.com/xYmsInY.png","permalink":"https://hoxtonhsu.com/p/h2database%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%AA%94%E7%B4%80%E9%8C%84/","title":"H2Database之配置檔紀錄"},{"content":"設定環境變數 可以在此配置環境變數\n格式如下\n1  username=sa;password=sa   Application.properties之設置 使用${username}來獲取環境變數\n如下\n即可在專案中配置環境變數，並讓配置檔讀取\n","date":"2023-05-06T00:07:44+08:00","image":"https://i.imgur.com/lRrDIvY.png","permalink":"https://hoxtonhsu.com/p/%E5%9C%A8intellij%E8%A8%AD%E5%AE%9A%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8%E4%B8%A6%E8%AE%93application.properties%E8%AE%80%E5%8F%96/","title":"在IntelliJ設定環境變數，並讓Application.properties讀取"},{"content":"1  sudo lsof -i:8080\t  然後找到它的PID\n1  kill 31128   就可以了\n","date":"2023-05-03T16:25:22+08:00","image":"https://i.imgur.com/m3Lr6uG.png","permalink":"https://hoxtonhsu.com/p/macos%E5%A6%82%E4%BD%95%E7%B5%82%E6%AD%A2portprocess/","title":"MacOS如何終止port,process"},{"content":" 拆掉上次Commit  1  git reset HEAD^   ","date":"2023-05-03T14:01:35+08:00","image":"https://i.imgur.com/v0TYB05.png","permalink":"https://hoxtonhsu.com/p/git%E7%AD%86%E8%A8%98/","title":"Git筆記"},{"content":"參考影片\nDcard如何進行Cache 先Pass掉，\nDcard DataBase之選擇與調整 資料儲存類型、資料儲存量、資料是被大量儲存還是被修改?\nDcard之RDB選擇-Postgres\nMongGODB Dcard的通知、愛心，運用Mogodb的Sharding功能\nREDIS\n用來儲存User的Token，或是會大量被使用的資料\nCache實戰學習-Serving Post List\n除了最左邊的三張表以外，其他都是Materialize View，因為在實際取用文章時，學校、系所、性別相關的資訊、以及在哪一個看板，這樣的Materilize View在遇到Migration時就會遇到很大的問題，幾乎全部都要重寫\n使用Paging Service來替代Materlize View\nCase Studies Handle Reaction\n將Reaction的服務抽離出來，讓Loading降低\nQ\u0026amp;A\n","date":"2023-05-01T11:45:37+08:00","image":"https://i.imgur.com/dqGgQLi.png","permalink":"https://hoxtonhsu.com/p/dcard%E5%BE%8C%E7%AB%AF%E6%8A%80%E8%A1%93%E5%88%86%E4%BA%AB%E7%B4%94%E7%B4%80%E9%8C%84/","title":"Dcard後端技術分享－純紀錄"},{"content":"SpringBoot的Bean有三種注入方式\n @Autowired Constructor Injection Setting Injection  而官方推薦的是第二種的建構子注入，而Lombok有個註解叫做@RequiredArgsConstructor，它能夠產生一個只有final field的建構子\n就像這樣\n23行的@RequiredArgsConstructor，會創建MemberController底下的final field，也就是這樣\n1 2 3  public MemberController(MemberService memberService) { this.memberService = memberService; }   這樣一來我們的Service層跟Controller層就會更簡潔，當新的依賴進入後，不需要再重新寫一個建構子，只要將其宣告成final後，Lombok就會幫我們創建了\n","date":"2023-04-30T02:39:36+08:00","image":"https://i.imgur.com/1OBx1AG.png","permalink":"https://hoxtonhsu.com/p/%E7%B5%90%E5%90%88lombok%E5%AF%AB%E5%87%BA%E6%9B%B4%E6%95%B4%E6%BD%94%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC/","title":"結合Lombok寫出更整潔的程式碼"},{"content":"參考影片：Clean Architecture with Spring by Tom Hombergs @ Spring I/O 2019\n架構的目標  Facilitate Development Facilitate Deployment Facilitatte maintenance keep software soft keep frameworks of arm\u0026rsquo;s length keep options open  架構的終極目標 The Goal of software Achitecture is to minimize the lifetime cost of the software\n分層式(Layers)架構有什麼問題？ 分層架構是一種可靠的架構模式！但是如果沒有額外的限制，它們容易出現設計缺陷。 根據講者的經驗，我們有很多的架構是所謂的資料庫驅動設計(Database Driven design)\n在我們的Domain Layer，我們有Service Layer、Persistence Layer，裡面存在著我們的Entity以及JPA相關的一些資訊\n模糊的界線(Blurred Boundaries) 另一個關於Layer的議題是，我們通常會有一個工具類(utili)來封裝我們常用的一些函式庫，這些東西會在各層之間流竄，這樣會使得各層之間的關係越發模糊。\n難以測試 需要Mock很多東西，比如說Service、Repository。\n許多功能被隱藏起來了 假使我們有一個Order的系統，那我們所有對Order的CRUD都會集中在OrderService中，一旦這個方法有很多個，那麼很多方法(Functionality)就會被埋沒起來\n那麼如何解決這些問題呢 ？\nDo Circles Instead 再議SOLID設計模式 Dependency Inverision Principle 依賴反轉原則\n(左圖為Database Driven Development)\n影片戳記時間\n若要執行依賴反轉原則，那麼Domain層不應該依賴Persistence層，而是反轉過來，(Use Case等同於Service層)，\n這樣做的好處是什麼？我們可以選擇任何Code的依賴方向\nSingle Responsibility Priniciple 一個Class或一個Module只做一件事情\n一個Class或一個Module只能有一個原因被修改(Change)\n分層式架構下，若Persistence修改了，那麼Business層有很大機率也會連動修改，但在Clean Architecture的架構下，Persistence由於不處於最核心的部分(Entity)，因此不需要一起改動\n假使我們有一個Order Service，其中有三個user Roles，當其中一個User Roles改變後，我們就要去改動我們的Service\n但當我們把Service分割成不同的Use Cases，每一個Cases指對應一個Use Roles，那麼這個Use Case也只會有一個原因被修改\n Service應該被切割成許多不同的Use Case(First-Class Citizens)\n Only a Domain-Centric Architecture Allows Domian-Driven Design\nClean Architecture Hexagons 六角架構是Clean Architecture的具現化\n Input Port：對外暴露的API  use case class implements an input port, the input port is just a Java interface, then the use case class modifies the domain model\n問題時間：這個應用程式在做什麼？ 分層架構下，只透過Class名稱無法獲得有用的訊息\n六角架構中，將Service拆分成不同的Use Case，所有的職責會更加一目了然\n實作時間 Code連結：thombergs/buckpal\n\n\n\n\nSummary 如何強迫我們使用這個架構\n","date":"2023-04-25T10:24:57+08:00","image":"https://i.imgur.com/wlAKij1.jpg","permalink":"https://hoxtonhsu.com/p/spring%E4%B8%AD%E7%9A%84clean-architecture/","title":"Spring中的Clean Architecture"},{"content":"利用一個下午，把對Cherry Pick的一些問題整理成一篇文章，並且這個指令常常與Rebase, Merge兩者來對比，目前感覺如下\n   指令 merge rebase cherry pick     說明 將一條分支合進另一條分支中。不會破壞提交歷史的完整性，但缺點是合併後的提交歷史較為混亂，有時可能會產生冗長的提交歷史。 將當前分支與目標分支結合，並以目標分支為底(base)重新出發。將一個分支中的提交歷史應用到另一個分支上，使得目標分支中的提交歷史變得更加緊湊和簡潔 命令可以從一個分支中選擇單個提交，並將其應用到另一個分支上，通常用於需要特定提交的情況。只想要某個分支的某些commit，不希望把整個分支搬過來   指令 git merge salve git rebase main git cherry-pick c4   圖示      優點 簡單易操作，不破壞commit歷史 不產生多餘commit 與分支線 不會更動到Commit的歷史順序   缺點 會產生額外的分支合成線 不可以在共用分支上使用，否則將打斷commit順序，破壞commit完整性 若cherry pick commit過多，易產生重複的commit紀錄   應用場景 整合分支 用以取得別的分支整個進度 用以取得別的分支的個別進度    預覽 這是一個SpringBoot專案，Main分支目前長這樣，並且還有兩個協作者，分別是Hoxton跟Dallas\nSourceTree如下\nHoxton這個有四個Commit\n依序如下\n 創建MemberDao　f198 創建MemberService 185a 創建MemberController 310a 為MemberController新增一個方法 99b2 刪除MemberController fd8b  Dallas這個分支有兩個Commit\n 創建LoginContorller 7eb2 為LogingController新增一個方法 e92a  Main這個分支有一個Commit\n 創建README fce6  接下來在不同情境下，使用Cherry Pick，看看會有什麼結果與問題\n實際演練 Main需要hoxton的進度，其中有包含Main上未有的檔案(99b2) 結果：\n發生衝突，因Main上沒有MemberController。雖然最新的Commit 只有對MemberController更新，沒有創建MemberController的部分，但因為要Cherry Pick的關係，所以還是會把MemberController創建起來，並且其內容是最新的內容至於Service、Dao則不會帶過來，因為那是屬於別的Commit的，因此最終是長這樣，綠色部分是新增的部分\n hoxton-310a 創建Member Controller\n  hoxton-99b2 在Member Controller新增方法\n Main只需要Hoxton的幾個進度，其中的commit並非連續(310a, f198) 結果：\n將MemberController與Dao創建進來，其中不包含Dao，因為Cherry-pick的部分不包含，注意到的是，因為Cherry pick時我們的指令是這樣\n1  git cherry-pick 310a f198   因此Commit 的順序調換了，變成先Controller在Dao\n檔案長這樣\nMain只需要Hoxton的幾個進度，其中的commit並非連續(f198, 310a) 結果：\n將MemberController與Dao創建進來，其中不包含Service，因為Cherry-pick的部分不包含，注意到的是，因為我們Cherry Pick的指令如下\n1  git cherry-pick f198 310a   因此Commit 順序與hoxton上分支的順序一樣\n檔案長這樣\nCherry-pick一個只有刪除檔案的commit，是否能成功 fd8b這個Commit是將MemberController刪掉，在Main上cherry Pick後會發生什麼事情呢?\n結果\n結果：\n顯示\n Bad revision\n 直接不讓cherry-pick，我猜多半是因為這個Commit只有包含刪除，因此沒辦法pick\nCherry-pick一個範圍的commit，最終的結果呈現如何? 1  git cherry-pick f198 .. fd8b   結果：\n假設現在Dallas需要Hoxton的Commit，它合進去Main後會長什麼樣子呢? 如果兩邊合進Main之後會長怎麼樣呢？會不會兩邊都有重複的Commit導致畫面很亂呢?\n結果：\n會，合進去後會有許多重複的commit，因為Cherry pick過去後，雖然看起來一樣，但它們的Hash Code已經有所不同，因此會有重複的情形發生\n","date":"2023-04-16T17:30:28+08:00","image":"https://i.imgur.com/n1qX6TQ.gif","permalink":"https://hoxtonhsu.com/p/cherry-pick%E7%9A%84%E4%B8%80%E9%BB%9E%E7%A0%94%E7%A9%B6/","title":"Cherry Pick的一點研究"},{"content":"本文參考至MyBatis入門教學\n以及my-batis官方文件\n新增Maven依賴 1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   XML配置內容  此為預設的模板\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;org/mybatis/example/BlogMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   檔案大概配置成這樣\nXML具體配置內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;org.h2.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:h2:~/cherry;AUTO_SERVER=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;sa\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;org/example/BlogMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   配置BlogMapper.xml 於專案中，此Xml用以儲存SQL語句\n1 2 3 4 5 6 7 8 9  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;BlogMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectBlog\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from Blog where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   ","date":"2023-04-16T16:01:05+08:00","image":"https://i.imgur.com/wG62XWP.jpg","permalink":"https://hoxtonhsu.com/p/mybatis%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","title":"MyBatis學習筆記"},{"content":"導因 通常是因為在JPA的地方使用了@GeneratedValue(strategy = GenerationType.AUTO)這個註解，這個註解會由資料庫自動(AUTO)去配置，如果資料庫有就沒問題，但有些資料庫可能會沒有，比如說我用的資料庫是PostgresSQL就會出現這個問題\n解決方式\n將@GeneratedValue(strategy = GenerationType.AUTO)更改，更改為@GeneratedValue(strategy = GenerationType.IDENTITY)即可\n","date":"2023-04-16T03:55:44+08:00","image":"https://i.imgur.com/kdTSaSC.png","permalink":"https://hoxtonhsu.com/p/springboot%E5%95%9F%E5%8B%95%E6%99%82%E5%87%BA%E7%8F%BEmissing-table-hibernate-sequence%E4%B9%8B%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/","title":"SpringBoot啟動時，出現Missing table hibernate sequence之解決方法"},{"content":"前言 連假實在有點無聊，打算來手寫一個SprintBoot專案，來加深自己對這種IoC框架的理解，我打算把這個框架叫做Winter，象徵我每況愈下的人生，唉\nSprintBoot 單例池 本章所用到的程式碼存放在這\nhttps://github.com/Hoxton019030/Winter/tree/bean-scan-and-beandefinition\n一切開始的地方，Main 啟動類的寫法如下\n1 2 3 4 5  public class Main { public static void main(String[] args) { WinterApplicationContext applicationContext = new WinterApplicationContext(AppConfig.class); } }   這邊看到兩個陌生的Class，WinterApplicationContext，以及AppConfig。先講AppConfig是什麼，它是Winter的配置類，我們會在這邊去配置我們Winter Bean的位置在哪邊，所以我們要加上@ComponentScan這個註解，讓我們的Winter框架知道它要去什麼package底下找到Bean。這邊我們就先創這個Class就好，目前先不會寫到它。\nAppConfig 1 2 3 4 5 6 7  /** * Winter的配置文件 */ @ComponentScan(\u0026#34;org.hoxton.service\u0026#34;) public class AppConfig { }   @ComponentScan 1 2 3 4 5  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface ComponentScan { String value() default \u0026#34;\u0026#34; ; }   用來示意我們的Winter框架，要去哪邊找到我們的Bean，我們的Bean都會寫在org.hoxton.service這個路徑下面。\n@Component 這個大家熟的吧，將當前類變成一個Spring Bean的註解\n1 2 3 4 5 6  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Component { String value() default \u0026#34;\u0026#34;; }   @Scope 標示當前類所要創建的Bean是一個單例還是一個Prototype的Bean\n1 2 3 4 5  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Scope { String value(); }   UserService 用來假設MVC架構中的Service層\n1 2 3 4  @Component(\u0026#34;userService\u0026#34;) @Scope(\u0026#34;singleton\u0026#34;) public class UserService { }   WinterApplicationContext 這個類就是SpringBoot框架中的容器類，我們接下來要來手寫一個容器類，首先先創這個類出來，並且它要吃一個Class參數作為Constructor\n1 2 3 4 5 6 7  public class WinterApplicationContext { private Class configClass; public WinterApplicationContext(Class configClass){ this.configClass=configClass; } }   接下來我們寫一個方法，叫做Scan，這個Scan方法會去得到@ComponentScan這個註解的值，取得要掃描的Package路徑，取得路徑之後，會去掃描路徑底下有哪些類有被@Component這個註解所修飾，並且會去找尋@Scope這個註解，得知哪些Bean是Singleton，哪些Bean是prototype，將這些資訊放入\n1  private ConcurrentHashMap\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;();   這個ConcurrentHashMap中\n步驟  從Config類中取得ComponentScan註解的值，其值即為路徑  1 2 3 4 5 6  private void scan(Class configClass) { // 從Config類中取得ComponetScan註解的值，其值即為路徑  ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class); String path = componentScanAnnotation.value(); }    使用類加載，讀出Class檔案的資訊  1 2 3 4 5 6 7 8 9 10 11  private void scan(Class configClass) { // 從Config類中取得ComponentScan註解的值，其值即為路徑  ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class); String path = componentScanAnnotation.value(); //掃描 org.hoxton.service  // 類加載器 (Class Loader)  // Java中有三種類加載器，以及對應的加載路徑  // BootStrap ---\u0026gt; jre/lib  // Ext ---\u0026gt; jre/ext/lib  // App ---\u0026gt; classpath ---\u0026gt; \u0026#34;C:\\Program Files\\Java\\jdk-11\\bin\\java.exe\u0026#34; \u0026#34;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\lib\\idea_rt.jar=5445:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath C:\\Users\\hoxton\\Desktop\\Winter\\target\\classes org.hoxton.Test 編譯器顯示的資訊  }    BeanDefinition  我們先來討論一個東西叫做BeanDefinition，這個類用來描述一個Bean的資訊，我們目前讓這個類盡量簡單一點，我們只需要紀錄一個Bean它的類型以及它的作用範圍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public class BeanDefinition { /** * 當前Bean類型 */ private Class clazz; /** * 當前Bean作用範圍 */ private String scope; public BeanDefinition() { } public BeanDefinition(Class clazz, String scope) { this.clazz = clazz; this.scope = scope; } public Class getClazz() { return clazz; } public void setClazz(Class clazz) { this.clazz = clazz; } public String getScope() { return scope; } public void setScope(String scope) { this.scope = scope; } }   使用類加載器，依照@ComponentScan的值，去掃描底下的Bean，  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  private void scan(Class configClass) { ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class); String path = componentScanAnnotation.value(); //掃描路徑  //掃描 org.hoxton.service  // 類加載器 (Class Loader)  // Java中有三種類加載器，以及對應的加載路徑  // BootStrap ---\u0026gt; jre/lib  // Ext ---\u0026gt; jre/ext/lib  // App ---\u0026gt; classpath ---\u0026gt; \u0026#34;C:\\Program Files\\Java\\jdk-11\\bin\\java.exe\u0026#34; \u0026#34;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\lib\\idea_rt.jar=5445:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath C:\\Users\\za546\\Desktop\\Winter\\target\\classes org.hoxton.Test 編譯器顯示的資訊  ClassLoader classLoader = WinterApplicationContext.class.getClassLoader(); //app加載器  URL resource = classLoader.getResource(\u0026#34;org/hoxton/service\u0026#34;); //使用類加載，掃苗檔案下的.class檔  File file = new File(resource.getFile()); if (file.isDirectory()) { File[] files = file.listFiles(); for (File f : files) { String fileName = f.getAbsolutePath(); if (fileName.endsWith(\u0026#34;.class\u0026#34;)) { //若檔案以.class結尾即為.class檔，則進入流程判斷  String className = fileName.substring(fileName.indexOf(\u0026#34;org\u0026#34;), fileName.indexOf(\u0026#34;.class\u0026#34;)); className = className.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;.\u0026#34;); Class\u0026lt;?\u0026gt; clazz = null; try { clazz = classLoader.loadClass(className); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } if (clazz.isAnnotationPresent(Component.class)) { //類上若有@Component註解，代表為一個Bean  //表示這個類是個Bean  // ...? Class -- \u0026gt; bean ?  // 解析類，判斷當前Bean是單例Bean還是Prototype的Bean，生成BeanDefinition  Component componentAnnotation = clazz.getDeclaredAnnotation(Component.class); String beanName = componentAnnotation.value(); //取得@Component的值(bean名)  //BeanDefinition- Bean定義  BeanDefinition beanDefinition = new BeanDefinition(); //取得一個BeanDefinition物件  beanDefinition.setClazz(clazz); if (clazz.isAnnotationPresent(Scope.class)) { Scope scopeAnnotation = clazz.getDeclaredAnnotation(Scope.class); beanDefinition.setScope(scopeAnnotation.value()); } else { beanDefinition.setScope(SINGLETON); //沒加Scope註解，預設為單例  } beanDefinitionMap.put(beanName, beanDefinition); // 將beanDefinition放進ConcurrentHashMap中  } } } } }   我們先來稍微預覽一下整個Class完成後會長什麼樣子，讓大家更有一個概念  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  public class WinterApplicationContext { final String SINGLETON =\u0026#34;singleton\u0026#34;; private Class configClass; /** * 一個單例池，存放Spring Bean */ private ConcurrentHashMap\u0026lt;String, Object\u0026gt; singletonPool = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 存放所有Spring Bean的定義 */ private ConcurrentHashMap\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * @param configClass Winter的配置文件 */ public WinterApplicationContext(Class configClass) { this.configClass = configClass; //解析配置類  // ComponentScan註解解析 -\u0026gt; 掃描路徑 -\u0026gt; 掃描 ---\u0026gt; BeanDefinition ---\u0026gt; BeanDefinitionMap  scan(configClass); for (String beanName : beanDefinitionMap.keySet()) { BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); //如果bean scope是單例，則放進單例池中  if(beanDefinition.getScope().equals(SINGLETON)){ Object bean = createBean(beanDefinition); singletonPool.put(beanName, bean); } } } public Object createBean(BeanDefinition beanDefinition){ Class clazz = beanDefinition.getClazz(); try { Object instance = clazz.getDeclaredConstructor().newInstance(); return instance; } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } catch (InvocationTargetException e) { throw new RuntimeException(e); } catch (NoSuchMethodException e) { throw new RuntimeException(e); } } private void scan(Class configClass) { ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class); String path = componentScanAnnotation.value(); //掃描路徑  //掃描 org.hoxton.service  // 類加載器 (Class Loader)  // Java中有三種類加載器，以及對應的加載路徑  // BootStrap ---\u0026gt; jre/lib  // Ext ---\u0026gt; jre/ext/lib  // App ---\u0026gt; classpath ---\u0026gt; \u0026#34;C:\\Program Files\\Java\\jdk-11\\bin\\java.exe\u0026#34; \u0026#34;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\lib\\idea_rt.jar=5445:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.2.2\\bin\u0026#34; -Dfile.encoding=UTF-8 -classpath C:\\Users\\za546\\Desktop\\Winter\\target\\classes org.hoxton.Test 編譯器顯示的資訊  ClassLoader classLoader = WinterApplicationContext.class.getClassLoader(); //app加載器  URL resource = classLoader.getResource(\u0026#34;org/hoxton/service\u0026#34;); //使用類加載，掃苗檔案下的.class檔  File file = new File(resource.getFile()); if (file.isDirectory()) { File[] files = file.listFiles(); for (File f : files) { String fileName = f.getAbsolutePath(); if (fileName.endsWith(\u0026#34;.class\u0026#34;)) { String className = fileName.substring(fileName.indexOf(\u0026#34;org\u0026#34;), fileName.indexOf(\u0026#34;.class\u0026#34;)); className = className.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;.\u0026#34;); Class\u0026lt;?\u0026gt; clazz = null; try { clazz = classLoader.loadClass(className); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } if (clazz.isAnnotationPresent(Component.class)) { //表示這個類是個Bean  // ...? Class -- \u0026gt; bean ?  // 解析類，判斷當前Bean是單例Bean還是Prototype的Bean，生成BeanDefinition  Component componentAnnotation = clazz.getDeclaredAnnotation(Component.class); String beanName = componentAnnotation.value(); //BeanDefinition- Bean定義  BeanDefinition beanDefinition = new BeanDefinition(); beanDefinition.setClazz(clazz); if (clazz.isAnnotationPresent(Scope.class)) { Scope scopeAnnotation = clazz.getDeclaredAnnotation(Scope.class); beanDefinition.setScope(scopeAnnotation.value()); } else { beanDefinition.setScope(SINGLETON); } beanDefinitionMap.put(beanName, beanDefinition); } } //  } } } public Object getBean(String beanName) { // 依照beanName去判斷是單例Bean還是Prototype Bean  if (beanDefinitionMap.containsKey(beanName)) { BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(SINGLETON)) { Object bean = singletonPool.get(beanName); return bean; } else { //創建bean對象嗎?  Object bean = createBean(beanDefinition); return bean; } } else { throw new NullPointerException(\u0026#34;沒有這個Bean\u0026#34;); } } }   接下來我們繼續回到WinterApplicationContext這個Constructor，我們已經把我們Package底下的Bean掃描完，放進beanDefinitionMap中，那我們接下來要依照這個Map，創建SINGLETON的bean，接著把SINGLETON的Bean放進singletonPool中，這個singletonPool也就是Spring中的單例池  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public WinterApplicationContext(Class configClass) { this.configClass = configClass; //解析配置類  // ComponentScan註解解析 -\u0026gt; 掃描路徑 -\u0026gt; 掃描 ---\u0026gt; BeanDefinition ---\u0026gt; BeanDefinitionMap  scan(configClass); for (String beanName : beanDefinitionMap.keySet()) { //遍整個beanDefinitionMap，找出單例的Bean，放進singletonPool中  BeanDefinition beanDefinition = beanDefinitionMap.get(beanName); //如果bean scope是單例，則放進單例池中  if(beanDefinition.getScope().equals(SINGLETON)){ Object bean = createBean(beanDefinition); singletonPool.put(beanName, bean); } } }   撰寫createBean方法會吃一個BeanDefinition為參數，這個方法會用BeanDefinition的Clazz創建一個Class，接著調用class底下的getDeclaredConstructor()取得建構子，並用newInstance()方法創造出一個那個bean的物件出來  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public Object createBean(BeanDefinition beanDefinition){ Class clazz = beanDefinition.getClazz(); try { Object instance = clazz.getDeclaredConstructor().newInstance(); return instance; } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } catch (InvocationTargetException e) { throw new RuntimeException(e); } catch (NoSuchMethodException e) { throw new RuntimeException(e); } }   到Main中，使用getBean來取得singletonpool中的Bean  1 2 3 4 5 6 7 8 9 10  public class Main { public static void main(String[] args) { WinterApplicationContext applicationContext = new WinterApplicationContext(AppConfig.class); System.out.println(\u0026#34;可以看到這三個的值是一模一樣的，代表這幾個物件都是同一個\u0026#34;); System.out.println(applicationContext.getBean(\u0026#34;userService\u0026#34;)); System.out.println(applicationContext.getBean(\u0026#34;userService\u0026#34;)); System.out.println(applicationContext.getBean(\u0026#34;userService\u0026#34;)); } }   這樣就是一個基礎的SprintBoot 單例池的創建\nAutowired之實現原理 To Be Continued \u0026hellip;\n","date":"2023-04-01T19:40:36+08:00","image":"https://i.imgur.com/1G2G1o4.png","permalink":"https://hoxtonhsu.com/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AF%ABsprintboot%E6%A1%86%E6%9E%B6/","title":"手把手教你寫SprintBoot框架"},{"content":"前一陣子在寫DiscordBot的時候，曾經在教學中看過這種寫法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class GymBotConfiguration { @Bean public \u0026lt;T extends Event\u0026gt;GatewayDiscordClient gatewayDiscordClient(final List\u0026lt;EventListener\u0026lt;T\u0026gt;\u0026gt; eventListeners){ final GatewayDiscordClient client = DiscordClientBuilder.create(token) .build() .login() .block(); for (EventListener\u0026lt;T\u0026gt; listener : eventListeners) { client.on(listener.getEventType()) .flatMap(listener::execute) .onErrorResume(listener::handleError) .subscribe(); } return client; } }   對於其中的寫法感到非常困惑，不知道為什麼回傳值前還會有泛型符號，直到最近在研究一些OpenSource的框架時，才又更了解這件事情。\n如何宣告泛型 在講這件事情之前，要先有個基礎知識，就是關於Java是如何宣告一個泛型Class的，其實就是在Class後面加上\u0026lt;T\u0026gt;就可以了\n1 2 3  public class Link\u0026lt;E\u0026gt; { }   如此一來，就可以在其他地方創建一個泛型的Link類\n1  Link link=new Link\u0026lt;Integer\u0026gt;;   現在我們在這個Link類裡新增一個方法\n1 2 3 4 5 6 7  public class Link\u0026lt;E\u0026gt; { public List\u0026lt;E\u0026gt; addToList(E t){ List\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(t); return list; } }   這個方法會把傳進來的值，包裝成一個ArrayList並回傳出去，而它參數的型別則是與Link的泛型一致，比如說\n1 2 3 4  public static main(String[] arg){ Link link=new Link\u0026lt;String\u0026gt;; List\u0026lt;String\u0026gt; list=link.add(\u0026#34;早安\u0026#34;); }   也就是說addToList這個方法的型別和Link的泛型型別是綁定在一起的。\n何謂回傳型別前的泛型 承上，因為方法的參數型別與類的泛型型別基本上綁定在一起，如果我宣告了一個Link\u0026lt;Integer\u0026gt;，我的addToList就只能吃Integer的參數，那為了要解決這種問題，就有了在回傳型別前的泛型的寫法，釋例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class Link\u0026lt;E\u0026gt; { public List\u0026lt;E\u0026gt; addToList(E t){ List\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(t); return list; } public\u0026lt;E\u0026gt;List\u0026lt;E\u0026gt; addToList2(E t){ List\u0026lt;E\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(t); return list; } }   可以看到addToList2這個方法的回傳值List\u0026lt;E\u0026gt;前，我加了一個\u0026lt;E\u0026gt;，先別管這個到底能做什麼，我們現在先使用這個方法看看\n這時候你發現了，addToList2能吃的參數變成Object類了，當我們輸入一個String\n輸入一個Double\n也可以輸入一個自定義的類\n可以感受到addToList跟addToList2的差異了嗎？沒錯，addToList2的泛型不受Link的影響，可以自己有自己的泛型\n應用 這樣的用法不只可以拿來用在泛型類裡的方法，也可以用在一個非泛型類，比如說\n1 2 3 4 5 6 7  public class Student { public List\u0026lt;Student\u0026gt; addPeopleList(Student student){ ArrayList\u0026lt;Student\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(student); return list; } }   今天我們希望這個addPeopleList的方法可以吃任何型別的參數，我們如果這樣寫是會報錯的\n原因就在於我們並沒有一個地方告訴編譯器，什麼是T，因為我們的Student類並不是一個泛型類，但實務上，我們又不太可能去修改原有的類，避免破壞掉一些東西，所以我們修改addPeopleList，讓它變成這樣\n如此一來，addPeopleList就可以吃任何型別的參數了，以上就是所謂的泛型方法約束。\n","date":"2023-04-01T00:03:03+08:00","image":"https://i.imgur.com/Y9pLlYY.png","permalink":"https://hoxtonhsu.com/p/java%E4%B8%AD%E5%9B%9E%E5%82%B3%E5%80%BC%E5%89%8D%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%A8%99%E8%AD%98%E7%AC%A6%E6%98%AF%E4%BB%80%E9%BA%BC%E6%84%8F%E6%80%9D%E5%91%A2/","title":"Java中回傳值前的泛型標識符是什麼意思呢"},{"content":"SpringBoot中想要從Application.properties中取的值，有兩種常見的方式，其中一種是利用@Value的方式\n@Value 1 2  @Value(\u0026#34;${app.version}) String version   Enviroment 另一種則是透過 Enviroment物件來取的\n1 2 3 4 5  private final Environment env; public String getAppVersion() { return environment.getProperty(\u0026#34;app.version\u0026#34;); }   以取值的表現形式來看 在某些情形下，我們可能會從applicaiton.properties中取出一個陣列值，比如說\n1  language=en,zh,jp   這時如果使用Enviroment來取，取出來的值會一個String，需要再透過轉換，將它變為一個String\n1 2 3 4 5 6 7 8 9 10 11  @Autowired private Environment env; public String[] getMyArrayProperty() { String propertyValue = env.getProperty(\u0026#34;my.array.property\u0026#34;); if (propertyValue != null) { return propertyValue.split(\u0026#34;,\u0026#34;); } else { return new String[0]; } }   但如果用@Value的方式來取值，則可以在宣告變數時，聲明它是一個String或是一個String[]，避免後續的轉換\n1 2  @Value(\u0026#34;${language}\u0026#34;) private String[] myArray;   以單元測試角度來看 這兩個表現形式幾乎一模一樣，都可以取得想要的部分，但最大差別就在單元測試時，由於@Value這個取值方式有賴將整個SpringBoot專案啟動才可以注入，在單元測試的環境下並沒有辦法做到這件事情。但相反的，由於Environment本身屬於一個外部依賴，我們可以很好的替代掉他\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Service public class VersionService { Environment environment; public VersionService(Environment environment) { this.environment = environment; } public String getEunoExAppVersion() { return environment.getProperty(\u0026#34;eunoex.version\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @ExtendWith(MockitoExtension.class) class VersionServiceTest { @Mock Environment environment; @InjectMocks VersionService versionService; @Test void getAppVersion_everythingFine_returnSuccessfully() { given(environment.getProperty(any())).willReturn(\u0026#34;v1.2.0\u0026#34;); String ExAppVersion = versionService.getAppVersion(); System.out.println(\u0026#34;AppVersion = \u0026#34; + AppVersion); } }   大概Guy4這樣\n","date":"2023-03-24T01:41:57Z","image":"https://i.imgur.com/UDvSvgw.png","permalink":"https://hoxtonhsu.com/p/%E8%AB%96value%E8%88%87environment%E4%B9%8B%E5%84%AA%E5%8A%A3/","title":"論@Value與Environment之優劣"},{"content":"安裝window terminal 至Microsoft Store安裝window terminal\n安裝Cmder Cmder載點\n並將它解壓縮後放置\n%USERPROFILE%/AppData/Roaming\n中\n也就是\nC:\\Users\\you_userName\\AppData\\Roaming\n設定環境變數 接著設定環境變數\n1 2  變數名稱：CMDER_ROOT 變數值：%USERPROFILE%/AppData/Roaming/cmder   1 2  變數名稱：ConEmuDir 變數值：%USERPROFILE%/AppData/Roaming/cmder/vendor/conemu-maximus5   設定window Termianl\n打開設定\n按左下角的開啟JSON檔案\n將下列這段貼上至JSON檔中的這個位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  { \u0026#34;background\u0026#34;: \u0026#34;#2E3436\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe /k %CMDER_ROOT%\\\\vendor\\\\init.bat\u0026#34;, \u0026#34;font\u0026#34;: { \u0026#34;face\u0026#34;: \u0026#34;Cascadia Code\u0026#34;, \u0026#34;size\u0026#34;: 10.0 }, \u0026#34;guid\u0026#34;: \u0026#34;{6d953325-a939-475d-a151-940cbd0302fb}\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;%CMDER_ROOT%\\\\icons\\\\cmder.ico\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Cmder\u0026#34;, \u0026#34;padding\u0026#34;: \u0026#34;15\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;%USERPROFILE%/Desktop\u0026#34; }   就像這樣子\n接著重開window terminal就可以囉~\n","date":"2023-03-21T10:40:57+08:00","image":"https://i.imgur.com/l3t70N4.png","permalink":"https://hoxtonhsu.com/p/%E5%9C%A8window-terminal%E4%B8%AD%E4%BD%BF%E7%94%A8cmder/","title":"在window Terminal中使用Cmder"},{"content":"前情提要 最近在學習zabbix時，安裝在Linux系統下時，透過Postman是可以正常取得資料的\n但是當我用Docker把Zabbix架設在Window環境下時卻一直出現\n1  File not found.   的錯誤\n發現錯誤 兩邊的版本、設置、Server Port都一樣，完全不知道到底發生了什麼問題，後來是透過網頁的開發人員工具才發現一小處的不同\n這是Linux環境下的API請求\n這是Window下的API請求\n聰明的你一定發現了，肏你媽的這兩個API請求的URL完全不一樣啊，幹你媽的\n解決方法 我個人猜應該是Docker在部屬的時候，不知道為什麼裡面檔案的結構層級直接跳過了\\zabbix這一層，直接變成http://localhost/api_jsonrpc.php的路徑。\n將URL改成正確地之後就能正常訪問了\n","date":"2023-03-16T06:41:23Z","image":"https://i.imgur.com/AP3wJLN.png","permalink":"https://hoxtonhsu.com/p/%E4%BD%BF%E7%94%A8docker%E5%9C%A8window%E6%9C%83%E5%87%BA%E7%8F%BE%E7%9A%84file-not-found%E5%95%8F%E9%A1%8C/","title":"使用Docker在window會出現的File Not Found問題"},{"content":"如果依照存在即合理的說法來看，Switch的存在確實是有解決一些問題，比如說一些要依照不同情況來回傳不同結果的Function，相較於用冗長的if-else，選擇用Switch確實是個不錯的解法。但當今天的Switch Case會增長的情況，在選擇使用它就會違反了OCP(開放擴充、封閉修改)的原則，亦即每次有新的情況出現，我們就得回頭去改Switch語法，新增不同的case，一來一往增加了維護的負擔，這邊分享一個我把switch語法拆解的方式，以供紀錄這樣子。\n情境 我在設計一款可以連結不同SQL Engine的程式，當用戶選擇了不同的SQL Engine，我能夠執行不同資料庫的語法來返回結果，圖示如下\n修改前 這是我的設計\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @RestController public class DatasourceController { DatabaseService databaseService; public DatasourceController(DatabaseService databaseService) { this.databaseService = databaseService; } @GetMapping(\u0026#34;/query\u0026#34;) public String query(@RequestBody QueryRequest queryRequest) throws SQLException, JsonProcessingException, ClassNotFoundException { return databaseService.query(queryRequest); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Service public class DatabaseServiceImp implements DatabaseService{ DatabaseDao databaseDao; public DatabaseServiceImp(DatabaseDao databaseDao) { this.databaseDao = databaseDao; } @Override public String query(QueryRequest queryRequest) throws SQLException, JsonProcessingException, ClassNotFoundException { String databaseName = queryRequest.getDatabaseEngine(); databaseDao = getDatabaseDao(databaseName); return databaseDao.connect().query(queryRequest.getQuery()); } private DatabaseDao getDatabaseDao(String databaseName) { switch (databaseName){ case \u0026#34;Postgres\u0026#34;: return new PostgresDaoImpl(); case \u0026#34;MsSql\u0026#34;: return new MySQLDaoImpl(); default: throw DatabaseNotFoundException.createDatabaseNotFoundException(\u0026#34;Not this Database\u0026#34;); } } }   1 2 3 4 5 6 7 8 9 10 11  @Repository public interface DatabaseDao { DatabaseDao connect() throws SQLException, ClassNotFoundException; void close() throws SQLException; String query(String query) throws SQLException, JsonProcessingException; }   我在Service層的地方會有一個methodgetDatabaseDao，來依照輸入的databaseName來將不同的Dao賦值進filed中，首先這有兩個問題\n 當資料庫在擴充時，必須要回頭修改getDatabaseDao，增加修改的成本 無法利用SpringBean的IoC，每次有新的Request近來，都會創造一個Dao的Object存在於記憶體中，造成記憶體空間的浪費  修改後 因此後來的修改必須得改善上面兩點，必須要符合OCP的規則，我只要新增新的Dao，而毋需修改就有的程式碼，並且還要使用SpringBean，以下是修改後的版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Service public class DatabaseServiceImp implements DatabaseService { DatabaseEngineDao databaseEngineDao; List\u0026lt;DatabaseEngineDao\u0026gt; databaseDaoList; public DatabaseServiceImp(List\u0026lt;DatabaseEngineDao\u0026gt; databaseDaoList) { this.databaseDaoList = databaseDaoList; } @Override public String query(QueryRequest queryRequest) throws SQLException, JsonProcessingException, ClassNotFoundException { String databaseName = queryRequest.getDatabaseEngine(); databaseEngineDao = getDatabaseDao(databaseName); return databaseEngineDao.connect().query(queryRequest.getQuery()); } private DatabaseEngineDao getDatabaseDao(String databaseEngine) { for (DatabaseEngineDao databaseDao : databaseDaoList) { if (databaseEngine.equals(databaseDao.getDatabaseEngineName())) { return databaseDao; } } throw DatabaseNotFoundException.createDatabaseNotFoundException(\u0026#34;Not Found This DatabaseEngine，請檢查是否有相應的databaseEngineName在DAO中\u0026#34;); } }   1 2 3 4 5 6 7 8  @Repository public interface DatabaseEngineDao { DatabaseEngineDao connect() throws SQLException; void close() throws SQLException; String query(String query) throws SQLException, JsonProcessingException; public String getDatabaseEngineName(); }   將原本的DatabaseDao databaseDao;修改為，List\u0026lt;DatabaseEngineDao\u0026gt; databaseDaoList;，在SpringBoot啟動時，將所有的DatabaseEngineDao類配置進databaseDaoList中，讓springBoot控制object的創建，並且將getDatabaseDao改寫，改成去for-each databaseDaoList，尋找List中是否有名稱符合的SQL Engine。並在DatabaseEngineDao Interface處新增getDatabaseEngineName，讓每個實作它的Impl都必須去完成這個method，完成了OCP的原則。\n","date":"2023-03-14T00:31:03+08:00","image":"https://i.imgur.com/rfkvgRO.png","permalink":"https://hoxtonhsu.com/p/%E9%81%8B%E7%94%A8arraylist%E8%88%87%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E5%B0%87swich%E8%AA%9E%E6%B3%95%E6%8B%86%E8%A7%A3/","title":"運用ArrayList與自動配置將Swich語法拆解"},{"content":"參考網址：監控大挑戰 - 以 Zabbix 為例\n為什麼選擇Zabbix? 目前常見的監控軟體有三者\n Zabbix Cacti Nagios  NagiOs的介面 Cacti的介面 Zabbix的介面    監控產品 Zabbix Nagios Cacti     圖形介面 好看 不是特別好 還行   監控性能 併發監控，對CPU要求較高 併發監控，對CPU要求較高 輪詢監控，效能低   配置難度 較低，有圖形化介面使用 需使用CommandLine 需使用CommandLine   自動發現 支持 不支持 不支持   異常通知方式 Email,簡訊,webhook,Line\u0026hellip; Email,簡訊,webhook,Line\u0026hellip; 較弱，預設只支援Email    Zabbix是什麼 Zabbix是一種開源的網絡監視和警報系統，用於監視各種網絡設備，包括服務器、網絡設備和應用程序等。Zabbix提供了一個可擴展的架構，可用於監視多個位置的數千個設備。\nZabbix支持各種監視方式，包括SNMP、JMX、IPMI和VMware監視，還可以通過自定義監視腳本進行擴展。Zabbix還提供了一個強大的報警系統，可以通過電子郵件、SMS和其他方式發送警報，以便快速解決問題。\nZabbix還提供了一個用戶友好的Web界面，可以輕鬆設置監視器和警報。Zabbix的開源設計使其成為一個非常有用的監視解決方案，可以滿足各種規模的企業和組織的需求\nZabbix術語 Zabbix Server\n Zabbix server是agent程序報告系統可用性、系統完整性和統計數據的核心組件，是所有配置訊息、統計訊息和操作數據的核心儲存器  Zabbix資料庫存取\n 所有配置訊息和Zabbix收集到的數據都被儲存在資料庫中  Zabbix Web介面\n 為了從任何地方和任何平台都可以輕鬆地訪問Zabbix，我們提供基於Web的Zabbix介面，該介面是Zabbix Server的一部分，通常(但不一定)跟Zabbix Server運行在同一台物理主機上  Zabbix Proxy 代理服務器\n Zabbix Proxy可以替Zabbix Server收集性能和可用性數據。Proxy代理服務器是Zabbix軟體可選擇部屬的一部分，當然，Proxy代理服務器可以幫助單台Zabbix Server分擔負載壓力  Zabbix Agent 監控代理\n Zabbix agent 監控代理，部屬在監控目標上，能夠主動間空本地資源和應用程序，並將收集到的數據報告給Zabbix Server  Zabbix數據流\n 監控方面，為了創造一個監控項(item)用於採集數據，必須先創建一個主機(host) 告警方面，在監控項裡面創造觸發器(trigger)，通過觸發器(trigger)來觸發告警動作(action)。因此如果你想收到Server XCPU負載過高的告警，必須滿足   為Server X創建一個Host並關聯一個用對CPU進行監控的監控項(item) 創建一個Trigger，設置成當CPU負載過高時會觸發 Trigger被觸發，發送告警郵件  雖然看起來有很多步驟，但是使用模板的話操作起來其實非常簡單，Zabbix這樣的設計使得配置機制非常靈活易用\n主機(Host)\n 一台你想監控的網路設備，用IP和域名表示  主機組(host Group)\n 主機的邏輯組；包含了主機和模板。一個主機裡的主機和模板之間並沒有任何直接的關聯，通常在給不同用戶組的主機分配權限時，使用主機組  監控項(item)\n 你想要接收的主機的特定數據，一個度量數據  觸發器(Trigger)\n 一個被用於定義問題閾值和\u0026quot;評估\u0026quot;監控項接受到的數據的邏輯表達式，當接收到的數據高於閾值時，觸發器從OK變成Problem狀態。當接收到的數據低於閾值時，觸發器保留/返回一個OK的狀態  事件(Event)\n 單次發生的需要注意的事情，例如觸發器狀態改變，或是發現有監控代理自動註冊  異常(Problem)\n 一個處在異常狀態的觸發器  動作(Action)\n 一個對事件做出反應的預定義的操作 一個動作由操作(例如發出通知)和條件(當時操作正在發生)組成  升級(Escalation)\n 一個在動作內執行操作的自定義場景；發生通知／執行遠程命令的序列  媒介(Media)\n 發送告警通知的手段；告警通知的途徑  通知(Notification)\n 利用已選擇的媒體途徑把跟事件相關的訊息發送給用戶  遠程命令(remote command)\n 一個預定義好的，滿足一些條件的情況下，可以在被監控主機上自動執行的命令  模板(template)\n 一組可以被應用到一個或多個主機上的實體(監控項、觸發器、圖形、聚合圖形、應用、LLD、Web場景)的集合 模板的任務就是加快對主機監控任務的實施；也可以使監控任務的批量修改更簡單。模板是直接關連到每台單獨的主機上  應用(Application)\n 一組監控項組成的邏輯分組  Web場景(Web Scenario)\n 利用一個或多個HTTP請求來檢查網站的可用性  前端(FrontEnd)\n Zabbix提供的Web介面  Zabbix API\n Zabbix API允許你使用JSON RPC協議(是一個無狀態且輕量級的遠程過程調用Remote Procedure Call 傳送協議，其傳遞內容透過JSON為主)來創建、更新和獲取Zabbix對象(如主機、監控項、圖形和其他)信息或者執行任何其他的字定義的任務  Zabbix Server\n Zabbix軟件實現監控的核心程序，主要功能是與Zabbix proxies和Agents進行交互、觸發器計算、發送告警通知、並將資料集中保存  Zabbix Agent\n 一個部屬在監控對象上的，能夠主動監控本地資源和應用的程序 Zabbix Agent部屬在監控的目標上，主動監測本地的資源和應用(硬體驅動、記憶體、處理器統計等等) Zabbix Agent收集本地的操作訊息並將資料報告給Zabbix Server用於進一步處理。一旦出現異常(比如硬碟空間已滿或者有崩潰的服務器Process)，Zabbix Server會主動警告管理員指定機器上的異常。Zabbix Agents的極端高校源於他可以利用本地系統調用來完成統計數據的收集  被動(Passive) 和 主動(Active)檢查\n Zabbix Agent可以執行被動和主動兩種檢查方式   被動檢查(Passive Check)模式中Agent應答數據請求，Zabbix Server(或者Proxy)詢問Agent資料，如CPU負仔狀況，然後Zabbix Agent回傳結果 主動檢查(Active Checks) 處理過程將相對複雜。Agent必須首先從Zabbix server索取監控項列表以進行獨立處理，然後週期性的發送新的值給Server  執行被動或主動檢查是通過選擇相應的監測項目類型來配置的。Item Type. Zabbix Agent處理監控項類型有Zabbix agent和 Zabbix Agent(Active)\nZabbix Proxy\n 一個幫助Zabbix server收集數據，分擔Zabbix Server負擔的程式 Zabbix Proxy是一個可以從一個或多個受監控設備收集監控數據，並將訊息結果發送到Zabbix Server的Process，基本上是代表Server工作的。所有收集的數據都在本地進行快取，然後傳送到Proxy所屬的Zabbix Server。 部屬Proxy是可選的，但是可能會非常有益於分散單個Zabbix Sever的負載，如果只有Proxy收集數據，Server上的進程就會減少，CPU消耗和磁碟I/O負載 Zabbix Proxy是完成遠端區域，分支機構，沒有本地管理員的網路集中監控的理想解決方案 Zabbix Proxy需要使用獨立的資料庫  使用Docker安裝 Zabbix 首先先點到下列網站 https://www.zabbix.com/documentation/5.0/en/manual/installation/containers\n並在這邊選擇要使用的版本 這次是使用官網提供的，也就是用mysql當database的版本\n並按照下列的cmd指令輸入，下面的參數，若有需要變可以在自行修改\n1  docker network create --subnet 172.20.0.0/16 --ip-range 172.20.240.0/20 zabbix-net    1  docker run --name postgres-server -t -e POSTGRES_USER=\u0026#34;zabbix\u0026#34; -e POSTGRES_PASSWORD=\u0026#34;zabbix_pwd\u0026#34; -e POSTGRES_DB=\u0026#34;zabbix\u0026#34; --network=zabbix-net --restart unless-stopped -d postgres:latest    1  docker run --name zabbix-snmptraps -t -v /zbx_instance/snmptraps:/var/lib/zabbix/snmptraps:rw -v /var/lib/zabbix/mibs:/usr/share/snmp/mibs:ro --network=zabbix-net -p 162:1162/udp --restart unless-stopped -d zabbix/zabbix-snmptraps:alpine-5.0-latest    1  docker run --name zabbix-server-pgsql -t -e DB_SERVER_HOST=\u0026#34;postgres-server\u0026#34; -e POSTGRES_USER=\u0026#34;zabbix\u0026#34; -e POSTGRES_PASSWORD=\u0026#34;zabbix_pwd\u0026#34; -e POSTGRES_DB=\u0026#34;zabbix\u0026#34; -e ZBX_ENABLE_SNMP_TRAPS=\u0026#34;true\u0026#34; --network=zabbix-net -p 10051:10051 --volumes-from zabbix-snmptraps --restart unless-stopped -d zabbix/zabbix-server-pgsql:alpine-5.0-latest    1  docker run --name zabbix-web-nginx-pgsql -t -e ZBX_SERVER_HOST=\u0026#34;zabbix-server-pgsql\u0026#34; -e DB_SERVER_HOST=\u0026#34;postgres-server\u0026#34; -e POSTGRES_USER=\u0026#34;zabbix\u0026#34; -e POSTGRES_PASSWORD=\u0026#34;zabbix_pwd\u0026#34; -e POSTGRES_DB=\u0026#34;zabbix\u0026#34; --network=zabbix-net -p 443:8443 -p 80:8080 -v /etc/ssl/nginx:/etc/ssl/nginx:ro --restart unless-stopped -d zabbix/zabbix-web-nginx-pgsql:alpine-5.0-latest   透過termianl訪問Container中的資料庫，以psql為例 1  docker exec -it [containerId] bash    1  psql -U zabbix -h localhost zabbix   當全部都設置好後\n訪問 http://localohst/ 即可訪問Zabbix頁面\n帳號：Admin 密碼：zabbix\n在Window下安裝 Zabbix Agent 這邊待補啦，不過先講一下Zabbix的Server端要怎麼對應\n​\tHost Name：要和當初設定Agent的Name一致\nGroup：Templates/Operating systems\nAgent：當Agent的那一台主機的IP\nTemlate：Template OS Windows by Zabbix agent\nAPI的使用 可以到下列的網站使用線上的Zabbix API Test\nhttps://sbcode.net/zabbix/zabbix-api-test-form/\nurl都是 http://localhost/api_jsonrpc.php，差別在於Body的內容\n測試用API，用以返回版本號 1 2 3 4 5 6 7  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;apiinfo.version\u0026#34;, \u0026#34;id\u0026#34;: 1, \u0026#34;auth\u0026#34;: null, \u0026#34;params\u0026#34;: {} }   返回的結果\n1 2 3 4 5  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: \u0026#34;5.0.32\u0026#34;, \u0026#34;id\u0026#34;: 1 }   登入用的API，用來取得Token 1 2 3 4 5 6 7 8 9 10  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;user.login\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;user\u0026#34;: \u0026#34;Admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;zabbix\u0026#34; }, \u0026#34;id\u0026#34;: 1, \u0026#34;auth\u0026#34;: null }   返回的結果\n1 2 3 4 5  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: \u0026#34;1a6022b1a01b787b2129d011763c73e6\u0026#34;, \u0026#34;id\u0026#34;: 1 }   result就是Token值\n返回目前存在的Agent 記得把Auth的值改成login返回的token\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;host.get\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;output\u0026#34;: [ \u0026#34;hostid\u0026#34;, \u0026#34;host\u0026#34; ], \u0026#34;selectInterfaces\u0026#34;: [ \u0026#34;interfaceid\u0026#34;, \u0026#34;ip\u0026#34; ] }, \u0026#34;id\u0026#34;: 2, \u0026#34;auth\u0026#34;: \u0026#34;1a6022b1a01b787b2129d011763c73e6\u0026#34; }   返回的結果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: [ { \u0026#34;hostid\u0026#34;: \u0026#34;10084\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Zabbix server\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34; } ] }, { \u0026#34;hostid\u0026#34;: \u0026#34;10438\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Ian\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.100.51\u0026#34; } ] }, { \u0026#34;hostid\u0026#34;: \u0026#34;10440\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.100.57\u0026#34; } ] }, { \u0026#34;hostid\u0026#34;: \u0026#34;10439\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Jess\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.100.51\u0026#34; } ] } ], \u0026#34;id\u0026#34;: 2 }   Zabbix API介紹 https://sbcode.net/zabbix/zabbix-api-test-form/\n在很多的API Parameter中，會常常看到\n1  {\u0026#34;output\u0026#34;: \u0026#34;extend\u0026#34;}   這段。這句話的意思是這樣的 output代表你想要返回的value值有什麼下面會有詳細的介紹 而extend則代表「請提供給我，更多的資訊」，詳細的差異如下\n我們假設 host.get的返回值為下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: [ { \u0026#34;hostid\u0026#34;: \u0026#34;10084\u0026#34;, \u0026#34;proxy_hostid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Zabbix server\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;disable_until\u0026#34;: \u0026#34;1679972679\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;Get value from agent failed: cannot connect to [[127.0.0.1]:10050]: [111] Connection refused\u0026#34;, \u0026#34;available\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;errors_from\u0026#34;: \u0026#34;1679019319\u0026#34;, \u0026#34;lastaccess\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ipmi_authtype\u0026#34;: \u0026#34;-1\u0026#34;, \u0026#34;ipmi_privilege\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;ipmi_username\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ipmi_password\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ipmi_disable_until\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ipmi_available\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;snmp_disable_until\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;snmp_available\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;maintenanceid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;maintenance_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;maintenance_type\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;maintenance_from\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ipmi_errors_from\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;snmp_errors_from\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;ipmi_error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;snmp_error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;jmx_disable_until\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;jmx_available\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;jmx_errors_from\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;jmx_error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Zabbix server\u0026#34;, \u0026#34;flags\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;templateid\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tls_connect\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;tls_accept\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;tls_issuer\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tls_subject\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tls_psk_identity\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;tls_psk\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;proxy_address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;auto_compress\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;inventory_mode\u0026#34;: \u0026#34;-1\u0026#34; } ], \u0026#34;id\u0026#34;: 2 }   但我們並不想要那麼多資訊，我們可能只想要其中幾項，比如說proxy_hostid,status而已，那我們就可以把我們Parameters的參數修改成這樣\n1  {\u0026#34;output\u0026#34;: [\u0026#34;hostid\u0026#34;,\u0026#34;proxy_hostid\u0026#34;]}   回傳的結果就會變成這樣 使用Zabbix來取得CPU Utilization (in %)  先使用host.get來取得所有host資訊  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;host.get\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;output\u0026#34;: [ \u0026#34;hostid\u0026#34;, \u0026#34;host\u0026#34; ], \u0026#34;selectInterfaces\u0026#34;: [ \u0026#34;interfaceid\u0026#34;, \u0026#34;ip\u0026#34; ] }, \u0026#34;id\u0026#34;: 2, \u0026#34;auth\u0026#34;: \u0026#34;7cdc68d62750b0ed7ae693d1d7a52466\u0026#34; }   返回的結果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: [ { \u0026#34;hostid\u0026#34;: \u0026#34;10084\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Zabbix server\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34; } ] }, { \u0026#34;hostid\u0026#34;: \u0026#34;10438\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Ian\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.100.51\u0026#34; } ] }, { \u0026#34;hostid\u0026#34;: \u0026#34;10440\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;Bill\u0026#34;, \u0026#34;interfaces\u0026#34;: [ { \u0026#34;interfaceid\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.100.57\u0026#34; } ] } ], \u0026#34;id\u0026#34;: 2 }   透過item.get取得hostId的資料  假設我們現在要找到hostId=10440的資料，我們的API BODY要這樣送\n1 2 3 4 5 6 7 8 9 10 11 12  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;item.get\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;output\u0026#34;:[\u0026#34;name\u0026#34;,\u0026#34;description\u0026#34;,\u0026#34;lastvalue\u0026#34;], \u0026#34;filter\u0026#34;:{ \u0026#34;hostid\u0026#34;:\u0026#34;10440\u0026#34; } }, \u0026#34;id\u0026#34;: 2, \u0026#34;auth\u0026#34;: \u0026#34;7cdc68d62750b0ed7ae693d1d7a52466\u0026#34; }   其中 output的值代表，只顯示name,description,lastvalue這幾個key的資料，filter則代表我只要key-value為hostid:10440的資料\n返回的結果很長，這邊講個大概就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: [ { \u0026#34;itemid\u0026#34;: \u0026#34;37631\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Interface Intel(R) Ethernet Connection (14) I219-V(乙太網路): Outbound packets with errors\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The number of outgoing packets with errors on the network interface.\u0026#34;, \u0026#34;lastvalue\u0026#34;: \u0026#34;0\u0026#34; }, { \u0026#34;itemid\u0026#34;: \u0026#34;37632\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Interface Intel(R) Ethernet Connection (14) I219-V(乙太網路): Inbound packets discarded\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The number of incoming packets dropped on the network interface.\u0026#34;, \u0026#34;lastvalue\u0026#34;: \u0026#34;0\u0026#34; }, { \u0026#34;itemid\u0026#34;: \u0026#34;37633\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Interface Intel(R) Ethernet Connection (14) I219-V(乙太網路): Inbound packets with errors\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The number of incoming packets with errors on the network interface.\u0026#34;, \u0026#34;lastvalue\u0026#34;: \u0026#34;0\u0026#34; }, { \u0026#34;itemid\u0026#34;: \u0026#34;37634\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Interface Intel(R) Ethernet Connection (14) I219-V(乙太網路): Bits received\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Incoming traffic on the network interface.\u0026#34;, \u0026#34;lastvalue\u0026#34;: \u0026#34;6431168\u0026#34; } ... //以下略.. }   找到CPU Utilization的資訊  搜尋關鍵字 CPU\n這邊，那個lastValue其實就是最新的CPU使用率，這樣就成功取得CPU的使用率囉！\n取得CPU Utilization的使用率  API Body如下\n1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;history.get\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;history\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;itemids\u0026#34;: \u0026#34;37631\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;extend\u0026#34; }, \u0026#34;auth\u0026#34;: \u0026#34;7cdc68d62750b0ed7ae693d1d7a52466\u0026#34;, \u0026#34;id\u0026#34;: 1 }   返回的結果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;result\u0026#34;: [ { \u0026#34;itemid\u0026#34;: \u0026#34;37568\u0026#34;, \u0026#34;clock\u0026#34;: \u0026#34;1679900528\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;5.186729\u0026#34;, \u0026#34;ns\u0026#34;: \u0026#34;297585693\u0026#34; }, { \u0026#34;itemid\u0026#34;: \u0026#34;37568\u0026#34;, \u0026#34;clock\u0026#34;: \u0026#34;1679900648\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;6.917095\u0026#34;, \u0026#34;ns\u0026#34;: \u0026#34;233421931\u0026#34; } // ... 略 ] }   使用Docker安裝，可能導致API路徑不正確 最近在學習zabbix時，安裝在Linux系統下時，透過Postman是可以正常取得資料的\n但是當我用Docker把Zabbix架設在Window環境下時卻一直出現\n1  File not found.   的錯誤\n發現錯誤 兩邊的版本、設置、Server Port都一樣，完全不知道到底發生了什麼問題，後來是透過網頁的開發人員工具才發現一小處的不同\n這是Linux環境下的API請求\n這是Window下的API請求\n聰明的你一定發現了，肏你媽的這兩個API請求的URL完全不一樣啊，幹你媽的\n解決方法 我個人猜應該是Docker在部屬的時候，不知道為什麼裡面檔案的結構層級直接跳過了\\zabbix這一層，直接變成http://localhost/api_jsonrpc.php的路徑。\n將URL改成正確地之後就能正常訪問了\n","date":"2023-03-13T05:40:02Z","image":"https://i.imgur.com/7g77ZiN.png","permalink":"https://hoxtonhsu.com/p/zabbix%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AD%86%E8%A8%98/","title":"Zabbix的一些筆記"},{"content":"介紹 PicGo是個開源的圖片上傳程式(並非平台)，由於設定快速，效果簡單而深受我的喜愛，決定寫一篇文章來介紹這東西該怎麼使用\n安裝 我們使用Choco來安裝，Choco是一個Window系統的檔案下載工具，可以做類似npm的功能，以下是它的安裝方式。\n使用系統管理員執行CMD，並輸入以下的指令\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;))   即下載成功，若下載成功，可以輸入\n1  choco --version   來查看是否安裝成功\n若Choco安裝沒問題，則可以透過以下指令安裝picGo，若跳出什麼無法存取，則請記得要使用系統管理員身分執行\n1  choco install picgo   使用 我有點懶得打，就錄成Gif了，這邊其實就是去Imgur的\nhttps://imgur.com/account/settings/apps\n這邊，去設定你的一個ClinetId\n然後把它貼到設定ClinetId那一欄就可以\n並且我也會推薦將上傳的快捷鍵調成Ctrl+Alt+V\n這樣當你按下Win+Shift+S，截圖後，只要按下Ctrl+Alt+V，圖片就會自動幫你上傳至Imgur囉\n","date":"2023-03-08T20:56:55+08:00","image":"https://i.imgur.com/teYQFXk.png","permalink":"https://hoxtonhsu.com/p/%E5%8F%AA%E8%A6%81%E6%8C%89%E5%80%8B%E9%8D%B5%E5%9C%96%E7%89%87%E7%AB%8B%E5%88%BB%E4%B8%8A%E5%82%B3%E8%87%B3%E9%9B%B2%E7%AB%AF-picgo%E4%BB%8B%E7%B4%B9/","title":"只要按個鍵，圖片立刻上傳至雲端 PicGo介紹"},{"content":"前言 每次在新電腦上使用Git的時候都會跳這個東西出來，但一直不知道這是啥，這次來研究一下\n總結 這東西其實是因為如果要推東西上去或是拉Private專案下來的話，會需要做認證(Credential)的部分，而這個視窗其實就是在問你，你所提供的這些登入資訊想存在哪邊?\n會建議就用預設的manager-core就好，如果想存在磁碟中的話就選store，如果想存在Cache就選cache 這樣就可以囉\n如果已經存了，那可以輸入以下的指令來調整\n 查看目前的credential.helper 是什麼  1  git config credential.helper    將credential.helper 的設定改掉  1  git config --global credential.helper manager-core    設定帳號密碼  由於自2021年後，GitHub不在提供使用帳號密碼的認證方式，要使用Token進行認證，帳號輸入自己的Github帳號，而密碼則是輸入自己的Token，這樣就設定成功囉！\n","date":"2023-03-08T20:48:18+08:00","image":"https://i.imgur.com/PFJUZO4.png","permalink":"https://hoxtonhsu.com/p/git%E5%9C%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%9A%84credentialhelperselector%E8%A9%B2%E6%80%8E%E9%BA%BC%E8%A8%AD%E5%AE%9A%E5%91%A2/","title":"Git在第一次使用的credentialhelperselector該怎麼設定呢"},{"content":"參考網站\n這篇文章是以Postgres SQL的語法為主，其他RDB的語法略有不同\n什麼是Store Procedure 預存程序（Stored Procedure）是一種資料庫對象，它是一個預編譯的SQL程式碼，可以在資料庫中存儲並重複使用。它通常由一系列SQL語句和編程邏輯組成，可以接受輸入參數、返回輸出參數和結果集。存儲過程通常由數據庫管理員或開發人員編寫和維護，並且可以在數據庫中執行。\n存儲過程有以下幾個優點：\n 提高了數據庫性能：存儲過程是預編譯的，一旦編譯就會存儲在數據庫中，執行速度快。此外，存儲過程可以減少客戶端與服務器之間的通信，從而降低網絡延遲，提高數據庫性能。 提高了數據安全性：存儲過程可以在數據庫層面上實現安全控制，可以限制某些用戶或角色的操作權限，從而保證數據的安全性。 代碼復用：存儲過程可以被多個應用程序或者腳本重複調用，從而實現代碼復用，減少重複編寫代碼的時間和工作量。 事務處理：存儲過程可以封裝事務處理邏輯，當多個SQL語句需要在一個事務中執行時，可以使用存儲過程將它們封裝在一個事務中，從而保證了數據的一致性和完整性。 簡化了複雜的操作：存儲過程可以將多個SQL語句組合成一個操作，從而簡化了複雜的操作，使得應用程序更易於開發和維護。  存儲過程可以實現很多功能，比如：\n 數據庫的備份和還原 數據庫的複製和同步 數據庫的日誌記錄和監控 數據庫的查詢優化 數據庫的數據加密和解密 數據庫的數據清洗和轉換 數據庫的業務邏輯實現 數據庫的存儲和檢索過程中的錯誤處理 數據庫的報表生成和匯出等。  Procedure與Function之差異 在PostgreSQL中，function和procedure都是儲存運算邏輯的物件，它們在設計目的和使用方式上略有不同。\nFunction主要是用於執行一個特定的計算或邏輯，返回一個單一的值或一個結果集，並且可以在SELECT語句、WHERE語句等中使用。Function可以返回一個或多個結果集，但只能返回一個值作為輸出，因此它被稱為有返回值的Function。\nProcedure主要用於執行一連串的操作，不返回結果集，通常是用來執行複雜的業務邏輯，如事務處理、資料庫管理等。Procedure可以執行INSERT、UPDATE、DELETE等數據操作，但是不能作為SELECT語句的一部分使用。Procedure不返回任何值或結果集，因此它被稱為無返回值的Procedure。\n在設計時，需要根據實際需求選擇使用哪種物件。如果需要執行一個特定的計算或邏輯，並返回一個結果集，則使用Function。如果需要執行一連串的操作並且不需要返回結果集，則使用Procedure。\n更直接的不同是，Procedure並沒有定義它自身的回傳值，連Returns void都沒有，而Function是有回傳值的，即使是Returns Void也是有回傳值\n創建procedure的語法 1 2 3 4 5 6 7  create or replace function test() LANGUAGE plpgsql AS $$ BEGIN END $$;   若加入RETURNS VOID則會回報錯誤\n創建Function的語法 1 2 3 4 5 6 7  create or replace function test() LANGUAGE plpgsql AS $$ BEGIN END $$;   若不指定回傳值，則會報錯誤function result type must be specified\n定界符$$ (delimiter) 在SQL中，兩個美元符號（$$）用來定義一個區塊或一個標識符（identifier）。\n例如，可以使用$$來.定義一個存儲過程或函數的主體。在$$之間的所有內容都被視為存儲過程或函數的主體，可以包含SQL語句、流程控制語句等。\n另外，$$還可以用來定義一個標識符，例如，可以使用$$來定義一個變量或一個標識符的名稱。在$$之間的所有內容都被視為標識符的名稱，可以包含字母、數字和下劃線等字符。使用$$定義標識符時，可以幫助區分保留字和自定義的標識符，以及避免標識符中包含空格等特殊字符所帶來的問題。\n1 2 3 4 5 6 7 8  CREATE FUNCTION myfunc(x INT, y INT) RETURNS INT AS $$ BEGIN RETURN x + y; END; $$ LANGUAGE plpgsql; -- 在這個例子中，$$ 用來定義函數的主體。CREATE FUNCTION 指令創建了一個名為 myfunc 的函數，它接受兩個整數參數 x 和 y，返回它們的和。 RETURN 指令用於返回函數的值。  -- 在這裡，$ 用作定界符，它定義了函數的主體。如果不使用定界符，則在函數主體中使用分號 ; 可能會導致錯誤。使用定界符可以幫助區分不同的 SQL 區塊，從而更好地組織和管理 SQL 代碼。   使用Terminal操作Postgres SQL 有兩種方式，一種是用psql的Shell，另一種則是用powershell\n使用psql的Shell 打開psql\n輸入相應的資訊\n使用powerShell 首先先下載Postgres SQL，接著在把環境變數加入至電腦中，路徑大概會如下\n1  C:\\ProgramFiles\\PostgreSQL\\14\\bin   即可在Termianl中操作postgres SQL\n如以下指令\n查看當前Psql有什麼Database 1  psql -l   連結進入Database 1 2 3 4 5 6  psql [dbname] psql -U [role] [dbname] # 以 postgres 的 role 登入 postgres 的 database psql -U postgres # 使用 postgres 的 role 登入 的 postgres 這個 database psql -U aaronchen minicare_demo # 以 aaronchen 的 role 登入 minicare_demo 這個 database psql -U postgres -d minicare_demo   1 2  psql -h localhost -p 5432 -U postgres school ## psql -h localhost -p 5432 -U \u0026lt;your_username\u0026gt; \u0026lt;your_database\u0026gt;   (與之對應的Server設定)\n連結成功後的畫面 可以輸入\n1  \\dt   來查看該database底下的table\n 在 psql 中，\\ 符號是一個特殊的字元，稱為 \u0026ldquo;psql 內部命令前綴\u0026rdquo;。當您在 psql 終端機中輸入以 \\ 開頭的命令時，psql 將解釋這個命令，並執行對應的操作。\n以下是幾個常用的 psql 內部命令：\n \\c: 切換到另一個數據庫 \\dt: 列出當前數據庫中的所有表格 \\d table_name: 查看指定表格的結構 \\q: 退出 psql 終端機 \\! clear: 清空psql 終端機畫面  當您想要使用 psql 內部命令時，必須在命令前加上 \\ 符號。例如，要列出當前數據庫中的所有表格，您可以輸入 \\dt。\n如果您想要輸入以 \\ 開頭的普通文本，而不是 psql 內部命令，則必須在 \\ 前面再加上一個 \\ 符號。例如，如果您想要在 SQL 陳述句中使用反斜線（\\）字元，則必須將其寫成 \\\\。\n請注意，在某些情況下，psql 內部命令前綴 \\ 可能會和 SQL 語句的關鍵字混淆。例如，CREATE TABLE 陳述句中的 TABLE 關鍵字後面如果不加引號可能會被 psql 認為是一個內部命令。為避免這種情況，建議在使用關鍵字時加上引號，例如 \u0026quot;TABLE\u0026quot;。\\\n 基本上這個terminal就是我們的Query Tool，所以是可以在這邊做CRUD的，如下\n常用的psql 指令  \\q - 退出 psql 命令行界面。 \\c \u0026lt;database_name\u0026gt; - 連接到指定的數據庫。 \\dt - 列出當前數據庫中的所有表格。 \\d \u0026lt;table_name\u0026gt; - 列出指定表格的詳細信息，包括列名、類型和約束等。 \\du - 列出所有用戶帳號的詳細信息，包括用戶名、權限和群組等。 \\dp - 列出所有表格的權限設置。 \\timing - 啟用或禁用查詢執行時間的顯示。 \\set - 列出或設置 psql 的配置選項。 \\i \u0026lt;file_path\u0026gt; - 從指定的檔案載入 SQL 命令。 \\e - 打開外部編輯器編輯當前緩衝區中的 SQL 命令。 \\! clear: 清空psql 終端機畫面 \\dt: 查看所有表格 \\df: 查看資料庫中的所有函數以及Stored Procedure \\ef: 編輯現有的函數，可能你寫錯了還是啥的 ☆修改完後，存檔退出記事本，進到terminal要加上 \\g 才會把這個修改go出去，不然你怎麼改都是沒有用ㄉ，血與淚的教訓Q_Q \\sf: 查看更詳細的函數內容，s stand for show  dt, du, df的d代表Describe的縮寫，用以顯示資料庫的資料\nStored Procedure的實戰 首先創造表格\n1 2 3 4 5  CREATE TABLE users ( id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL UNIQUE );   插入資料\n1 2 3 4 5  INSERT INTO users (name, email) VALUES (\u0026#39;John Doe\u0026#39;, \u0026#39;john.doe@example.com\u0026#39;), (\u0026#39;Jane Doe\u0026#39;, \u0026#39;jane.doe@example.com\u0026#39;), (\u0026#39;Bob Smith\u0026#39;, \u0026#39;bob.smith@example.com\u0026#39;);   返回值為空的Function 先創建一個無關緊要的stored procedure來感受一下它的作用吧，我們創造一個function，用來返回今天的日期，語法如下\n1 2 3 4 5 6 7 8 9 10  CREATE OR REPLACE FUNCTION -- 創建stored procedure的起手式。 get_current_date() -- 函式名稱 RETURNS DATE -- 該函式的返回值，若未指定則為Return Null AS -- 用以分明函數聲明與函數體，AS上面的是函數聲明，AS下面的是函數體 $$ -- 定界符，參照上方說明 BEGIN RETURN CURRENT_DATE; -- 函數體 END; $$ -- 定界符，參照上方說明 LANGUAGE plpgsql; -- 不加這個就是默認使用SQL語言，只能使用一些比較簡單的語法，加了這個之後就可以作流程控制、循環、異常處理等等...   接著呼叫它\n1  SELECT get_current_date();   回傳特定資料的function 該function會返回參數值的使用者的相關資訊\n1 2 3 4 5 6 7  CREATE OR REPLACE FUNCTION get_user_info(user_id INTEGER) RETURNS TABLE (name VARCHAR(255), email VARCHAR(255)) AS $$ BEGIN RETURN QUERY SELECT users.name, users.email FROM users WHERE id = user_id; END; $$ LANGUAGE plpgsql;   更新資料的function 1 2 3 4 5 6 7 8  CREATE OR REPLACE FUNCTION public.update_user_info(user_id integer, name character varying, email character varying) RETURNS void LANGUAGE plpgsql AS $$ BEGIN UPDATE users AS u SET name = $2, email = $3 WHERE u.id = $1; END; $$   變數宣告 :=來進行變數宣告，=在postgresSQL比較像是用來比較\n1 2 3 4 5 6 7 8 9 10 11 12  CREATE OR REPLACE FUNCTION my_function(param1 integer, param2 integer) RETURNS integer AS $$ DECLARE var1 integer := 0; var2 integer := 0; BEGIN var1 := param1 + 1; var2 := param2 + 2; RETURN var1 * var2; END; $$ LANGUAGE plpgsql;   WHILE 語法 1 2 3 4 5 6 7 8 9 10 11 12 13 14  CREATE OR REPLACE PROCEDURE public.factorial(IN n INT, OUT result BIGINT) LANGUAGE plpgsql AS $$ DECLARE i INT := 1; BEGIN result := 1; WHILE i \u0026lt;= n LOOP result := result * i; i := i + 1; END LOOP; END; $$;   IF語法 1 2 3 4 5 6 7 8 9 10 11 12  CREATE OR REPLACE PROCEDURE example_if_proc (a INT) AS BEGIN IF a \u0026lt; 0 THEN DBMS_OUTPUT.PUT_LINE(\u0026#39;a is negative\u0026#39;); ELSIF a = 0 THEN DBMS_OUTPUT.PUT_LINE(\u0026#39;a is zero\u0026#39;); ELSE DBMS_OUTPUT.PUT_LINE(\u0026#39;a is positive\u0026#39;); END IF; END;   將SELECT出來的值儲存在一變數中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  CREATE OR REPLACE PROCEDURE public.get_customer_info( IN customer_id INTEGER, OUT customer_name VARCHAR(50), OUT customer_email VARCHAR(50) ) LANGUAGE plpgsql AS $$ BEGIN SELECT name, email INTO customer_name, customer_email FROM customers WHERE id = customer_id; IF NOT FOUND THEN RAISE EXCEPTION \u0026#39;Customer not found\u0026#39;; END IF; END; $$;   將資訊打印出來(print) 1 2 3 4 5 6 7 8 9  CREATE OR REPLACE procedure sayHello() RETURNS void LANGUAGE plpgsql AS $$ DECLARE BEGIN RAISE NOTICE \u0026#39;hello word:\u0026#39;; END; $$   ","date":"2023-03-01T09:45:17+08:00","image":"https://i.imgur.com/1BTtOUL.png","permalink":"https://hoxtonhsu.com/p/storeprocedure%E8%B7%9Fpsql%E7%9A%84%E7%AD%86%E8%A8%98/","title":"StoreProcedure跟PSQL的筆記"},{"content":"參考影片：為你自己學GitLab CICD\n為何選擇Jenkins？ 目前市面上有三種CI/CD的工具，分別是\n Github Action GitLab CI/CD Jenkins  而他們各自的難易度如下：\nGithub Action Jenkins GitlabCICD 三者之比較     Github Action GitLab CI/CD Jenkins     優點 簡單易用，可以透過組合 Actions 來設定 CI/CD 流程。集成與 GitHub 相當良好，方便地與其他 GitHub 工具整合。 功能齊全，涵蓋了版本控制、需求管理、測試、打包、部署等。內建了測試覆蓋率分析、版本回溯、網路推送等工具。支援更多的發佈平臺和語言，可以支援更多不同的開發團隊。 功能強大，擁有豐富的插件系統，可以滿足多種 CI/CD 需求。社區活躍，有大量社區插件可以使用。可以自定義工作流程，靈活應對複雜需求。   缺點 設定複雜的流程可能會比較困難。有些功能，比如說高級的權限管理，可能比較弱。 較為複雜，可能會花費一些時間來學習和設定。有些功能，例如高級的安全性，可能會有額外的費用。 相對較難學習和使用，不如 GitHub Actions 和 GitLab CI/CD 簡單易用。配置和管理相對複雜，需要一定的技術支持。    為什麼CI/CD重要，它做了哪些事情？\n 在還沒有CI/CD的流程之前，部屬一個web大概是這樣   CI/CD建立完成後，開發人員只需要專注在任務的完成，而不需要做重複的部屬工作  名詞解析 Pipeline 就是腳本(script)的意思，用來設計CICD的流程，一個常見的pipeline如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  # 稱之為階段，可以為每個Job分配階段，常見的比如說有測試階段、打包階段、部屬階段等等，每個job都屬於一個階段 stages: - linter - testing - building - deploy # 工作流 workflow: rules: - if: $CI_COMMIT_BRANCH ==\u0026#34;main\u0026#34; #若發生什麼事 when: always #則做什麼事 - when: never #不然則做什麼 # 變數，就是那個變數，可以寫在外層的就是全域變數，寫在Job裡面的就是Job變數 variables: host_name: \u0026#34;hoxton\u0026#34; # 稱之為Job Helloworld: # Job名稱 image: ruby:3.1.2-alpine3.16 #指定要用什麼image來跑，等同於Executor variables: # Job變數 my_name: \u0026#34;hello kitty\u0026#34; stage: linter # 這個Job是什麼階段的 script: # 要執行什麼樣的腳本 - echo \u0026#34;hello world, GitLab! $my_name\u0026#34; - echo \u0026#34;hello world, GitLab! $host_name\u0026#34; - chmod +x ./run.sh - ./run.sh run_unit_tests: # Job名稱 stage: testing # 這個Job是什麼階段的 needs: # 決定Job的順序 - Helloworld # 在這些Job完成後才會去做run_unit_tests的Job script: # 要執行什麼樣的腳本 - echo \u0026#34;執行單元測試\u0026#34; before_script: #在執行腳本之前需要執行什麼腳本 - echo \u0026#34;安裝套件\u0026#34; - echo \u0026#34;設定資料庫連線\u0026#34; after_script :#在執行腳本之後需要執行什麼腳本 - echo \u0026#34;刪除不必要的檔案\u0026#34; bad_job: # Job名稱 stage: testing # 這個Job是什麼階段的 script: # 要執行什麼樣的腳本 - echo \u0026#34;bad_job\u0026#34; build_docker_images: # Job名稱 only: # 指定Job只會在什麼分支執行 - main stage: building # 這個Job是什麼階段的 script: # 要執行什麼樣的腳本 - echo \u0026#34;building docker images\u0026#34; deploy_to_production: # Job名稱 except: # 指定Job不在什麼分支執行 - dev # 分支名稱 stage: deploy # # 這個Job是什麼階段的 script: # 要執行什麼樣的腳本 - echo \u0026#34;deploy to production\u0026#34;   Runner 大概等同於「要用哪台電腦來執行Pipeline」，以下可以證明\n欲執行的script\n1 2 3 4 5  print-location: tags: - euno script: - echo \u0026#34;$HOSTNAME\u0026#34;   若不指定要有用哪台電腦執行，則gitlab會提供，但這時候就是在使用gitlab所提供的服務，免費帳戶每月超過40小時即到達上限，因此需要去註冊一個Runner\n 如何註冊一個Runner  可以參考GitLab的官方文件 https://docs.gitlab.com/runner/install/\n在Ubuntu系統下\n1 2  curl -L \u0026#34;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\u0026#34; | sudo bash   接著執行\n1  sudo apt-get install gitlab-runner   Executor 代表pipeline所運行的環境，可以是shell，也可以是Docker容器，端看目的而定，但千萬要記得，要執行指定的Executor，也要看自己的電腦或VM有沒有這個環境，之前有遇到一個問題是，我在本地起了一個runner，但一直說找不到pwsd的指令，此時要到gitlab-runner安裝的資料夾去調整toml檔案，將shell改成用powershell運行，因為window下沒有pwsd這個指定\n如何使用GitLab的CI/CD工具 在專案底下新增.gitlab-ci.yml的檔案，裡面的格式長這樣\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  # 稱之為狀態stages:- linter- testing- building- deploy # 稱之為JobHelloworld:stage:linterscript:- echo \u0026#34;hello world, GitLab!\u0026#34;run_unit_tests:stage:testingscript:- echo \u0026#34;執行單元測試\u0026#34;before_script:- echo \u0026#34;安裝套件\u0026#34;- echo \u0026#34;設定資料庫連線\u0026#34;after_script:- echo \u0026#34;刪除不必要的檔案\u0026#34;bad_job:stage:testingscript:- epaewjdqwebuild_docker_images:stage:buildingscript:- echo \u0026#34;building docker images\u0026#34;deploy_to_production:stage:deployscript:- echo \u0026#34;deploy to production\u0026#34;  把Image推上Gitlab 問題彙整 Got permission denied while trying to connect to the Docker daemon socket at unix:/// \u0026hellip; 解決方法：\n在vm中輸入\n1  usermod -aG docker gitlab-runner   \u0026ldquo;usermod -aG docker gitlab-runner\u0026rdquo; 這個指令是用來將 \u0026ldquo;gitlab-runner\u0026rdquo; 用戶加入 \u0026ldquo;docker\u0026rdquo; 群組。 \u0026ldquo;-a\u0026rdquo; 選項用於將用戶附加到指定的群組， \u0026ldquo;-G\u0026rdquo; 選項用於指定群組。\n這通常是為了允許 \u0026ldquo;gitlab-runner\u0026rdquo; 用戶在 GitLab Runner 管理的 CI/CD 流程中執行 Docker 容器。 通過將用戶加入 \u0026ldquo;docker\u0026rdquo; 群組，用戶可以在不需要權限升級的情況下運行 Docker 指令。\n請注意，\u0026ldquo;usermod\u0026rdquo; 指令的確切語法和行為可能因您使用的作業系統而異。 請查閱您的作業系統的文檔以獲取更多信息。\ndenied : requested access to the resource is denied. 八成是你的push沒有寫好，可以參考下面的樣子\nrunner會將target檔案刪掉，導致dokcer build不起來 GitLab CICD runner在執行每次作業時(Job)，為了保持互相的獨立性，會將Job所產生的檔案，切換至下個檔案時刪除，例如\n1  mvn clean package   時會產生/target的資料夾，在下一個Job時就會被刪除，如下\n此時可以在pipeline裡面加上這段\n1 2 3  artifacts: paths: - temp/*.jar   這樣就代表在下一次Job時，這個目錄底下的東西並不會被刪除\n","date":"2023-02-06T19:50:08+08:00","image":"https://i.imgur.com/b9bWXWs.jpg","permalink":"https://hoxtonhsu.com/p/gitlab-ci/cd%E7%AD%86%E8%A8%98/","title":"GitLab-CI/CD筆記"},{"content":"步驟 產生key的方式 1  ssh-keygen   儲存Key的位置 要改就改，不改就是預設的\n是否要針對privateKey設置密碼 使用這組Key時需不需要額外使用密碼，不輸入就是空白\n查看產生的key .pub後綴的就代表是pubKey\n進入主機內，將private Key加入 在.ssh底下會有一個authorized_keys的檔案 將privateKey放入其中就好\n輸入\n1  cat id_rsa.pub   來查看\n此時將這串複製下來，貼到GitHub的SSH Key設定\n接著只要上傳是使用SSH方式上傳，就不需要再登入github了\n","date":"2023-02-05T21:06:21+08:00","image":"https://i.imgur.com/8ocM55M.png ","permalink":"https://hoxtonhsu.com/p/%E4%BD%BF%E7%94%A8ssh%E4%BE%86%E9%80%A3%E5%8B%95gitscm/","title":"使用SSH來連動GITSCM"},{"content":"緣起 年假實在太無聊了，有點廢到連書都讀不下去，就打開Netflix想看看有什麼好看的，原本想看初戀First Love的，但無奈我對於愛情類型的東西實在沒什麼太大的興趣，正好看到了wednesday出現在推薦名單上，稍微看了一下預告，覺得Wednesday這種厭世到極限的人設深得我心，再搭配上女配角伊妮形成的反差，兩邊的對比實在太過強烈，讓我忍不住好奇到底這部在演什麼，於是就點進去了。\n先講結論，我覺得整部人設滿分，劇情真的不行，後面劇情感覺沒一個人是用腦袋在做事的，看完只覺得我的智商被狠狠的強暴了一遍。\n前面四集算是蠻多記憶點的，比如說舞會、拉大提琴、雕像爆破等等，對於星期三的角色塑造也算豐滿(就是個怪胎)。但無奈到後面幾集感覺整部劇情的調性就開始脫離了Addams Family的那種黑色幽默。\n首先是第五集，這一集家庭探訪日，校長要求Addams一家去做心理諮商，我本以為可以看到她們一家人「與眾不同」的那面，比如說互相挖苦、愛彼此愛到要殺死對方的那一種關心方式，但沒想到話鋒一轉，她們一家人居然整整齊齊的認真在做一場諮商，當問到Gormoz年輕時是否真的殺過人，Morticia還牙起來，要Wedensday不要再繼續追問下去了。\n當時心裡在想，這家人不是一群outcast嗎？怎麼突然間會這麼嚴肅地在講這件事情？整場諮商下來完全沒有任何Addams Family的感覺，跟一般家庭沒什麼不同的地方。直到後面謎題揭曉時，我還想說這麼嚴肅肯定是有什麼天大的事情所以才不能說，原來就只是爸爸幫媽媽背黑鍋而已，請問這件事情有必要瞞著Wednesday嗎？有必要故弄玄虛嗎？\n緊接著到第六集，莫名其妙的Xavier跟Tyler都對Wednesday暈船，而且暈船的不清，相繼說出什麼「舞會過後，我只想忘掉妳，卻都忘不掉」\n「雖然可能是我的錯覺，星期三，但你明明不停對我明示暗示」，我的天，我以為點進來是黑色幽默的懸疑片，沒想到點進來的原來是三角戀修羅場連續劇，再回頭看看前面的劇情，實在不覺得星期三跟這兩人的互動有什麼地方會讓人暈船的，可能這兩人都是易暈體質吧，只能說Wednesday有海王天份，深諳各種小心機吧，有一幕好像是Xavier看到Wednesday跟Tyler去舞會還是啥的，再生悶氣，沒想到Wedensday居然問Xavier到底在不開心什麼，我當時心裡在想「你這不是很懂嗎？海王Wednesday」，只能說男人終究是抵抗不了神祕正妹的邀請，唉。\n到了後面進入主線，Wednesday騙Enid跟Tyler想要出去，結果實際上是去Gates家調查，結果調查不順遭到Hyde的攻擊，結尾時看到Enid生氣的對Wedensday說「你根本不在乎你身邊的人，你只在乎你自己」時，我心裡想說終於啊，有人終於講出實話了，結果下一集Enid又活蹦亂跳的來找Wednesday聊天，不只是這幕，其實之前也有很多類似的劇情\nWednesday搞了些什麼讓大家很不爽，結果過沒幾集大家又主動來找Wednesday聊天，道歉。奇怪，到底為什麼要跟她道歉啊，難道人長得正就可以這樣子嗎。\n接著劇情在往下走，發現更加弱智，星期三指認Xavier就是兇手，結果實際上抓錯了，我個人認為沒問題，畢竟人總是有出錯的時候，而且確實很多證據都指向Xavier。但當Wednesaday說她抓錯，Tyler才是兇手時，她的快樂夥伴依然是無條件地相信Wednesday，甚至連證據都沒提供，她的快樂夥伴沒有絲毫的懷疑她講得到底是真是假，整個抓捕過程細絲極恐，我甚至覺得，假使Tyler不是兇手，Wednesday說Ajax是兇手，那群快樂夥伴也是會很樂意地把Ajax抓起來上供給Wednesday。也就是說其實星期三的行為根本是村霸的行為吧，說你有罪就有罪，抓犯人不靠腦袋而是靠拳頭，全程硬A，甚至最後抓犯人還是靠幻視才抓到的，0邏輯思考、解謎。\n到最後一集則是弱智情節大集合，知道主謀是Thornhill老師，校長用變形術變成Tyler的樣子去跟Wednesday包圍她，結果校長在Thornhill面前解除變形後，我本以為會有什麼刺激的對決畫面，結果Thornhill只是提起「手中」的針筒，就往校長的「脖子」刺下去，校長就死了，那到底為什麼要變形接近老師啊，不能躲在旁邊聽就好嗎？退一萬步來說，校長你真的不是在演嗎？你身高190，老師身高155，能不能反應一下啊，結果就這樣死了，完全沒有任何推進劇情的作用，校長在不在那個場景對於劇情影響都不大，真的就只是為了過來死而已。\n後來Crackstone復活，我本以為會有什麼超炫的技能，結果完全沒有，戰力值低落到我甚至認為Nevermore學生每個人都衝上去，他就會活活當場被打死在現場，就只有進Nevermore後放個火焰風暴後，接著就拿起法仗當一個進戰法師，跟Wednesday近身平A起來，不知道是不是腦袋還沒熱起來，忘記自己是一個法師，應該拉開距離，或是趁隙放個什麼魔法之類的，最後還被Bianca從後面背刺，當他轉過去打飛Bianca後，接著又被Wednesday背刺，看到這幕的時候我還以為在看周星馳的零零漆大戰金鎗客，這種古靈金怪槍的幽默沒想到也被洋人發揚光大去了。最後Thornhill老師拿了一把槍走出來時，我心裡在想「終於啊！大人，時代變了，該拿槍了」，結果拿槍抖了老半天，講了一堆話就是沒開下去，結果後面被蜜蜂叮的時候才開槍，真的不是當年腦子進水嗎？Crackerstone復活後不就叫你閉嘴，警告你話太多了嗎？結果最後還是沒把他的話聽進去，難怪不成大氣。\n最後快樂大結局，該發糖的發糖、該狼化的狼化，Xavier繼續暈船Wednesday，結尾還送了台Iphone給Wednesday，看到這幕時，我忽然想起知道為什麼Xavier一開始會懷疑自己被Bianca蠱惑，從劇情表現上看起來他確實是暈到神智不清，我也懷疑他最後真的被星期三蠱惑了，印證了那句「星期三虐我千百遍，我仍待她如初戀」，鋼鐵星期三粉實至名歸。\n結尾 認真回想了一下，整部劇情最大該吐槽的點就是Wednesday身邊的人對她近乎盲目的包容，校長包容她、警長包容她、狼妹包容她、男配也包容她，Wednesday至始至終除了小手外，幾乎沒對任何人道過歉，也沒深刻的反省，但就是所有的人都會莫名其妙的原諒她，毫無邏輯與深度可言。第二季出的話我應該還是會看，畢竟人設實在太香了，希望第二季不要在虎頭蛇尾了。\n","date":"2023-01-29T17:20:08+08:00","image":"https://i.imgur.com/C9FgAaF.jpg","permalink":"https://hoxtonhsu.com/p/wednesday-%E6%98%9F%E6%9C%9F%E4%B8%89%E8%88%87%E5%A5%B9%E7%9A%84%E6%9A%88%E8%88%B9%E5%A4%A5%E4%BC%B4%E5%80%91/","title":"Wednesday 星期三與她的暈船夥伴們"},{"content":"前言 記得在某次外勤的時候，那時候好像是要做稅抽還是要查什麼東西，需要用客戶的電腦SAP裡面查一些資料，可是我按了老半天，一直出現錯誤，迷迷糊糊地從那些文字中拼湊出一些單詞，只記得有什麼SQL Error，當時把這件事情跟客戶的會計反應，他旋即請了工程師過來處理，弄了一下之後跟我說需要明天才會好，要我明天再去撈\n(範例，非當事錯誤)\n後來這幾年工作上常常接觸到資料庫的東西，最近又想起這件事來，也總算知道當時遇到的錯誤是什麼了我猜是IP連不到。因此繼續趁著年假這個真的不知道做什麼事的時間點來科普一下ERP系統後面的東西，SQL DataBase是什麼？\n什麼是SQL 首先要知道SQL怎麼發音，我都念SQL，但也有些人念SQL，SQL的念法是，C闊(Ess-cue-ell')。SQL這個詞的由來有人說沒意義，就是叫SQL，也有人認為是有意義的，也就是Structured Query Language(結構化查詢語言)的縮寫。簡而言之SQL就是用來跟資料庫(Database)溝通的一種Syntax(語法)，SQL與資料庫的關係像魔法師與魔法書的關係，魔法師透過詠唱咒語(SQL語法)來使用魔法書(Database)的能力。\n第一次接觸到SQL是在大四大三的時候吧，那時候好像有個系必修是什麼資訊概論類似的課程，老師上課的時候有提到一個東西，他的介面是隻海豚，然後有很多奇怪的按鈕，\n當時的我完全不知道這些是啥，甚至連SQL是什麼都沒有半點頭緒，那門課我記得我只負責處理一些很瑣碎的事情，其他都靠我同學Carry過的XD。結果沒想到逃的了一時，逃不了一世，現在天天都會看到，感嘆命運多舛啊。\n話說回來，所以什麼是SQL呢？他是用來做什麼的？我們首先先來講一下什麼是關聯式資料庫。大家應該有上過學吧，學校裡，有班級、有學生、有班導，有科任老師，這些東西都是互相有關聯的，比如說一個班導可以有很多學生，但每個學生只能有一個班導，一個科任老師也可以有很多學生，每個學生也可以有很多的科任老師。用來記錄這些資訊的資料庫就是所謂的關聯式資料庫注：有關聯式就會有非關聯式資料庫，但這部分我就不熟了。\n(注：我事後回來看，我覺得這樣設計有很多問題，其實可以在精簡一點的，大佬就別鞭太大力了）\n畫成關聯圖大概就是長這樣，原諒我畫的真的有點醜，不過大概看的出來它們彼此有哪些關係吧？學生跟班級、導師、科任老師有關聯、班級跟學生還有班導有關聯、班導跟科任老師沒有關聯(其實這邊設計的不太好，會違反資料正規化，但只是示範而已）。SQL Database我們每天都會碰到，比如說你每天上車逼的悠遊卡，你的卡號就被記在政府的悠遊卡SQL Database裡面，只要你遺失後，就會把你的那筆資料拉出來，標注已遺失。或是會計師考試報名時，會給你一組准考證號碼，所以考試院的SQL資料庫裏面，也會有這筆准考證的資料，這筆資料包含你的身分證、考試成績等等，只要涉及資料儲存的部分，其實背後都有資料庫的存在，也包含你的手機裡面的通訊錄等等，裡面都有小型的資料庫在裡面處理你的information。\nSQL的實作 多說無益，我們就用線上版的SQL編輯器來看看SQL是怎麼運作的吧，建議這邊點開我上面的HackMd，我有用Gif的方式錄影下來。\n線上的SQL編輯器：https://sqliteonline.com/\n點進去後會看到裡面長這個樣子，時間寶貴，我把左邊的欄位講一下就好，其實左邊就是各是各樣的SQL Database，不同的Database都有一些特性\n SQLite：輕量化的SQL資料庫，常用於手機端。 MariaDB：MySQL的作者獨立出來開發的SQL資料庫 PostgreSQL：也是SQL資料庫 MSSQL：微軟開發的SQL資料庫，會有微軟的奧援  當然不只這些，像常聽到的Oracle，不只有做ERP系統，其實還有做SQL資料庫，當然Oracle做的不止這些。話說回來，這些語法都大同小異，但為了方便各位，我們這次就用SQLite做示範，因為這個頁面一點進來就是SQLite了。\n這個紅色框框的地方就是讓我們打SQL語法的部分，我們先來創一些資料吧！秉持著能交給別人做的事情絕對不自己來的原則，這部分我們請ChatGPT來幫我們就好：）\nChatGPT產生的語法如上，這邊先講解一下會出現的名詞代表的意思，首先\n Table：近似於Excel裡面的活頁表，每個活頁表都拿來描述不同的東西，比如說學生這張Table就是拿來存放跟學生有關的資料，比如說姓名、學號之類的東西。 DROP：近似於刪除  1 2 3 4 5 6 7 8  CREATE TABLE Student ( Name TEXT,　ClassTeacherName TEXT, StudentID INTEGER, ClassroomID INTEGER, Birthdate DATE, Subjects TEXT );   這樣的語法代表創建一張名為Student的表格，裡面要有\n 名為Name的欄位，資料型別是文字 名為ClassTeacherName的欄位，資料型別是文字 名為StudentID的欄位，資料型別是數字 名為ClassroomID的欄位，資料型別是數字 名為Birthdate的欄位，資料型別是DATE(日期，亦即只能存放日期格式的東西) 名為Subjects的欄位，資料型別是文字  資料型別代表這個欄位只能存什麼東西，如果資料型別是數字，就代表只能存在羅馬數字，如果輸入 天氣 就會出錯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  -- 如果已經存在這些表就刪除，確保每次都是產生全新的Table DROP TABLE IF EXISTS demo; DROP TABLE IF EXISTS Student; DROP TABLE IF EXISTS Teacher; DROP TABLE IF EXISTS Classroom; DROP TABLE IF EXISTS SubjectTeacher; -- Create Student table CREATE TABLE Student ( Name TEXT, ClassTeacherName TEXT, StudentID INTEGER, ClassroomID INTEGER, Birthdate DATE, Subjects TEXT ); -- Create Teacher table CREATE TABLE Teacher ( Name TEXT, TeacherID INTEGER, ClassroomID INTEGER ); -- Create Classroom table CREATE TABLE Classroom ( ClassroomID INTEGER, ClassID INTEGER ); -- Create SubjectTeacher table CREATE TABLE SubjectTeacher ( Name TEXT, TeacherID INTEGER, Subject TEXT );   完成後我們可以看到我們的左邊就出現很多的東西，就代表我們成功創建了Table喔！\n但此時Table裡面的東西都是空的，我們試著塞一些資料進去Table裡面吧，這邊再次邀請我們的勞模ChatGPT\n這邊的INSERT其實就是新增資料進去的意思。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  -- Insert data into the Teacher table INSERT INTO Teacher (Name, TeacherID, ClassroomID) VALUES (\u0026#39;John Smith\u0026#39;, 1, 101); INSERT INTO Teacher (Name, TeacherID, ClassroomID) VALUES (\u0026#39;Jane Doe\u0026#39;, 2, 102); INSERT INTO Teacher (Name, TeacherID, ClassroomID) VALUES (\u0026#39;Bob Johnson\u0026#39;, 3, 103); -- Insert data into the Classroom table INSERT INTO Classroom (ClassroomID, ClassID) VALUES (101, 1); INSERT INTO Classroom (ClassroomID, ClassID) VALUES (102, 2); INSERT INTO Classroom (ClassroomID, ClassID) VALUES (103, 3); -- Insert data into the SubjectTeacher table INSERT INTO SubjectTeacher (Name, TeacherID, Subject) VALUES (\u0026#39;John Smith\u0026#39;, 1, \u0026#39;Math\u0026#39;); INSERT INTO SubjectTeacher (Name, TeacherID, Subject) VALUES (\u0026#39;Jane Doe\u0026#39;, 2, \u0026#39;Science\u0026#39;); INSERT INTO SubjectTeacher (Name, TeacherID, Subject) VALUES (\u0026#39;Bob Johnson\u0026#39;, 3, \u0026#39;English\u0026#39;); INSERT INTO SubjectTeacher (Name, TeacherID, Subject) VALUES (\u0026#39;Bob Johnson\u0026#39;, 3, \u0026#39;History\u0026#39;); -- Insert data into the Student table INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Alice Smith\u0026#39;, \u0026#39;John Smith\u0026#39;, 1, 101, \u0026#39;2000-01-01\u0026#39;, \u0026#39;Math, Science\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Bob Brown\u0026#39;, \u0026#39;John Smith\u0026#39;, 2, 101, \u0026#39;2001-01-01\u0026#39;, \u0026#39;Math, English\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Charlie Johnson\u0026#39;, \u0026#39;Jane Doe\u0026#39;, 3, 102, \u0026#39;2002-01-01\u0026#39;, \u0026#39;Science, History\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;David Wilson\u0026#39;, \u0026#39;Jane Doe\u0026#39;, 4, 102, \u0026#39;2003-01-01\u0026#39;, \u0026#39;Science, English\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Eve Davis\u0026#39;, \u0026#39;Bob Johnson\u0026#39;, 5, 103, \u0026#39;2004-01-01\u0026#39;, \u0026#39;English, History\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Frank Miller\u0026#39;, \u0026#39;John Smith\u0026#39;, 6, 101, \u0026#39;2005-01-01\u0026#39;, \u0026#39;Math\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Gary Moore\u0026#39;, \u0026#39;Jane Doe\u0026#39;, 7, 102, \u0026#39;2006-01-01\u0026#39;, \u0026#39;Science\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Helen Anderson\u0026#39;, \u0026#39;Bob Johnson\u0026#39;, 8, 103, \u0026#39;2007-01-01\u0026#39;, \u0026#39;English, History\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;Irene Thomas\u0026#39;, \u0026#39;John Smith\u0026#39;, 9, 101, \u0026#39;2008-01-01\u0026#39;, \u0026#39;Math, Science\u0026#39;); INSERT INTO Student (Name, ClassTeacherName, StudentID, ClassroomID, Birthdate, Subjects) VALUES (\u0026#39;James Hernandez\u0026#39;, \u0026#39;Jane Doe\u0026#39;, 10, 102, \u0026#39;2009-01-01\u0026#39;, \u0026#39;Science, English\u0026#39;);   完成後，在Table上面點選右鍵，選擇SELECT即可這張表的所有屬性喔 ！\n 教室Table   學生Table 這邊也違反資料庫正規化，一個應該只塞一筆資料的原則，我的subject塞了複數筆資料，但單純Demo而已，有點懶得改了    科任老師Table  老師Table\n  SQL語法的介紹 我們一樣在框框裡面操作\n1  SELECT * FROM Teacher   這個語法的意思就是 SELECT選擇 *全部欄位 FROM來自 Teacher這張表，翻成白話文的意思就是，幫我選出Teacher這張表的全部內容，當然我們也可以再複雜一點，比如說\n1  SELECT * FROM Teacher WHERE teacherid = 2   也就是從Teacher這張表裡面選出TeacherId為2的欄位\n1  SELECT * FROM Student WHERE subjects LIKE \u0026#39;%Math%\u0026#39;   當然我們再複雜一點點，這個語法會找出所有在Student這張Table裡面subjects欄位裡有Math的學生，聽起來有點繞口對吧XD，接著我們就把這些語法組合起來，試著找看看\n1 2 3 4  SELECT Student.* FROM Student JOIN SubjectTeacher ON Student.ClassTeacherName = SubjectTeacher.Name WHERE Birthdate BETWEEN \u0026#39;2001-01-01\u0026#39; AND \u0026#39;2005-12-31\u0026#39; AND SubjectTeacher.Subject = \u0026#39;Math\u0026#39;   我們再複雜一點點點點，我們想找出所有在2001年至2005年出生，並且有修Math的學生，看到這邊這個語法大家是不是有點感覺了，是不是很像我們去撈資料常常用到的，要撈發生在本年度的100018應付帳款全部資料XD。其實背後的SQL語法就像這樣子。\n當然實際上的情況SQL語法還會更複雜一點，因為這些這是關聯式資料庫，彼此間可能可以關聯到很遠很遠的Table，只是為了做科普而已就不弄得那麼複雜了。另外SQL Syntax(語法)也不只SELECT，常見的還有UPDATA, DELETE, CREATE等等，只是這些審計人員一般不會碰到。\n結語 其實沒啥想講的，只是覺得很閒而已，想說趁年假時後把想寫的東西寫一寫，順便也當科普一樣，感覺會計這個圈子好像很少人在寫科普或是知識介紹的東西，就花個一兩個小時的時間寫一下，如果對SQL有興趣的話，可以去載來玩看看\n MySQL：全英介面，一開始可能不太友好，但網路上資源最多 MSSQL：微軟的SQL，有中文介面，但網路上資源相對較少，其實SQL的語法都大同小異，但其實還是有一些不同處 PostgreSQL：通常不會用這個入門，我個人覺得它GUI的介面很爛，我用這個的話通常都是用Terminal SQLite：不太推薦，因為這算是輕量化版的，有很多資料型別是特規的。  我文章常提到的資料庫正規化介紹如下\nhttps://ithelp.ithome.com.tw/articles/10229472\n忙季加油！債見\n","date":"2023-01-26T17:50:33+08:00","image":"https://i.imgur.com/6aiiDXi.png","permalink":"https://hoxtonhsu.com/p/oraclesap%E9%BC%8E%E6%96%B0%E6%B7%BA%E8%AB%87%E9%80%99%E4%BA%9Berp%E8%83%8C%E5%BE%8C%E7%9A%84%E6%98%AF%E4%BB%80%E9%BA%BC-sql%E8%B3%87%E6%96%99%E5%BA%AB/","title":"Oracle?SAP?鼎新?淺談這些ERP背後的是什麼-SQL資料庫"},{"content":"想講一些實用的，但卻很少人知道的一些電腦使用的功能，知道這些對做底稿、翻憑證不會有太大的幫助，但會用的話我個人覺得可以節省很多時間，供大家參考。\n快速關機 window+D：回到桌面\n在桌面Alt+F4即可跳出關機選項\n記得當初在外勤的時候，只要組長說撤的時候我就會用最快的速度關機XD，那時候同事都問我怎麼用的，這就是訣竅，當然也可以選擇重新啟動或休眠，看自己喜好決定。\n截圖 window+shift+s\n這個應該最基本，在Window10以上的系統可以透過這個shortcut來打開截圖視窗，就拿來貼圖片給組長，跟組長說我哪邊不會QQ\n快速打開Excel, Word, 記事本, 小畫家,計算機\u0026hellip; Window+R：跳出執行選項\n在裡面輸入以下的內容已打開不同的Application\nmspaint：打開小畫家\nnotepad：記事本\nwinword：word\nexcel：excel\n計算機：calc\n快速打開工作列的應用程式 window+1\n可以打開工作列的第一個應用\nwindow+2\n可以打開工作列的第二個應用，以此類推\u0026hellip;\n這個指令我大部分都是用來開Chrome，或是Excel之類的東西\n瀏覽器快速選擇搜尋列 打開Chrorm後，打alt+D就可以定位到搜尋列，並且在這邊按Ctrl+1,2,3\u0026hellip;即可切換至不同的頁面，通常是我拿來打混摸魚的時候用的，Ctrl+T則可以打開新的分頁，所以兩個和再一起就是，開啟一個新分頁並搜尋，如果旁邊有人過來就立刻Ctrl+w關閉當前頁面，避免摸魚被抓包。\n","date":"2023-01-26T00:31:43+08:00","image":"https://i.imgur.com/Ln2xqzT.png","permalink":"https://hoxtonhsu.com/p/%E6%B7%BA%E8%AB%87%E4%B8%80%E4%BA%9B%E5%AF%A6%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%8D%B5/","title":"淺談一些實用的快捷鍵"},{"content":"前言 年假回老家實在是太無聊了，想把這幾年學到的東西分享一下，希望可以幫助一些莘莘學子，能用更有效率的方式來整理筆記。\n記得大二或是大三的時候很沉迷於作筆記這件事情，最喜歡做的事情，就是用一兩個下午把那個禮拜所上的成會或是中會整理成筆記，以利後面的複習。不得不說當時這樣做的回饋還不錯，當時中會跟成會的成績都還算不錯。\n（當時很認真的筆記）\n紙本筆記的缺點 這樣的筆記在當時應付期中考期末考還行，因為這些筆記可能都是一兩個月寫的，都還算有印象，但是當我準備研究所的時候就發現幾個問題了，首先\n 難以搜尋：面對海量的資料，我很難在第一時間找到我需要的資訊，比如說我想要找一個利息資本化的定義，以及它的細項，我除非前一陣子剛寫，或是我版面真的寫得很好，不然我不能第一時間的找到我想要的資訊。比如說稅法的部分就分成很多塊，比如說遺產稅贈與稅等等的，數量真的太多，且稅率也類似，常常找不到自己想要的地方。 難以擴充：紙質的筆記一旦寫下去之後就難以修改，無法滿足我越來越多的知識積累，比如說大家都知道的金融資產那一個章節，可能光一個範例就可以寫個2,30個也不為過，每個範例可能都有一些細節要抄進筆記裡面，這樣日積月累下去，那一頁的筆記越記越多、越寫越亂不易閱讀。 耗時：耗時是最大的問題，一頁的筆記我可能需要寫個半小時，雖然說寫的當下其實就記得很清楚了，但是卻非常的消耗時間，往往做完這些筆記我的假日就這樣沒了，實在是不太行，且手寫筆記非常吃手寫的品質，如果心一旦亂起來，亂寫一通，那這筆記基本上閱讀不能，只是寫給當時的自己看的，不利日後準備研究所或是會計師考試。  雖然1、2的問題都可以透過Ipad的手寫筆記來解決一些問題，但最大的問題就是第3點，當時有嘗試過很多方式，比如說用excel來記筆記(但儲存格不方便修改與擴充)，或是用word來寫，但word真的非常不適合拿來寫筆記，首先，work本身是不支援你打出類似分錄格式的東西的，就算可以，那個代價我記得也很大，其次，光是格式的部分可能就要設定個老半天，再加上在寫筆記的途中還需要移動滑鼠去調整現在想要的是\n      或是\n       這樣的格式真的有點打斷思緒。\n因此我的需求是這樣\n 方便撰寫，希望不需要去切什麼格式 支援圖片上傳，可以讓我傳圖片上去，可能有些範例或是老師在黑板上畫的東西，需要做成筆記來看 要可以讓我打類似分錄的東西  後來出社會工作後，接觸到Markdown這個東西真的驚為天人，並且是有一點相見恨晚，如果在學期間知道這個東西的話做筆記應該會更高效快速一點。首先先來介紹一下Markdown是什麼吧\nMarkdown介紹 Markdown 是目前非常普遍用來撰寫文檔的語言，一開始的目標就是使用「易讀易寫的純文字格式編寫文件」，此初衷讓使用者可以專注在文字的本身，而不需要透過其它工具來切換格式。以 Word 撰寫文檔來說，就必須透過上方的工具列來切換標題、列表、粗體、斜體等等；而 Markdown 並沒有這樣的工具列，完全都是使用標示符號來完成這些需求。\nMarkdown是一種輕量級標記式語言，創始人為約翰·格魯伯。它允許人們使用易讀易寫的純文字格式編寫文件\n由於Markdown的輕量化、易讀易寫特性，並且對於圖片，圖表、數學式都有支援，目前許多網站都廣泛使用Markdown來撰寫說明文件或是用於論壇上發表訊息。如GitHub、Reddit、Discord、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、簡書等，甚至還能被用來撰寫電子書。\n參考自維基百科以及https://www.casper.tw/development/2019/11/23/ten-mins-learn-markdown/\n先來看看如果我把會計的筆記轉成Markdown的話看起來會是怎麼樣吧，因為Dcard不支援markdown，可以點這邊預覽看看\nhttps://hackmd.io/@Celeast/ryyXXyosi\n第七章 彈性預算、直接成本與管理會計 本章學習重點\n 了解各差異的差異 基於差異分析所做的決策判斷  名詞定義\n 靜態預算(Static Budget)：在預算期間開始時，基於預計產出水準所做的預算所做的預算 靜態預算差異：在靜態預算中，實際結果與預期數之間的差異 彈性預算(Flexible Budget)：預算期間內按實際產出水準計算出預算收入與預算成本之預算  ．\n．\n．\n1 2 3 4  flowchart LR B[實際投入數量x實際價格] \u0026lt;--價格差異--\u0026gt; 實際投入數量x預算價格 \u0026lt;--效率差異--\u0026gt; C[實際產出下所允許之預算投入x預算價格] B \u0026lt;--彈性預算差異--\u0026gt;C       變動 歸納 評論     固定制造成本可以做為存貨成本嗎? 不可 可以 基本問題   有生產數量差異嗎? 沒有 有 對基準產能水準的選擇，只在歸納成本法下影響營業利益的衡量     分錄   原料\t10,000\n​\t應付帳款\t10,000\n  在製品\t30,000\n製造費用 1,000\n​\t原料\t31,000\n  產成品\t50,000\n​\t在製品\t50,000\n 課堂範例：\nＭarkdown語法介紹 上面是我把我的會計筆記轉成Markdown格式，可以看到Markdown支援了幾點\n 列表式的清單 用來舉例的黑點 重點的醒目提示 分層式的標題，標出章節重點 支援表格(注：markdown的表格語法非常反智，通常我都是用快捷鍵生成) 支援流程圖的繪製 支援數學式(這邊沒有示範到，不過Markdown是有支援高等數學的運算式的) 支援圖片上傳，可以讓我把版書或是題目直接貼上去  接下來帶大家認識一下Markdown的一些語法\n首先是標題的語法，輸入#再加上一個空格會產生標題，就像現在這樣\n在文字前加上1. 2. 3. 則會變成列表\n文字之間加上**則可重點醒目\n在文字前加上+則會變成黑點\n在文字前加上\u0026gt;則可做為補充說明，我就是用這個語法來寫分錄的\n顯示圖片的語法則是這樣\n裡面的內容填上自己的圖片連結就可以了，如何把圖片上傳上去我後面會說。\nMarkdown的語法還有很多很多，不只有我上面提到的這些，有興趣的同學可以參考這邊\nhttps://www.casper.tw/development/2019/11/23/ten-mins-learn-markdown/\n我該怎麼寫Markdown呢？ markdown是工程師蠻常會接觸到一個標籤式語言，如果你開心的話用記事本也是可以寫Markdown的喔，但是效果會不太好閱讀而已，目前markdown我自己認為比較常見的有幾種\n  Vscode\n這是我最初拿來寫markdown的工具，但它本身不是專門拿來寫markdown的，不支援一些熱鍵以及圖片上傳，後面就被我拋棄了\n  HackMd\nHackMd是一個網頁版的markdown編輯器，簡單來講就是你寫上去後，東西就是直接存在雲端，且圖片複製貼上就會自動幫你上傳到網路上了，非常的便捷以及快速，好像是台灣人開發的，最重要的是它免費，也是最常見的方式。\n  Typora\n這是我目前主力所使用的Markdown編輯器，跟HackMd最大的不同就是它是一個所見及所得的編輯器，上述兩款其實都是把畫面分成兩邊，左邊是Markdown語法，右邊則是渲染後的結果，而typora則是在你輸入完後直接幫你渲染好，也就是所寫及所見，是它最大的特色。\n但相比之下它就有幾個缺點\n 要錢，最直觀的問題就是它是一個付費的程式，屬於買斷制一次500，支援三台設備同時使用 本身不支援圖片上傳，想要用它來做圖片上傳需要懂一些控制台指令以及Json格式的 本身的檔案都在local端，需要自己手動丟上雲端(我個人是丟到github上面，然後用bat檔自動上傳)    還可以提供一點，我會把一些真的沒辦法用文字或是Markdown語法表示的東西寫在平板的GoodNote上面，在把連結分享出來，然後截圖下來貼上去，看起來就像這樣\n結語 當然還有不只這些，我沒記錯的話Notion本身也有支援(但我不熟)以及obsidian也是一個寫Markdown的工具，我之所以會選Typora只是因為我喜歡有更大的空間，不喜歡畫面被分成左右兩邊而已。\n作筆記的方法有很多，不做的、用紙寫的、用平板寫的，都可以，沒有誰優誰劣，Markdown也有它的限制在，比如說它就不能寫資產負債表、也不能寫T字帳，沒有一個方法是最佳解的，只要找到自己喜歡的方式都可以，這篇文章只是拋磚引玉，希望提供自己的一些想法供大家參考，也歡迎各位一起討論，祝大家新年快樂，忙季加油！\n","date":"2023-01-22T23:15:25+08:00","image":"https://i.imgur.com/c968Ywa.png","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E8%A3%BD%E4%BD%9C%E6%9C%83%E8%A8%88%E7%9A%84%E9%9B%BB%E5%AD%90%E7%AD%86%E8%A8%98markdown%E7%9A%84%E4%BB%8B%E7%B4%B9/","title":"如何製作會計的電子筆記？Markdown的介紹"},{"content":"最近在新電腦上安裝了Docker結果發現一直卡在這個畫面\n後來研究了一下發現應該是wsl沒有裝好的原因，後來安裝好之後，在把Window Update要我Update的東西全部更新一次，就可以執行成功了，推測應該是window版本沒更新，導致不支援wsl的關係。\n","date":"2023-01-21T00:52:36+08:00","image":"https://i.imgur.com/xgUpP8O.png)","permalink":"https://hoxtonhsu.com/p/docker_desktop_starting%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA/","title":"Docker_Desktop_Starting問題解決"},{"content":"名詞解釋 Container Docker Container 是一種軟體容器，它可以在其中運行應用程式和其他服務。它使用操作系統級別的虛擬化，可以在單一的物理主機上運行多個容器，並且每個容器都有自己的運行環境和資源。\nDocker Container 是一種軟體容器，它可以在其中運行應用程式和其他服務。容器具有輕量級、可移植性和隔離性等特點。容器是通過在操作系統內核中運行的容器引擎來實現的。\nDocker容器主要是使用了Linux 的 Namespaces 和 Control groups（cgroups） 技術來實現隔離，這兩種技術可以將一個實體主機上的資源限制給每個容器，而容器內部則是共用一個kernel，因此容器比虛擬機器輕量且速度較快。\nDocker容器是基於鏡像(Image)來建立與運行的，一個鏡像可以是一個基礎鏡像或是由其他鏡像所建立而來。當執行docker run 指令時，會從鏡像建立一個容器，並在容器內執行指定的應用程式或服務。\n不僅如此，Docker容器還支援網路、儲存卷的映射，使得容器可以與外部通訊，也可以存取本地端的資料。\n透過Docker容器,我們可以將應用程式、服務和其所需的環境打包在一起，並且可以在不同的環境中運行，提高了應用程式的可移植性和彈性。\nImage Docker Image 是 Docker 容器的基礎，它是一個只讀的模板，包含了容器運行所需的所有檔案、設定和程式。當執行 docker run 指令時，Docker 會從 Image 建立一個新的容器並在其中執行指定的應用程式或服務。\nDocker Image 可以通過構建或下載的方式創建，構建的方式可以使用 Dockerfile 來描述如何構建一個 Image。而下載的方式則可以從 Docker Hub 或其他的 registry 下載。\nVolume Docker Volume 是 Docker 的一種功能，用於管理容器中的數據。容器本身是輕量級的，數據是不能永久存在的，而 Volume 則是可以永久存在的。\nDocker Volume 可以被掛載到容器上，並且可以在容器內部存儲數據。當容器停止運行或者被刪除時，Volume 中的數據仍然可以保留下來。這樣就可以在重啟容器或建立新容器時，繼續使用之前存儲的數據。\n並且Volume裡面的資料是可以和Host分享的，兩邊的資料呈現鏡像的雙向對應，在Host新增的東西會在Container出現，Container新增的資料也會在Host裡面出現\n常用指令 搜尋Image 1  docker search postgres   查看目前的image 1  docker image ls   或是\n1  docker images   執行docker image 1  docker run [imageName][:tag]   後面的:latest是版本號，可加可不加，沒加的話預設就是latest\n刪除images 1  docker rmi [imageId]   在Detached mode下執行 1  docker run -d nginx   所謂的Detached mode亦即啟動後會不會占用你的terminal，可以看一下下面的git，可以比較兩者間的差異\n 沒有-d   有-d  打包成docker image 1  docker build -t drink-more-water:latest .   -t 是 tag的縮寫，hello-docker是這個tag的名稱，.代表dockerfile在當前的目錄下，如果Dockerfile不在當前目錄，則這邊要改變。latest則是版本號，可加可不加，不加的話預設是latest\n查看目前運行的Container 1  docker ps   ps是process status的意思\n或是\n1  docker container ls   ​\t查看目前運作中(running)的Container 1  docker ps   或是\n1  docker ps -a   查看底下全部的Container不論啟動與否\n進入Container與之互動 1  docker exec -it [ConatinerId]] bash   bash有可能沒有，有可能是sh，要自己到/bin裡面看\n停止Container 1  docker stop [ContainerId]   ​\n啟動停止的Container\n1  docker start [ContainerId]   刪除Container 1  docker rm [ContainerId]or[NAMEs]   也可以輸入很多個Id，一次刪個爽\n還有更猛的\n1  docekr rm -f $(docker ps -aq)   直接用參數的方式全刪。\n暴露port 1  docker run -p 5432:5432 posgres   前面的5432是你自定義的localhost:5432，而後面的5432則是容器裡面的port號\n暴露已經Running,Stopping 的Container的Port 沒有這個方法，只有\n1  docker run postgres   的這個時候你才可以把port暴露出來\n一次性查看Container的Log紀錄 1  docker logs [ContainerId]   這條指令只會顯示過去的紀錄，後續的logs不會更新\n持續查看Container的Log紀錄 1  docker logs -f [ContainerId]   這條不只會顯示過去的，還會動態更新現在的log\n執行Docker-compose 1  docker compose up -d   -d 代表是否背景執行，不佔用terminal\n停止並刪除Docker-compose的Container 1  docker compose down   將Dokcer Images Push至Dockerhub 首先先登入dockerhub\n1  docker login   再將想要推上去的docker Image重新命名\n1  docker tag [Image Name] DockerHub帳號/Image Name   接著push上去 dockerhub\n1  docker push DockerHub帳號/Image Name   想要使用image的話就執行pull\n1  docker pull DockerHub帳號/Image Name   在Docker啟動Ubuntu   下載 ubuntu 的image\n1  docker pull ubuntu   或是可以\n1  docker run ubuntu   就會自動從docker hub載下來了，但這樣只是把ubuntu的image拉到我們的docker裡面，它本身是沒有啟動的\n  在docker中運行ubuntu\n1  docker run -it ubuntu     使用apt(advanced package tool)安裝nano(Linux text editor)\n用apt載任何東西前都建議先update\n1  apt update   1  apt install nano     Exposing Port 輸入docker ps可以看到以下資訊\n其中的PORTS 80/tcp的意思，容器對外公開的網路端口是 80/tcp，表示這個容器對外公開的網路端口是80，並且是基於TCP協議的。這意味著當外部網路瀏覽器連接到http://localhost或http://時，將會連接到容器內部的 Nginx Web 伺服器。想要讓容器的端口對外開放，就需要exposing它，否則直接打localhost:80是沒有用的。\n我們可以使用以下的方式將8080 連接到80/TCP\n1  docker run -d -p 8080:80 nginx   其中的8080:80的意思是指將主機的 8080 端口映射到容器的 80 端口。也就是說，當外部網路瀏覽器連接到 http://localhost:8080 時，將會連接到容器內部的 Nginx Web 伺服器。\n你也可以不只Exposing一個Port，可以Exposing多個port給80\n1  docker run -d -p 8080:80 -p 3000:80 nginx   Container的管理 當我們啟動、並Stop一個Container，實際上如果依照我們剛剛的作法，我們是不斷的創造新的Container，輸入docker ps -a 即可看到目前存在的Container(不論running or Stopping)，或是在Desktop docker裡面也都可以看到\n我們可以透過\n1  docker rm [ContainerId]   來真正意義上的移除Container，而不是停止它\n可以使用docker ps -aq ，這個指令只會秀出ContainerId，可以刪更爽，直接複製貼上就好\n還有更爽的方式，用$(docker ps -aq)的方式 傳遞參數\n為Container命名 建議命名一下，比較好找，只支援英文，不支援中文\n1  docker run --name hoxtonPractice -d -p 8080:80 nginx   Volume的使用 讓資訊可以在host與Container共享的一個功能\n範例：\n首先在桌面上創建一個名為website的資料夾，裡面有個index.html，內容如下\n1  \u0026lt;h1\u0026gt;hello docker and volume\u0026lt;/h1\u0026gt;   接著將terminal切至/website底下，然後輸入\n1  docker run --name website -v ${PWD}:/usr/share/nginx/html:ro -d -p 8080:80 nginx     -v是 Docker 中的 volume 指令，它用於將主機上的目錄或檔案掛載到容器中。配合後面的${PWD}:/usr/share/nginx/html，意思就是將當前目錄的內容掛載(Mount)到容器中的 /usr/share/nginx/html 目錄下。這樣設定後，當主機上的目錄內容變更時，容器中的 /usr/share/nginx/html 目錄內的內容也會隨之更新。\n  :ro 是指將主機上的目錄或檔案掛載到容器中的目錄或檔案，並設定為只讀模式。\n  ​\t這意味著在容器中將無法寫入或修改掛載的目錄或檔案，只能讀取。這可以避免對主機上的檔案造成損壞或不\t必要的變更。\n /usr/share/nginx/html 是 Nginx 預設的網站根目錄。  結果如下：\n也因為Volume是鏡像對應，因此修改host的檔案，container的內容物也會同步更新\n我們可以用以下的指令來訪問看看Nginx的檔案\n1  docker exec -it website bash    docker exec 是 Docker 的命令行工具，用於在運行中的容器內執行命令。 -it 這兩個選項表示要互動式地執行命令，並且讓輸入和輸出保持連接。 website 是容器的名稱或 ID。 bash 是要在容器內執行的命令，這裡是啟動 Bash shell。也可以改成ls，就變成ls了，玩法很多，自行摸索  在Nginx裡面新增檔案，移除檔案，會發現host的資料夾檔案也同步更新\n不同的Container使用相同的Volume 1  docker run --name website-copy --volumes-from website -d -p 8081:80 nginx    \u0026ndash;volumes-from [ContainerName]：將這次要啟動的Container使用和website一樣的Volume  Dockerfile Dockerfile是一個文本文件，它包含了創建Docker image所需的指令。這些指令可以包括例如：\n 從哪個基礎鏡像建立新鏡像 安裝需要的軟體 設置環境變量 添加應用程序文件 定義容器啟動時執行的命令  透過Dockerfile, 可以自動化的建立一個環境，方便在不同的環境上部署，使用者可以更方便的管理環境，以及減少部署錯誤的機會。\n例如，如果你有一個Java應用程序需要在多個不同的服務器上運行，你可以使用Dockerfile創建一個包含Java執行時環境的镜像，然後在每個服務器上執行這個镜像，這樣就能保證每個服務器上都有相同的環境。\n試著把剛剛寫的volume打包成一個image，首先在/website的資料夾裡面新增一個名稱一定要是dockerfile的檔案\n裡面的檔案結構長的像這樣子\n1 2  FROMnginx:latestADD . /usr/share/nginx/html   FROM：指定了基礎Image是nginx，後面的latest是指版本號。Dockerfile中必須要有FROM指令，它是一切的根本，它指定了基礎Image環境。舉例來說，這邊指定用最新版的nginx，那麼我們的鏡像會基於這個最新版的nginx環境運行 ADD：將本地目錄中的文件複製到鏡像中的指定目錄。在這個例子中是將本地目錄中的所有文件複製到鏡像中的/usr/share/nginx/html目錄。它的功能跟COPY有點像，但是COPY用法比較單純，只能複製本地文件和目錄到鏡像中，而ADD指令還可以解壓縮tar文件並將其中的文件複製到鏡像中。  ​\t值得注意的是\n1  ADD . /usr/share/nginx/html  這行指的是，將當前目錄的所有東西(以一個.表示)加入至Container中的/usr/share/nginx/html目錄中。在這個例子中就是將\n這些東西ADD進/usr/share/nginx/html裡面。\n當Dockerfile寫好後，要開始bulid它，步驟如下\n1  docker build -t website:latest .   這個命令是在使用 Docker 建立一個新的鏡像檔，並標記為 \u0026ldquo;website:latest\u0026rdquo;。 \u0026ldquo;.\u0026rdquo; 表示當前目錄下的 Dockerfile 檔案將會被用來建立映像檔。這個命令將會建立一個名為 \u0026ldquo;website\u0026rdquo; 並且標記為 \u0026ldquo;latest\u0026rdquo; 的鏡像檔。  Build完後就會出現一個image了，輸入\n1  docker images   就可以查看目前擁有的images\n並且可以這個image可以運行我們剛剛對index的設定，輸入\n1  docker run --name website -p 8080:80 -d website:latest   注意：這邊不需要再為website設置volume，因為我們已經將需要的東西打包進image裡面了。\n輸入完後，在URL的地方輸入localhost:8080就可以看到我們剛剛設置的東西了。\ngif如下\n​\n實際演練 NodeJs 前置作業 安裝Node.js，這邊安裝為了快速，就直接用Choco來裝了，Choco的安裝如下\n  在Terminal中輸入，記得要以系統管理員身分輸入\n1  Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;))     安裝完後安裝nodeJs\n1  choco install nodejs     安裝完後隨便創一個資料夾，這邊命名叫做user-service-api\n  切換到該資料夾底下，並且npm init它\n1  npm init     接著安裝express\n1  npm install --save express     用好後檔案結構長這樣\n  在該目錄底下新增一個index.js的檔案，內容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const express = require(\u0026#39;express\u0026#39;) const app = express() const port = 3000 app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.json([{ name: \u0026#39;Bod\u0026#39;, email: \u0026#39;bob@gmail.com\u0026#39; }]) }) app.listen(port, () =\u0026gt; { console.log(`Example app listening on port ${port}`) })     使用nodejs運行\n1  node index.js     成功後進入localhost:3000即可看到下列畫面\n  如此一來前置作業就完成了\n製作DockerFile 在目錄底下新增dockerfile，內容如下\n1 2 3 4 5  FROMnode:latestWORKDIR/appADD . .RUN npm installCMD node index.js   WORKDIR：若Container有/app這個資料夾，則使用它，若沒有，則創造它。   ADD . .： 将当前目录中的文件复制到镜像中的 /app 目录。 RUN npm install： 在鏡像中运行 npm install 命令，安装应用程序所需的依赖项。 CMD node index.js：设置镜像启动时运行的命令，这里是运行 node index.js。  為什麼要分成RUN跟CMD呢？有幾個原因，首先RUN跟CMD的用途本身就不一樣，RUN主要是在創建image中執行命令，並將結果保存在image中，它主要用來安裝依賴、配置應用程式或其他操作。則是用來說明Image創建完成後要執行的動作。簡而言之，RUN是在創建Image中過程所執行的，而CMD則是在Image創建完成後所執行的。\n並且，一個DockerFile可以有很多RUN指令，但只能有一個CMD指令，因為Container只能運行一個CMD指令\n使用Image 接著創建鏡像\n1  docker build --tag user-service-api:latest .   創建完之後啟動鏡像\n1  docker run --name user-api -d -p 8080:3000 user-service-api:latest   這邊的8080:3000是指，將我們容器裡面原本配置的3000端口暴露出來，以8080來接收。\n因為3000是指在Container裡面的端口，host想要讀到它，必須將Container的端口暴露出來。因此localhost:3000會找不到東西，只有打localhost:8080才會有我們要的內容\nDockerIgnore 做完上面這些操作後，我們的檔案結構長這樣\n然後我們的Dockerfile長這樣\n1 2 3 4 5  FROMnode:latestWORKDIR/appADD . .RUN npm installCMD node index.js  比較之後發現一件事情，RUN npm install會創建node_modules資料夾，但我們在ADD時已經把node_modules加入進去，等於說我們重複創建了兩次node_modules，這種情況就類似gitIgnore，需要排除掉重複的資料夾\ndockerIgnore的寫法\n1 2 3  node_modulesdockerfile.git  這樣就可以把這些檔案排除在外了\nCaching \u0026amp; Layers DockerFile裡面的每一個CML都是一個Layer，每個Layer都用來Caching`\n1 2 3 4 5  FROMnode:latestWORKDIR/appADD . .RUN npm installCMD node index.js  可以看到這邊的Step1, Step2都對應著CML的指令\u0026hellip;\n而Cache的點就在於，其實除了ADD . . 以外(原始碼每次打包時都會有更動)，其實WORKDIR, RUN npm install這些指令其實都是重複的，我們每次打包都需要再重複執行一次，這樣很沒**效率 **\n於是Dokcer就會把這些重複的事情Caching起來，只要沒有改變就不會重複再做，就會看到上面的Using Cache了\nALPINE 翻譯的意思是高山\n我剛剛打包的Image檔案已經快逼近一個G了，很明顯我們其實不需要那麼多的東西，Alpine版本的就是一個非常小的鏡像。\n實際安裝ALPINE 1  docker pull node:lts-alpine   兩者的Size差了快十倍\nDocker Compose 將後端與資料庫一起包一包 一個Project不可能只由一個後端組成，肯定是要由後端、前端、以及資料庫三者組合，甚至更甚者可能會有10,20個的部件需要去組合，那麼一個一個run container這件事情就變得相當缺乏效率。為了處理這件事情，於是有了Docker-Compose的概念出現。\nDocker-Compose大概就像這樣，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  version:\u0026#39;3.7\u0026#39;services:db:container_name:postgres-for-dockerpracticeimage:postgresenvironment:POSTGRES_PASSWORD:rootPOSTGRES_USER:rootPOSTGRES_DB:rootvolumes:- ./pgdata:/var/lib/postgresql/dataports:- \u0026#39;5432:5432\u0026#39;backend:container_name:backend-for-dockerpracticeimage:shopdepends_on:- dbports:- \u0026#39;8080:8080\u0026#39;  和dockerfile一樣存在於專案根目錄中\n他類似於一個配置檔，用以告訴Docker要啟動哪些Container，以及它們之間的交互關係，以上面的Docker-compose.yml來說明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  version:\u0026#39;3.7\u0026#39;//要使用的dokcer-compose版本，有分很多版，比如說1.0,2.0，但目前主流是3.0，所以照著寫就好services://每一個起起來的Container有一個特殊的名字，叫做service，這個yaml檔就有兩個service，分別叫db跟backenddb://可自定義的service名稱，高興叫啥就叫啥，但這個名字會與你在application.properties裡描述的名稱有對應關係，可以看看下面的附圖，第四行的url:jdbc:postgresql://db:5432/shop，其中的db就是service的名稱container_name:postgres-for-dockerpractice //自定義的名稱，想叫啥就叫啥，這名稱會是你的Container名稱image:postgres //要使用哪個image作為基底environment:POSTGRES_PASSWORD:45002502POSTGRES_USER:postgresPOSTGRES_DB:shopvolumes:- ./pgdata:/var/lib/postgresql/dataports:- \u0026#39;5432:5432\u0026#39;//要暴露出來的端口backend://可自定義的service名稱，高興叫啥就叫啥，但這個名字會與你在application.properties裡描述的名稱有對應關係。container_name:backend-for-dockerpractice //自定義的名稱，想叫啥就叫啥，這名稱會是你的Container名稱image:shop //要使用哪個image作為基底，這個是我自己docker build -t shop:latest . 所創建出來的imagedepends_on:- db //這意味著，你這邊的service會等到db這個service完成後才會進行部屬。ports:- \u0026#39;8080:8080\u0026#39;// 暴露出來的端口  ▲第四行的db與services的名稱有對應。\n▲上述的docker-compose啟動後顯示的樣子。\n常用的指令\n啟動當前目錄的docker-compose\n1  docker compose up   關閉當前目錄的docker-compose\n1  docker compose down   ","date":"2023-01-18T21:47:50+08:00","image":"https://i.imgur.com/JdDwgHn.png ","permalink":"https://hoxtonhsu.com/p/docker%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/","title":"Docker學習筆記"},{"content":"前陣子在網路上找看看有沒有什麼實用的Git指令，無意間看到這個功能。\n只要在Github的頁面按下 \u0026gt; ，就可以開啟網頁版的Vscode囉，不過有個小缺點就是，Vscode開啟時介面語言是依據你瀏覽器的語言所決定，所以如果想要使用英文版的Vscode就要把Chrome的語言設定成英文喔。\n這樣開啟後最直觀的好處就是可以直接在Github上以Vscode編輯程式碼，做快速的修改，瀏覽起來也比較快，不然原本網頁在看的話速度非常的慢！並且也可以在上面做衝突的處理。\n","date":"2023-01-11T23:27:27+08:00","image":"https://i.imgur.com/Gckim1N.png","permalink":"https://hoxtonhsu.com/p/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%97%8E%E7%8F%BE%E5%9C%A8github%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8vscode%E5%96%94/","title":"你知道嗎?現在Github上也可以使用Vscode喔！"},{"content":"前言 整理一下工作上有用過，並覺得實用、比較少人提過的一些Git指令。\nGit指令  退回到上一個Commit，數字可以更改，1就是上一次，改成三的話就是三次前的Commit  1  git checkout HEAD~1   退回上一次的Commit，重複輸入的話會往復循環  1  git checkout -   將本次修改合併至上次Commit，如果有漏掉的提交會常用這個指令  1  git commit --amend --no-edit   ","date":"2023-01-06T14:15:51+08:00","image":"https://i.imgur.com/nCGDuUc.png ","permalink":"https://hoxtonhsu.com/p/%E5%AF%A6%E7%94%A8%E7%9A%84git%E6%8C%87%E4%BB%A4/","title":"實用的Git指令"},{"content":"開頭 Java中的例外分為受檢例外與非受檢例外(RuntimeExcetption)兩大類，可以先看到這張圖。\n所謂的非受檢例外就是指繼承了RuntimeException的Exception，這類的Exception發生，而非受檢例外就是指沒有繼承RuntimeException的Exception。可以看下列的圖片\n何謂受檢例外與非受檢例外 受檢例外之所以叫受檢例外，就在於這些例外是工程師必須明確檢查並處理的例外，例如讀取檔案時發生的FileNotFoundException，這類的Exception，JVM沒有辦法進行處理，因此需要工程師去做處理。而RumtimeException則是指那些工程師不需要去明確處理的Exception，比如說NullPointerException, ArrayIndexOutOfBoundsException，這類的例外都是繼承自RuntimeException，可以由JVM進行處理，當然要處理也是可以的，比如說這樣\n(可以看到左邊第13行的方法，沒有被try..catch包住也沒事，因為該方法拋出的例外是NumberFormatException，這個例外繼承了RuntimeException，因此不用try\u0026hellip;catch處理也沒關係，JVM會自動幫我們處理，如果要放到try\u0026hellip;catch的話，則是在catch段裡去catch NumberFormatException)\n將方法放入try\u0026hellip;catch之後，因為catch是抓RuntimeException，所以被抓到後會print出catch error。\n另外比較實務上的說法即是，受檢例外(checked Exception)是可被修復的例外，可以試看看retry，而不可修復的例外就是非受檢例外(RunTimeException)，這種時候就代表程式出了問題，有bug，需要工程師下來進行處理，把問題處理掉\n來源：2021 IT 鐵人 Day 09 單元測試與例外處理\n那如果一個method會拋出受檢例外，而在該method中又沒有做處理，則會需要呼叫它的那一個method進行處理。\n右邊的方法實際上不會拋出IOException，所以會顯示為灰色的，這邊只是作為Demo先寫上去。可以看到畫面左邊的地方，此時IDE跟我們報錯，說這個方法會拋出一個IOException，要我們進行處理，因為IOException是一個受檢例外，JVM本身沒有能力可以進行處理。\n大概先這樣，其他想到後補。\n","date":"2022-12-27T15:12:58+08:00","image":"https://i.imgur.com/dwbYvaF.png","permalink":"https://hoxtonhsu.com/p/java%E4%B8%AD%E7%9A%84throwthrowstry...catch%E5%8F%97%E6%AA%A2%E4%BE%8B%E5%A4%96%E8%88%87%E9%9D%9E%E5%8F%97%E6%AA%A2%E4%BE%8B%E5%A4%96/","title":"Java中的throw,throws,try...catch，受檢例外與非受檢例外"},{"content":"序言 參考資料：\nAgile Hsinchu 2022.11 - 〈你就是不寫測試，才會沒時間〉線上導讀\n測試有時間再寫？你就是不寫才會沒時間！\n你就是都不寫測試才會沒時間：Kuma 的 30 天 Unit Test 手把手教學，從理論到實戰 （Java 篇）\nTDD(Test-Driven Development)是一個軟體開發的模式，它的概念很簡單，就是先寫測試在寫程式，\n這樣的事情會讓我們覺得不可思議，因為我們一直以來寫程式的方式都是先寫程式，而測試則是有時間才再補的東西。那改成先寫測試會有什麼好處呢？這部分我們等等再來談，我們先討論TDD最核心的部分—單元測試(Unit Test)。\n單元測試在TDD的作用是什麼 ​\t一開始在認識單元測試的時候，許多人的想法都會認為說，單元測試可以避免Bug，可以提升程式碼的品質。確實這些都是Unit Test的好處，但卻不是最核心的關鍵，單元測試最重要的點在於幫助我們重構現有的程式架構。\n​\t我們在經手一個項目的時候，第二個月的理解一定會比第一個月的理解更深，第三個月的理解也一定會比第二個月的理解更加深刻，可能三個月前所使用的架構，在三個月後，隨著業務規模的擴展、需求的增加，而需要去新增新的程式，或是改變原有的設計，因而漸漸不敷使用，在這樣的情形下，若沒有單元測試的保護支持我們重構，讓我們確保每一步的Design都沒有破壞原有程式的設計，工程師會變得去害怕修改舊有的程式碼，因而導致不敷使用的架構繼續生長下去。\n(▲ 程式能跑，但還能在更好）\n​\t如果只是這樣子還沒什麼問題，畢竟就只是把東西一個接著一個地疊上去，頂多就是不好維護而已。但實際上的開發中，是很常出現改Ａ壞Ｂ這種情況的，在沒有單元測試的保護下，工程師在開發中是不會知道自己更新的這段程式碼會對某些程式造成影響，往往要等到合併後才能出現問題，所以會出現一種情況就是前期開發的都很順利，而越到後面Dead Line，效率就越發下降，因為工程師在開發的當下不知道自己新增的功能到底會不會對別人造成影響。而有了測試的保護，我們可以在寫程式的時候就知道現在程式的運行狀況，今天這樣子的修改會不會導致其他程式跑不起來，如果跑不起來那單元測試就不會過，這樣的回饋是立即性的回應，而不需要等到合併後大家才知道。\n(▲ 隨著開發時間的增加，TDD的優勢會更凸顯出來）\nAgile與TDD  講到Agile就會講到瀑布式開發(WaterFall)，但你知道嗎？其實從來都沒有瀑布式開發這種事情喔。\n 瀑布式開發是來自於Winston Royce在1970所提出的論文Managing the Development of Larger Software Systems被提出，但事實上這個開發模式在這篇論文的下一行就被Winston Royce否決了。\n I believe in this concept, but the implementation described above is risky and inivites failure. The problem is illustrated in Figure 4 .\n我相信這個概念，但照著這上面的流程做的話是高風險且易導致錯誤的，原因就如第四張圖所示\n ​\t(▲Figure 4)\n The testing phase which occurs at the end of the development cycle is the first event for which timing, stotage, input/output transfers, etc, are experienced as distinguished from analyzed. These phenomena are not precisely analyzable. There phenomena are not precisely analyzable. They are not the solutions or the satndard partial differential quations of mathematical physics for instatnce. Yet if there phenomena fail to satisfy the various external constraints, then invariablt a major redesign is required . A simple octal patch or redo of some isolated code will not fix there kinds of difficulties. The required design changes are likely to be so disruptive that the software requiremnets upon which the design is based and which provides the rationale for everything are violated. Either the requirements must be modified, or a substantial change in the design is required. In effect the development process has returned to the origin and one can expect up to a 100-percent overrun in schedule and/or costs\n在開發流程的最後一個階段-測試，第一個遇到的事情就是時序、儲存，輸出輸入，這些現象情況無法準確的分析，這些不像數學物理的解答，或是標準偏微方程，然而，如果存在不能滿足各種外部約束的現象，則不可避免地需要進行重大的重新設計，一個簡單的八進制補丁或一些孤立代碼的重做不會解決這些困難，所需的設計更改可能會造成破壞，以至於違反了設計所基於的以及為所有事情提供基本原理的軟件要求。 要么必須修改要求，要么需要對設計進行實質性更改。 實際上，開發過程已經回到原點，預計進度和/或成本會超支 100%。\n Winston Royce在瀑布模型提出的當下其實就否認了它的意義，但後續被一些人拿來當作開發的窠臼，也導致了這種開發模式往往會在完工時出現重大的危害。Winston Royce認為，在最後的測試階段是充滿著未知與不確定性，到最後會反覆著在測試、程式修改、確認需求這三個階段來回擺盪，這樣三個階段的來回擺盪是不是有點似曾相似呢？沒錯，就是TDD的概念\n什麼是TDD TDD是一個開發模式而不是測試模式，TDD的測試模式是由\n 寫一個會錯的測試 寫一個剛好會過的程式 重構  ​\t這三者循環，對應Winston Royce對瀑布模型提出的弊端，也就是測試、修改程式、確認需求，也因此TDD是一個可以讓問題早期浮上水面的開發方式，為什麼？因為這樣的開發方式要求我們對業務邏輯的需求有充分的了解，這樣我們才可以寫測試，一旦需求明確了，那麼寫出程式就只是時間的問題了。\n​\t另一方面，也是因為TDD的開發模式，我們每一個Code都有單元測試的保護，我們可以隨時重構我們的程式碼而毋須擔心程式被我們改錯，是的，沒錯，TDD的一個核心概念就在於任何時候都可以重構我們的程式碼，因為人對於系統的了解，會隨著開發時間的增加而了解的越深刻，半年前的Code到了現在可能越看越不順眼，另一方面，隨著業務規模的提升，我們早期的設計可能也會越不敷使用，若沒有單元測試的保護，我們重構的成本會隨著產品的規模的提升而提升，而發展到一定規模的情況下，重構變成遙不可及的夢想。\n​\t也是因為有單元測試的保護，我們才可以真正的去設計我們的程式，常見的S.O.L.I.D，以及23種設計模式的使用，如何根據不同的情境套用不同的設計模式，這就是工程師有價值的地方，可以說單元測試的撰寫完整了整個物件導向的程式設計。\n","date":"2022-12-04T22:22:06+08:00","image":"https://i.imgur.com/2xteh3C.png","permalink":"https://hoxtonhsu.com/p/%E6%B7%BA%E8%AB%87%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC/","title":"淺談測試驅動開發"},{"content":"在Junit5中，有對一些Junit的測試的註解進行調整\n比如說\n    Junit4 Junit5     測試用框架的選擇 @RunWith(MockitoJUnitRunner.class) @ExtendWith(MockitoExtension.class)    當測試會使用到SprintBoot框架時，應該要使用@ExtendWith(SpringExtension.class)，@MockBean來調用\n若測試不想涉及SprintBoot的時候@ExtendWith(MockitoExtension.class)，以及@Mock, @InjectMocks，並且使用MockMvcBuilders.standaloneSetup來設置獨立測試，以下是Code的示範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.InjectMocks; import org.assertj.core.api.Assertions; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.setup.MockMvcBuilders; /** * @author Hoxton on 2022/11/30 */ @ExtendWith(MockitoExtension.class) public class UserControllerTest { @Mock //Controller調用的Service  UserService userService; @InjectMocks //要測試的Cotroller  UserController userController; MockMvc mockMvc; //模擬Mvc  @BeforeEach public void setMockMvc(){ MockMvcBuilders.standaloneSetup(userController).build(); } @Test void testMethod_situation_returnWhat(){ given(someObject.someMethod()).willReturn(\u0026#34;someting\u0026#34;); // ... 設置  MockHttpServletResponse response = mvc.perform(get(\u0026#34;someUrl\u0026#34;)).andReturn().getResponse(); assertThat(\u0026#34;something\u0026#34;).isEqualTo(\u0026#34;thatThing\u0026#34;); } }   ","date":"2022-11-30T13:30:27+08:00","image":"https://i.imgur.com/4qePz5L.png ","permalink":"https://hoxtonhsu.com/p/%E5%A6%82%E4%BD%95%E5%B0%87junit%E7%9A%84%E6%B8%AC%E8%A9%A6%E7%B2%92%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%9C%A8%E6%9C%80%E5%B0%8F%E5%96%AE%E5%85%83/","title":"如何將Junit的測試粒度控制在最小單元"},{"content":"最近業配公司，讓公司老闆買了IDEA讓我們後端工程師來使用，因此技術分享做了一次IDEA的主題，在這邊把技術分享的一些內容做成文章，分享一下\n推薦的Plugin    Plugin名稱 截圖     One Dark Theme\n佈景主題    \n按鍵提示    Rainbow Brackets\n括弧顏色顯示    Nyan Progress Bar讀取條改變    WakaTime\n工作的紀錄     要改的設定    Code Completion\nAlt+.\n      Second Basic Alt+/\n    Type-Match-Completion\nAlt+;\n    Run F10\n 就Run   Terminal Alt+`\n| |    更改Terminal Bash CMD or Window terminal    更改TODO 模板\n     實用的快捷鍵    功能 預覽     sout,souv\n快速印出    搜尋 Shift+shift 快速列出所有可能，快速定位   切換分頁\nCtrl+E 預設快捷鍵，會列出最近開啟的分頁   選擇檔案\nAlt+F1然後按1\n若不想選擇按Esc退回Editor    快速選取區塊\nCtrl+W    快速選取方法\nAlt+↑    查看根源\nCtrl+B    快速定位錯誤\nF2    查看變數提示\nCtrl+P    修改\nShift+F6    內建GitBlame功能\n對行數右鍵選擇gitBlame    萬能鍵Context Action\n引入變數、錯誤修正\u0026hellip;     ","date":"2022-11-10T23:52:33+08:00","image":"https://i.imgur.com/zyn4XVp.png","permalink":"https://hoxtonhsu.com/p/idea%E7%9A%84%E4%BB%8B%E7%B4%B9/","title":"IDEA的介紹"},{"content":"推薦的Plugin    Plugin名稱 截圖     One Dark Theme\n佈景主題    \n按鍵提示    Rainbow Brackets\n括弧顏色顯示    Nyan Progress Bar讀取條改變     要改的設定          Code Completion Alt+.\n    Second Basic Alt+/\n    Run F10\n 就Run   Terminal Alt+`\n| |    更改Terminal Bash CMD or Window terminal    更改TODO 模板\n     實用的快捷鍵    功能 預覽     搜尋 Shift+shift 快速列出所有可能，快速定位   切換分頁\nCtrl+E 預設快捷鍵，會列出最近開啟的分頁   選擇檔案\nAlt+F1然後按1\n若不想選擇按Esc退回Editor    快速選取區塊\nCtrl+W    快速選取方法\nAlt+↑    內建GitBlame功能\n對行數右鍵選擇gitBlame     ","date":"2022-10-23T20:40:49+08:00","image":"https://i.imgur.com/Fx9nanx.png","permalink":"https://hoxtonhsu.com/p/intellij%E4%BB%8B%E7%B4%B9/","title":"IntelliJ介紹"},{"content":"最近在研究C++，但發現我的CLion不知道為什麼只能有一個Main方法，後來網路上查了一下之後發現好像是因為CMake的關係。\n 錯誤訊息\n 後來研究了一下，發現只要在Project底下的CMakeList.txt加上這段就可以了\n1 2 3 4 5 6  file (GLOB files *.cpp) foreach (file ${files}) string(REGEX REPLACE \u0026#34;.+/(.+)\\\\..*\u0026#34; \u0026#34;\\\\1\u0026#34; exe ${file}) add_executable (${exe} ${file}) message (\\ \\ \\ \\ --\\ src/${exe}.cpp\\ will\\ be\\ compiled\\ to\\ bin/${exe}) endforeach ()    完整的圖片如上\n 加入之後記得要Reload CMake Project\n","date":"2022-10-17T18:09:43+08:00","image":"https://i.imgur.com/aGwtINt.png","permalink":"https://hoxtonhsu.com/p/clion%E7%9A%84mutilmain/","title":"CLion的MutilMain"},{"content":"最近領到薪水後買了TYPORA後，想找如何上傳圖片的教學，發現網路上的教學蠻少的，台灣好像只有一篇，還是For mac的教學，剩下的都是中國的教學，但他們用的圖床，台灣也很多不能用，後來研究了幾天終於搞懂，所以決定寫一篇看看\n圖片空間有Github跟imgur，就看你想要用哪個就用哪個吧，其實沒差太多，但imgur會稍微簡單一點點點點點點，以下是步驟\n開始  先去安裝node.js，因為會需要裡面的npm  https://nodejs.org/en/download/\n安裝好可以用系統管理員身分打開cmd，並輸入\n1  node    如果有成功安裝的話應該會顯示  接著安裝picGo-core\n1  npm install picgo -g   說出現錯誤，要我們執行\n1  npm audit fix -force   執行完之後就安裝好了，接著輸入\n1  picgo   來確認是否有安裝成功，有時候可能會出現\n1  檔案未經數位簽署這個指令碼將不會在系統上執行   之類之類的句子，這時候可以輸入\n1  Set-ExecutionPolicy RemoteSigned   來允許執行，這時候在輸入picgo應該就可以看到這樣子的畫面了\n到這一步本地端的設定已經完成80%了，接下來就是要選擇要使用哪種圖片空間\nGithub  首先先到Github創建一個公開的Repository，名字隨意就好   接著把這個Repository的URL複製下來  1  https://github.com/Hoxton019030/Typora    右上角個人頭像點開，選擇Settings   左側選項最下面有一個Developer settings   選擇Personal access tokens   選擇 Generate new token   輸入這個token的名稱，隨便取就好，Expiration看個人喜好，我很懶，所以我選擇永久，下面的select scopes勾選repo   接著會產生一組ghp開頭的token，這組序號只會在這裡以明碼出現一次，接下來永遠都不會再以明碼的方式呈現所以請好好記起來 然後到Typora的偏好設定裡打開開啟設定檔，通常會是用一個文本編輯器打開，通常都是vscode啦   接著把這串東西複製貼上去  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;github\u0026#34;: { \u0026#34;repo\u0026#34;: \u0026#34;Hoxton019030/Typora\u0026#34;, //這串對應的是使用者名稱+Repo名稱，改成自己的 \u0026#34;token\u0026#34;: \u0026#34;ghp_xxxxxxxxxxxxxxxxxxxx\u0026#34;, //這邊把剛剛產生的token貼上去 \u0026#34;path\u0026#34;: \u0026#34;data/\u0026#34;, //圖片要上傳到哪個資料夾，可以先不用設定， \u0026#34;customUrl\u0026#34;: \u0026#34;https://raw.githubusercontent.com/Hoxton019030/Typora/main\u0026#34;, //把Hoxton019030/Typora改成你自己的repo \u0026#34;branch\u0026#34;: \u0026#34;main\u0026#34; //應該也不用動 } }, \u0026#34;picgoPlugins\u0026#34;: {} }    完成之後應該長這個樣子，接著按存檔   接著回到設定，試著按看看測試圖片上傳  如果成功的話就會出現這樣的畫面\n就代表你成功了！\n 如果你在按一次測試圖片上傳，由於上傳的圖片檔名一模一樣，會報錯，這樣是正常現象，請不要驚慌\n imgur  首先先辦帳號 https://api.imgur.com/oauth2/addclient 點擊這個網址 老樣子，名字隨意取就好，然後Authorization type選擇第二個   接著會跳出畫面，會告訴你你的Client ID是什麼，請複製下來   接著到偏好設定裡面打開開啟設定檔，通常會用vscode開啟   接著把這段複製貼上上去  1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;picBed\u0026#34;: { \u0026#34;current\u0026#34;: \u0026#34;imgur\u0026#34;, \u0026#34;uploader\u0026#34;: \u0026#34;imgur\u0026#34;, \u0026#34;imgur\u0026#34;:{ \u0026#34;clientId\u0026#34;: \u0026#34;XXXXXXXXXXX\u0026#34; } }, \u0026#34;picgoPlugins\u0026#34;: {} }   貼上去之後應該會長這個樣子\n 然後存檔之後，回到偏好設定，按「測試圖片上傳」  跳出這個就代表成功上傳了！\n小結 這樣子只要在typora裡面貼上圖片，typora就會自動幫我們上傳圖片到圖片空間了。\n","date":"2022-10-08T01:02:04+08:00","image":"https://i.imgur.com/W6FAkN1.png","permalink":"https://hoxtonhsu.com/p/typora-%E5%A6%82%E4%BD%95%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E6%95%99%E5%AD%B8-%E4%BD%BF%E7%94%A8github-imagur%E4%BD%9C%E7%82%BA%E5%9C%96%E7%89%87%E7%A9%BA%E9%96%93/","title":"TYPORA 如何上傳圖片(教學 使用Github , imagur作為圖片空間)"},{"content":"​\t到底要不要進事務所？\n我想一開始就給出解答\n如果不知道做什麼就進事務所吧！\n​\t如果是會計系的學生，在大學期間一定有想過自己到底要不要進入所謂的四大（勤業、資誠、安侯、安永），我在大學的時候對於這個問題倒是沒太多想法，只覺得進入四大事務所好像很威風，出入信義區，西裝革履的樣子，名稱也是國際上有名公司，怎麼想都覺得很穩，能出什麼問題？\n當然實際進去之後我就後悔了，發現這樣的生活根本不是自己想要的，索性的待到一月，把年終獎金還有到職獎金，以及政府的青年就業補助的錢領一領之後，就趕緊跑回高雄準備轉換跑道，做什麼都行，但這輩子絕對不會在做會計了。\n但離職過後也快一年，轉換工作也算成功，但持續的一直有在Follow會計這個圈子，所以想說來分享一下自己的一些想法，希望可以幫助到一些會計系的學生。\n 一份工作一定是有好有壞的，事務所的工作則是將好與壞的那非常極端，這篇文章先來講「我」覺得事務所好的地方，下一篇文章再來講我為什麼離職。\n  事務所的名聲   事務所的名聲是我在離職之後最直接的感受，在自我介紹或是之後轉換跑道的面試，第一個被問的問題都是\n「你之前在資誠耶，很好的一間公司？怎麼會想要離職轉換跑道呢？」\n誠然四大在會計系學生的眼中已經是臭到不能再臭的公司，但出了事務所之後，只要待的公司不是太鳥的那種，基本上四大的經歷即使不到亮眼，但也絕對不會是一個看不上眼的經歷。\n 事務所是一家很大的公司   在離職之後第二個很深的感受是，四大確實是一間很大的公司，在信義區的精華地段裡有很多層樓的辦公室，有包場的尾牙，會請藝人來唱歌，還有很完善的公司分工制度。我現在的公司就是一家在中山區普通商辦大樓裡面的辦公室，員工數大概也就十來人左右，也沒什麼完整的分工制度，有時候感覺一個人要身兼多職。\n而且我相信很多人離職之後，第二家公司的規模都不會再有四大那樣的規模，所以我覺得可以來四大體驗看看一家員工數破千的公司感覺是怎麼樣的。\n 事務所的工作強度   這點其實很諷刺，我之前在的組別是最近很夯的資誠A11 AKA 獨立所疊字組。說實話當時也沒覺得什麼地不地獄的，當你看同事在加班，組長在加班，經理們也在加班，其實當下也會覺得沒什麼，反正大家就一起加班，有時候晚上六點多，同事們相約訂餐的畫面總讓我想起國小在讀安親班的感覺。\n我在事務所的上班的大概就是9月入職然後到1月初離職，唯一接觸到的忙季大概就是十月，那時候星期一到五大概都是9點10點那邊回家，差不多有三天是待到11點才走（11點就可以走是因為資誠是在國貿大樓，國貿大樓11點就要關門，所以才有機會回家Q_Q），星期六大概是10點11點進所內，然後可能晚上8、9點離開，至於星期天我是沒進過所內，快樂的小確幸～\n在這樣中強度的加班強度下，我離職之後，不管待哪家公司我都覺得好爽，這可能也是事務所很諷刺的一個好處吧，畢竟從四大出來的，每個都是見過地獄的人，到哪裡都像是天堂一樣。\n 哈哈，可能真的太久沒寫文章了，感覺原本腦中有很多想法，突然要寫就寫不出什麼東西來，自己寫完再回頭來看自己列的這幾點，發現真的是蠻無聊的幾個點，也不構成什麼吸引力，但要問我後悔進入事務所嗎？其實還蠻慶幸我有進入事務所的，因為世界上真的找不太到比那更爛的工作了，我也是在那段期間真的很想離職，有這樣的念頭之後才知道自己到底想做的是什麼，這可能就是所謂的「在極大的痛苦中感覺精神甦醒吧」，總之我想說的是，不管你是台政北或是私科會計，不知道做啥就是選事務所，進去之後就會知道原來有這麼爛的工作，就會強迫自己去想自己到底要做什麼，如果做得下去那也很好，事務所的履歷還是有一點點用的（但我都建議最好是待到組長會比較有用一點）。\n接下來下一篇文章會聊聊我為什麼從事務所離職，應該蠻多可以談的～\n","date":"2022-10-08T00:36:13+08:00","image":"https://i.imgur.com/aHMlhAm.png","permalink":"https://hoxtonhsu.com/p/%E5%BE%9E%E5%85%A5%E8%81%B7%E5%88%B0%E9%9B%A2%E8%81%B7%E4%BA%8B%E5%8B%99%E6%89%80%E7%9A%84%E6%97%A5%E5%AD%90%E4%B9%8B%E8%A9%B2%E9%80%B2%E4%BA%8B%E5%8B%99%E6%89%80%E5%97%8E/","title":"從入職到離職，事務所的日子之《該進事務所嗎？》"},{"content":"目錄  Filter(過濾器)Interceptor(攔截器)AOP(剖面導向程式設計)之差異  Filter  Interceptor AspectJ    AspectJ 1 2  graph TD; AOP ---\u0026gt; SpringAop \u0026amp; AspectJ   AOP (概念) 面向切面編程，利用AOP可以對業務邏輯的各個部分進行隔離，使得業務邏輯各部分之間的耦合度降低，提高程式的可重用性，同時提高開發的效率\n不修改原始碼，從而擴充新功能\nFilter(過濾器)Interceptor(攔截器)AspectJ(AOP)之差異 1 2 3 4 5 6 7 8 9 10 11  flowchart LR; 1((使用者))--發送請求 --\u0026gt;Filter\\n+統一設置編碼\\n+過濾敏感字\\n+登入驗證\\n+URL級別的訪問權限控制\\n+數據壓縮 --\u0026gt;dispatcher --\u0026gt;Interceptor\\n+權限驗證\\n+登入驗證\\n+性能檢測 --\u0026gt;AOP\\n+日誌紀錄 --\u0026gt;2(Controller) -1[粗糙]--能處理request的精細程度----\u0026gt;-2[細緻]   Filter 1 2 3 4 5 6  flowchart LR; 1[瀏覽器]---\u0026gt;2{過濾器}---\u0026gt;3[Web資源] 3[Web資源]--\u0026gt;2{過濾器}--\u0026gt;1[瀏覽器]   在HttpServletRequest到達Servlet之前，過濾、處理一些資訊，本身依賴Sevlet容器，不能獲取SpringBean的一些資訊，它是javax.servlet.FilterChain的項目，不是Springboot\n可以做什麼\n 修改Request, Response 防止xss(Cross-Site-SCripting跨網站指令碼)攻擊 包裝二進制流  自定義Filter  以註解方式製作Filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ @Slf4j @Component @WebFilter(filterName = \u0026#34;f1\u0026#34;,urlPatterns = {\u0026#34;*.html\u0026#34;,\u0026#34;*.jsp\u0026#34;,\u0026#34;/\u0026#34;}) //filterName就只是一個名稱可以，隨意就好，urlPattern是用來指定哪些url要經過這個過濾器 public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了  } }   結果如上\n 以Java配置方式製作Filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Slf4j /** * 網路上教學蠻多都是implenments filter，但我建議extend GenericFilterBean * 會比較方便一點，省去implenments init(), distory()的麻煩 */ public class HiFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { log.info(\u0026#34;Hello Hoxton\u0026#34;); chain.doFilter(request,response); //代表這個Filter已經作用完畢，可以把request,response交給下一個Filter了  } }   1 2 3 4 5 6 7 8 9  @Configuration public class FilterConfig { @Bean public FilterRegistrationBean heFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(new HiFilter()); registration.addUrlPatterns(\u0026#34;/*\u0026#34;); //配置相關的路徑  return registration; } }    一些其他的config設置，僅供參考，與上面釋例無關\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  @Configuration public class FilterConfig { //test @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logProcessTimeFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogProcessTimeFilter()); //設定想要使用哪一個Filter  bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到  bean.setName(\u0026#34;logProcessTimeFilter\u0026#34;); //設置要叫什麼名字  bean.setOrder(0); //設定過濾器的執行順序  return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; logApiFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new LogApiFilter()); //設定想要使用哪一個Filter  bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到  bean.setName(\u0026#34;logApiFilter\u0026#34;); //設置要叫什麼名字  bean.setOrder(1); //設定過濾器的執行順序  return bean; } @Bean public FilterRegistrationBean\u0026lt;Filter\u0026gt; printResponseRequestFilter() { FilterRegistrationBean\u0026lt;Filter\u0026gt; bean = new FilterRegistrationBean\u0026lt;\u0026gt;(); bean.setFilter(new PrintResponseRequest()); //設定想要使用哪一個Filter  bean.addUrlPatterns(\u0026#34;/*\u0026#34;); //設置哪些url會觸發Filter，設置成/* 就代表全部都會吃到，/user/*就代表/user開頭的都會吃到  bean.setName(\u0026#34;printResponseRequestFilter\u0026#34;); //設置要叫什麼名字  bean.setOrder(2); //設定過濾器的執行順序  return bean; } }    SpringBoot本身也提供了許多不同的Filter供使用，參考如下\n常用的有以下幾個\n CharacterEncodingFilter(用於處理編碼問題) HiddenHttpMethodFilter(隱藏Http函數) HttpPutFormContentFilter(form表單處理) RequesrtContextFilter(請求上下文)  其他資訊可以詳閱Spring MVC中各个filter的用法\n其中以OncePerRequestFilter最常被使用，這個Filter會去過濾每一個Request請求，且不會重複執行，且這個Filter有一個doFilterInternal()的方法，供我們撰寫Filter邏輯因doFilter()的方法已在OncePerRequestFilter裡面實現了，可以用來做Jwtoken的登入驗證，程式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  @Component public class JwtAuthenticationFilter extends OncePerRequestFilter { @Autowired private JwtService jwtService; @Autowired private UserDetailsService userDetailsService; //注入JwtService UserDetailsService，分別用來解析Token與查詢使用者詳情  @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION); if (authHeader != null) { String accessToken = authHeader.replace(\u0026#34;Bearer \u0026#34;, \u0026#34;\u0026#34;); //從請求標頭中取得Authorization欄位中的值  Map\u0026lt;String, Object\u0026gt; claims = jwtService.parseToken(accessToken); //擷取出後面的JWT字串，接著解析它  String username = (String) claims.get(\u0026#34;username\u0026#34;); //從claims物件中取得username欄位的值  UserDetails userDetails = userDetailsService.loadUserByUsername(username); //並透過userDetailService查詢使用者詳情。這也代表JWT的內容(payload)必須包含username這個欄位  //在filter中查詢使用者的目的，是為了將該次請求所代表的驗證後資料(Authentication)帶進security中的Context。  //Context是一種較抽象的概念，可以想像成該次請求的身分狀態  Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); //為了將這個請求的使用者身分告訴伺服器，我們建立UsernamePasswordAuthenticationToken的物件，其中第三個參數放GrantedAuthority的List， 作為API的授權檢查  //第一個參數(principal)傳入使用者詳請(UserDetails)。  // 而第二個參數是credential，通常是密碼，但不傳入也無訪  //經由傳入principal，我們得以在業務邏輯中從Context輕易獲取使用者身分的資料  SecurityContextHolder.getContext().setAuthentication(authentication); } filterChain.doFilter(request, response); } }   配置完後再將這個Filter加入Security的過濾鍊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Autowired private JwtAuthenticationFilter jwtAuthenticationFilter; /** * 協助帳號密碼認證的東西 * @return */ @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } //加入Security的過濾鍊  protected void configure(HttpSecurity http) throws Exception { http.authorizeHttpRequests() .antMatchers(HttpMethod.GET, \u0026#34;/users/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name()) // .antMatchers(HttpMethod.GET,\u0026#34;/h2/**\u0026#34;).hasAuthority(MemberAuthority.SYSTEM_ADMIN.name())  .antMatchers(HttpMethod.GET,\u0026#34;/login/**\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST,\u0026#34;login\u0026#34;).permitAll() // .antMatchers(HttpMethod.POST, \u0026#34;/users\u0026#34;).permitAll()  .anyRequest().permitAll() .and() .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) //於UsernamePasswordAuthenticationFilter進行認證  .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .csrf().disable() .formLogin(); http.headers().frameOptions().disable(); //讓spring Security可以和h2建立連線  } /** * * @param auth 配置全局驗證資訊，如Authentication Provider,UserDetailService等等資訊， * authenticationManager會接收到UsernamePasswordAuthenticationToken傳入的資料後 * 調用SecurityConfig中所配置的userDetailsService,passwordEncoder來協助驗證 * * @throws Exception */ protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); } }   一些Code的示範\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class LogProcessTimeFilter extends OncePerRequestFilter { /** * @param request 請求 * @param response 回應 * @param filterChain 過濾鏈 會將現有的filter給串聯起來，當請求進入後端，需要依序經過它們才會達到Controller，相對的，當回應離開Controller，則是按照相反的方向經過那些Filter * @throws ServletException * @throws IOException */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { long startTime = System.currentTimeMillis(); filterChain.doFilter(request, response); //doFilter:相當於將請求送至Controller。  long endTime = System.currentTimeMillis(); long processTime = endTime - startTime; System.out.println(\u0026#34;processTime = \u0026#34; + processTime); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /** * Controller收到的請求主體(RequestBody)和回應主體(ResponseBody) * 分別由HttpServletRequest與HttpServletResponse的InputStream、OutputStream轉化而來， * 但資料流只能讀取一次，如果在Filter層就被讀掉，可能會導致後面都收不到資料 * 為了保留主體中的資料，我們將請求主體與回應主體包裝成ContentCachingResponseWrapper ContentCachingRequestWrapper * 再如同往常傳入FilterChain * * 這兩個Wrapper的特色是會在內部備份一個ByteArrayOutputStream，我們只要呼叫這兩個Wrapper的 * getContentAsByteArray就可以無限制地取得主體內容 */ public class PrintResponseRequest extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request); ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response); filterChain.doFilter(requestWrapper, responseWrapper); // logApi(request, response);  logBody(requestWrapper,responseWrapper); responseWrapper.copyBodyToResponse(); } private void logApi(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int httpStatus = response.getStatus(); //200,403,404之類的  String httpMethod = request.getMethod(); String uri = request.getRequestURI(); String params = request.getQueryString(); if (params != null) { uri += \u0026#34;?\u0026#34; + params; } System.out.println(String.join(\u0026#34; \u0026#34;, String.valueOf(httpStatus), httpMethod, uri)); } private void logBody(ContentCachingRequestWrapper request, ContentCachingResponseWrapper response) { String requestBody = getContent(request.getContentAsByteArray()); System.out.println(\u0026#34;Request: \u0026#34; + requestBody); String responseBody = getContent(response.getContentAsByteArray()); System.out.println(\u0026#34;Response: \u0026#34; + responseBody); } /** * @param content * @return 返回JSON字串 */ private String getContent(byte [] content){ String body = new String(content); return body.replaceAll(\u0026#34;[\\n\\t]\u0026#34;, \u0026#34;\u0026#34;); //去除換行\\n與定位符號\\t  } }   Interceptor 本身是AOP的一種應用，其實攔截器跟過濾器是可以互相替換的，功能其實差不多，只是攔截器可以在請求到達Controller或是回應回傳出Contrller時進行攔截，攔截成功時可以實做一些自定義的業務邏輯進行修改，且Interceptor是Springboot下的一個功能org.springframework.web.servlet.HandlerInterceptor\n可以用來\n 性能監控：紀錄請求的處理時間，比如說請求處理太久（超過500毫秒） 登入檢測   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  graph LR; request--\u0026gt;id1 id1--\u0026gt;id2--\u0026gt;id4--\u0026gt;id3--\u0026gt;id6--\u0026gt;id5 subgraph 攔截器1 direction TB id1[\u0026#34;preHandle()\u0026#34;] id3[\u0026#34;postHandler()\u0026#34;] id5[\u0026#34;afterCompletion()\u0026#34;] end subgraph 攔截器2 direction TB id2[\u0026#34;preHandle()\u0026#34;] id4[\u0026#34;postHandler()\u0026#34;] id6[\u0026#34;afterCompletion()\u0026#34;] end   要實現interceptor有兩種方式\n 實作HandlerInterceptor 繼承HandlerInterceptorAdapter  釋例\n 自定義攔截器  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class LogInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); System.out.println(\u0026#34;\\n-------- LogInterception.preHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;Start Time: \u0026#34; + System.currentTimeMillis()); request.setAttribute(\u0026#34;startTime\u0026#34;, startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.postHandle --- \u0026#34;); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;\\n-------- LogInterception.afterCompletion --- \u0026#34;); long startTime = (Long) request.getAttribute(\u0026#34;startTime\u0026#34;); long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;Request URL: \u0026#34; + request.getRequestURL()); System.out.println(\u0026#34;End Time: \u0026#34; + endTime); System.out.println(\u0026#34;Time Taken: \u0026#34; + (endTime - startTime)); } }    註冊攔截器  1 2 3 4 5 6 7 8 9 10 11 12  @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogInterceptor()); registry.addInterceptor(new OldLoginInterceptor()).addPathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); registry.addInterceptor(new AdminInterceptor()).addPathPatterns(\u0026#34;/admin/*\u0026#34;).excludePathPatterns(\u0026#34;/admin/oldLogin\u0026#34;); } }   AspectJ 屬於一種AOP框架\n 動態代理(Spring5本身已經封裝了)  有兩種情況的動態代理   有介面(JDK動態代理)\n1 2 3  interface UserDao{ public void login(); }   1 2 3 4  class UserDaoImpl implements　UserDao{ public void login(){ } }   創建UserDao介面實現類的代理對象，代理對象會有被代理對象的所有方法，並且增強\n  無介面(CGLIB動態代理)\n1 2 3 4 5  class User{ public void add (){ } }   1 2 3 4 5  class Person extends User{ public void add(){ super.add(); } }         AOP(JDK動態代理) 使用JDK的動態代理，要使用Proxy類裡面的方法來創建出代理對象 newProxyInstance(類加載器,增強方法所在的類，這個類實現的介面,實現這個接口(InvocationHandler)\n編寫JDK動態代碼\n1 2 3 4 5 6  public interface UserDao { public int add (int a,int b); public String update(String id); }   1 2 3 4 5 6 7 8 9 10 11 12 13  public class UserDaoImpl implements UserDao{ @Override public int add(int a, int b) { System.out.println(\u0026#34;add方法執行了\u0026#34;); return a+b; } @Override public String update(String id) { return id; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package com.example.aop; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; /** * @author Hoxton * @version 1.1.0 */ public class JDKProxy { public static void main(String[] args) { Class[] interfaces = {UserDao.class}; UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); //此dao已經不是原本的dao，而是新的代理類dao了  int result = dao.add(1, 2); System.out.println(\u0026#34;result = \u0026#34; + result); } } //創建代理對象的代碼 class UserDaoProxy implements InvocationHandler { //1. 把創建的是誰的代理對象，把誰傳遞進來  // 有參建構子  private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增強的邏輯  @Override public Object invoke(Object proxy, Method method, Object[] methodArgs) throws Throwable { //方法之前  System.out.println(\u0026#34;方法之前執行...\u0026#34; + method.getName() + \u0026#34;傳遞的參數...\u0026#34; + Arrays.toString(methodArgs)); //被增強的方法執行  Object res = method.invoke(obj, methodArgs); //方法之後  System.out.println(\u0026#34;方法之後執行...\u0026#34; + obj); return res; } }   AOP專業術語   連接點\n一個類裡面中，能被增強的方法就叫連接點，下面這個類就有四個連接點\n1 2 3 4 5 6  class User{ add(); update(); select(); delete(); }     切入點\n實際被增強的方法，就叫切入點\n  通知(增強)\n  實際增強的邏輯部分稱為通知(增強)\n  通知有多種類型\n  前置通知\n在切入點前執行\n  後置通知\n在切入點後執行\n  環繞通知\n在切入點前後執行\n  異常通知\n出現異常時執行\n  最終通知\n執行到try\u0026hellip;catch的final時執行\n      切面\n是一個動作\n 把通知應用到切入點的過程，就叫切面    AOP(準備)   Spring 框架一般都是基於AspectJ實現的AOP操作\n  什麼是AspectJ\n AspectJ不是Spring的組成部分，是一個獨立的AOP框架， 一般把AspectJ和Spring框架一起使用，進行AOP操作    基於Aspect實現AOP操作\n xml配置文件實現 基於註解方法實現(主要使用)    再專案裡面引入AOP依賴\n  切入點表達式\n  切入點表達式的作用: 知道對哪個類的哪個方法進行增強\n  語法結構:\nexecution( [權限修飾符] [返回類型] [類全路徑] [方法名稱] ( [參數列表] ) )\n  權限修飾符: public, private, *(代表不論是public, private 都選)\n  返回類型: String, int\n  類全路徑: com.hoxton\u0026hellip;\u0026hellip;.\n  方法名稱: 就方法名稱\n  參數列表: 有哪些參數\n舉例\n  對com.hoxton.dao.BookDao類裡面的add方法進行增強\n  1  execution(* com.hoxton.dao.BookDao.add(..) )       對com.hoxton.dao.BookDao類的所有方法進行增強\n  1  execution(* com.hoxton.dao.BookDao.*(..))       對com.hoxton.dao包裡的所有類，類裡面的髓有方法進行增強\n  1  excution(* com.hoxton.dao.*.*(..))         within([package名].* )或( [package名]..*)\n舉例\n          AOP操作(Aspect J 註解)  創建類，在類裡面定義方法  1 2 3 4 5 6  public class User { public void add(){ System.out.println(\u0026#34;add\u0026#34;); } }    創建增強類(編寫增強邏輯)\n  在增強類的裡面，創建方法，讓不同方法代表不同通知類型\n1 2 3 4 5  public class UserProxy { public void before(){ System.out.println(\u0026#34;before\u0026#34;); } }       進行通知的配置\n 在Spring    Log4j 2 1 2 3 4  flowchart TD; 8[\u0026#34;ALL(全輸出不留情)\u0026#34;]---\u0026gt;7[\u0026#34;Trace(更細的除錯資訊，通常用來追蹤城市流程的日誌)\u0026#34;]---\u0026gt;6[\u0026#34;DEBUG(除錯資訊的日志)推薦★\u0026#34;]---\u0026gt;5[\u0026#34;INFO(一般資訊的日志)推薦★\u0026#34;]---\u0026gt;4[\u0026#34;WARN(可能導致錯誤的日志)\u0026#34;]---\u0026gt;3[\u0026#34;ERROR(造成應用錯誤停止的日志)\u0026#34;]---\u0026gt;2[\u0026#34;FETAL(造成應用程式停止的日志)\u0026#34;]---\u0026gt;1[\u0026#34;OFF(不輸出任何日志)\u0026#34;]   參考 https://www.cnblogs.com/itlihao/p/14329905.html\nhttps://blog.csdn.net/fly910905/article/details/86537648\nSpringBoot攔截器(Interceptor)詳解\nSpring Boot使用過濾器和攔截器分別實現REST介面簡易安全認證\n  ","date":"2022-10-07T22:41:52+08:00","image":"https://i.imgur.com/B7GhSw1.png","permalink":"https://hoxtonhsu.com/p/%E5%9F%BA%E7%A4%8Eaop%E4%BB%8B%E7%B4%B9-filter-interceptor-aspectj/","title":"基礎AOP介紹-Filter Interceptor AspectJ"},{"content":"SpringBoot-Scheduling 用來做定期任務的東西，有兩種\n Spring schedule：只適合處理簡單的計畫任務，不能處理分散式的任務，當任務太多時，可能出現阻塞、崩潰、延遲啟動等問題 Quartz：更強大的一個排程器，能夠配置上百甚至上千的事務。  Spring Schedule 步驟  在啟動類上加上@EnableScheduling  1 2 3 4 5 6 7  @SpringBootApplication() @EnableScheduling public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }   在方法上加上@Scheduled  1 2 3 4 5 6 7  @Component public class Task { @Scheduled(fixedDelay = 10 * 100) public void printLocalTime() { System.out.println(LocalTime.now().toString()); } }   1 2 3 4  @Scheduled(cron = \u0026#34;1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); }   1 2 3 4  @Scheduled(cron = \u0026#34;0/1 * * * * ?\u0026#34;,zone = \u0026#34;Asia/Taipei\u0026#34;) public void printPer5second(){ log.info(\u0026#34;cron\u0026#34;); }   Cron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n   秒 分 時 日 月 周 年(可選)     1 * * * * ? ?     秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年  想像一個時鐘\u0026hellip;\n   當每次秒針指向一秒時 1 * * * * ?     當每次時針指向12時 * * 12 * * ?   每個月 1 號中午 12 點 0 0 12 1 * ?   1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ?       字元 意義     * 表達任意值，所有值都可以匹配   ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值   - 指定範圍，前後接數字: 10-12   , 指定離散的選項: 1,5,6,8，或者的概念   / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位   L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二   W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後   LW 用在日的值域，表示最後一周的工作日   # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三   C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天    Quartz 是一個開源的任務排程器，幾乎可以整合到任何Java應用程式中。\n它可以用來\n 安排每個晚上把資料庫內容轉存到檔案 提供定時提醒服務 族繁不及備載\u0026hellip;  底層數據結構- 堆 介紹 堆是一種特殊的樹，滿足下面兩個條件，就是一個堆\n 堆是一顆完全二元樹完整二元樹：除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..)  每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值   小頂堆\n 完整二元樹的一些特性：快速定位父節點\n在排程器的框架中，每一個節點就是一個Job，越頻繁的Job會被放置在越上層的節點\n如何插入元素 尾插法，在尾部插入一個新的元素，然後上浮，浮到符合定義\n 除了最後一層以外，其他層的節點數需要達到最大(1,2,4,8. ..)，且最後一層節點都靠左排列 每個節點所儲存的值，必須要大於小頂堆或小於大頂堆父節點的值  如何刪除元素 將尾部(最後一個節點)放置到堆頂，然後下沉\n時間輪算法(Time Wheel) 再刪除元素的時候都需要下沉，當節點數很多時會造成性能延宕\nround 型的時間輪 任務上記錄一個round，遍歷到了就將round減一，為0時取出來執行\n分層時間輪 Cron表達式以及其他排程器所採用的底層架構，分成秒輪、分輪、小時輪、日輪、周輪、月輪、年輪\u0026hellip;，月輪迭代到了，就將任務取出放到天輪中執行\u0026hellip;，以此類推\nCron表達式(七子表達式) 表達式生成工具\nCron語源來自Chronos，是希臘神話中掌管時間的神柯羅諾斯(Chronos)。\n   秒 分 時 日 月 周 年(可選)     1 * * * * ? ?     秒：0-59 分：0-59 時 ：0-23 日：1-31 月：0-11或\u0026quot;JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC\u0026quot; 周：1-7或SUN, MON, TUE, WED, THU, FRI,SAT 年  想像一個時鐘\u0026hellip;\n   當每次秒針指向一秒時 1 * * * * ?     當每次時針指向12時 * * 12 * * ?   每個月 1 號中午 12 點 0 0 12 1 * ?   1 月每天中午 12 點，每 5 秒 0/5 0 12 * 1 ?       字元 意義     * 表達任意值，所有值都可以匹配   ? 只用在 日 跟 周 的值域，有點表達 don’t care 的概念，無所謂，不關心到底是什麼值   - 指定範圍，前後接數字: 10-12   , 指定離散的選項: 1,5,6,8，或者的概念   / 指定增量，表達 每 的概念: 0/5 意旨從 0 開始每 5 單位   L 用在 月 跟 周 的值域。在月的話表達最後一天，在周的話前面可以加上數字 3L 表示該月最後一個星期二   W 用在日的值域表示距離最近的該月工作日: 15W，距離 15 號最近的工作日，可能往前也可能往後   LW 用在日的值域，表示最後一周的工作日   # 用在周的值域，指定特定周的特定日: “4#2” 表示第二周的星期三   C 用在日跟周的值域，指某特定個日期的後一天: 在日中寫 3C 指該月 3 號的後一天，在周中寫 2C 指該周星期一的後一天    ​\n重要API及概念  記得Job類一定要是public class，不然Scheduler會讀不到\n 釋例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Quartz { public static void main(String[] args) { MyJob myJob = new MyJob(); JobDetail jobDetail = JobBuilder.newJob(MyJob.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .build(); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;trigger1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); } catch (SchedulerException e) { throw new RuntimeException(e); } ; } }   1 2 3 4 5 6  public class MyJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;MyJob execute:\u0026#34; + new Date()); } }   釋例二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class HelloJob { public static void main(String[] args) { try { Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) //Job1是名字，具有唯一性，group1是這個Job屬於哪一組，同一組的Job可以共享相同的邏輯來處理Job。需要name與Job才可以組成一個JobKey  .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build(); SimpleTrigger trigger = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); // scheduler.shutdown();  } catch (SchedulerException e) { throw new RuntimeException(e); } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @Slf4j @NoArgsConstructor public class SayHello implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail jobDetail = context.getJobDetail();//從context中獲取屬性  JobKey key = jobDetail.getKey(); Class\u0026lt;? extends Job\u0026gt; jobClass = jobDetail.getJobClass(); String description = jobDetail.getDescription(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); String username = jobDataMap.getString(\u0026#34;username\u0026#34;); int age = jobDataMap.getIntValue(\u0026#34;age\u0026#34;); log.info(\u0026#34;\\nJobKey : {},\\n JobClass : {},\\n JobDesc : {},\\n username : {},\\n age : {}\u0026#34;, key, jobClass.getName(), description, username, age); } }   Scheduler 生命週期由ScheduleFactory建立開始，呼叫shutdown方法結束。\n當Schduler建立，任何關於Schduling相關的事情，都由它控制\n 新增 刪除 列出所有Job 暫停觸發器  在Start之前不會做任何事情\nJob 你希望被排程器排程的任務元件介面，定義如何執行，是正在執行的作業例項，一個Job可以建立多個JobDetail，擁有不同的JobDataMap。本身implement了Job類\n1 2 3  graph TD; Job ---\u0026gt; JodDetail1 \u0026amp; JodDetail2 \u0026amp; JodDetail3 \u0026amp; JodDetail...   1 2 3 4 5 6  public class SendEmail implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\u0026#34;SendEmail\u0026#34;); } }    當Job的觸發器觸發時，排程程式的工作執行將呼叫excute()方法 該方法接收一個JobExcutionContext物件，為Job提供了豐富的執行時環境，比如schduler,trigger,jobDataMap,job,calender,time   何謂Context(上下文)\n可以理解為環境、容器的意思會比上下文更具體一點，它提供了一個程式中全域性的資訊。\n JobDetail 用於定義Job的各種屬性、各種任務，還可以用來為Job儲存狀態資訊的JobDataMap，是將Job加入scheduler時，所需要創建的一個物件，它包含了各種屬性設置，以及用於存取job實例狀態訊息的JobDataMap，在創建JobDetail時，需要將欲執行的類名傳遞給JobDetail，這樣schedule就知道要執行何種類型的job。\n1  JobDetail jobDetail=JobBulider.newJob(Job.class).bulid();   JobDataMap 實作Map介面，因此具有Key-Value，儲存可序列化資料，供Job在執行時使用。也可以使用usingJobData(key,value)在建構JobDetail的時候傳入資料，使用JobDetail.getDataMap()獲取Map。可以再透過jobDataMap取出裡面的數據\n1 2 3 4 5  JobDetail job = JobBuilder.newJob(HelloJob.class) .withIdentity(\u0026#34;helloJob\u0026#34;, \u0026#34;hello\u0026#34;)//給job命名並分組  .usingJobData(\u0026#34;jobdd\u0026#34;, \u0026#34;hello job\u0026#34;)//通過JobBuilder的usingJobData方法給JobDataMap中塞入數據  .build();   1 2 3 4 5 6 7 8 9 10  public class HelloJob implements Job { @Override public void execute(JobExecutionContext context) throws JobExecutionException { System.err.println(context.getJobDetail().getKey());// JobDetail的key又他的name和group組成 \tSystem.err.println(context.getTrigger().getKey());// Trigger的key又他的name和group組成 \tSystem.err.println(context.getJobDetail().getJobDataMap().get(\u0026#34;jobdd\u0026#34;)); System.err.println(\u0026#34;hello,quartz\u0026#34;); } }   會輸出\n`hello.helloJob\nhello.helloTrigger\nhello job\nhello, quartz\nTrigger 觸發任務執行，觸發器可能具有與Job有關的JobDataMap，以便將觸發器觸發的引數傳遞給Job，Quartz本身提供了幾種觸發器SimpleTrigger和CronTrigger是最常用到的。\nSimpleTriger 用於一次性執行作業或需要在給定的時間觸發一個作業並重複執行N次，且兩次執行時間有Delay。用在具體的時間點，並已指定的間隔時間重複執行若干次，它包含了幾種屬性：\n 開始時間 結束時間 重複次數 重複間隔  釋例一：立刻觸發一次，然後停止\n1 2 3 4 5  Date date = new Date(); Trigger trigger1 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(date) .build();   釋例二：指定時間觸發，每隔十秒執行一次，重複10次\n1 2 3 4 5 6 7 8  trigger = newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(myTimeToStartFiring) // if a start time is not given (if this line were omitted), \u0026#34;now\u0026#34; is implied  .withSchedule(simpleSchedule() .withIntervalInSeconds(10) .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings  .forJob(myJob) // identify job with handle to its JobDetail itself  .build();   釋例三：5分鐘以後開始觸發，僅執行一次\n1 2 3 4 5  trigger = (SimpleTrigger) newTrigger() .withIdentity(\u0026#34;trigger5\u0026#34;, \u0026#34;group1\u0026#34;) .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future  .forJob(myJobKey) // identify job with its JobKey  .build();   釋例四：立即觸發，每個5分鐘執行一次，直到22:00：\n1 2 3 4 5 6 7  trigger = newTrigger() .withIdentity(\u0026#34;trigger7\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(simpleSchedule() .withIntervalInMinutes(5) .repeatForever()) .endAt(dateOf(22, 0, 0)) .build();   釋例五：在下一小時整點觸發，每個2小時執行一次，一直重複：\n1 2 3 4 5 6 7 8 9 10 11  trigger = newTrigger() .withIdentity(\u0026#34;trigger8\u0026#34;) // because group is not specified, \u0026#34;trigger8\u0026#34; will be in the default group  .startAt(evenHourDate(null)) // get the next even-hour (minutes and seconds zero (\u0026#34;00:00\u0026#34;))  .withSchedule(simpleSchedule() .withIntervalInHours(2) .repeatForever()) // note that in this example, \u0026#39;forJob(..)\u0026#39; is not called which is valid  // if the trigger is passed to the scheduler along with the job  .build(); scheduler.scheduleJob(trigger, job);   CronTrigger 希望以日期作為觸發任務的板機，就用CronTriger，實務上比較常用這個\n1 2 3 4  CronTrigger trigger2 = TriggerBuilder.newTrigger() .withIdentity(\u0026#34;trigger3\u0026#34;, \u0026#34;group1\u0026#34;) .withSchedule(CronScheduleBuilder.cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build();   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package com.how2java; import static org.quartz.CronScheduleBuilder.cronSchedule; import static org.quartz.JobBuilder.newJob; import static org.quartz.TriggerBuilder.newTrigger; import static org.quartz.SimpleScheduleBuilder.simpleSchedule; import java.util.Date; import org.quartz.CronTrigger; import org.quartz.DateBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SimpleTrigger; import org.quartz.impl.StdSchedulerFactory; public class TestQuartz { public static void main(String[] args) throws Exception{ Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); Date startTime = DateBuilder.nextGivenSecondDate(null, 8); JobDetail job = newJob(MailJob.class).withIdentity(\u0026#34;mailJob\u0026#34;, \u0026#34;mailGroup\u0026#34;).build(); CronTrigger trigger = newTrigger().withIdentity(\u0026#34;trigger1\u0026#34;, \u0026#34;group1\u0026#34;).withSchedule(cronSchedule(\u0026#34;0/2 * * * * ?\u0026#34;)) .build(); // schedule it to run!  Date ft = scheduler.scheduleJob(job, trigger); System.out.println(\u0026#34;使用的Cron表达式是：\u0026#34;+trigger.getCronExpression()); // System.out.printf(\u0026#34;%s 这个任务会在 %s 准时开始运行，累计运行%d次，间隔时间是%d毫秒%n\u0026#34;, job.getKey(), ft.toLocaleString(), trigger.getRepeatCount()+1, trigger.getRepeatInterval());  scheduler.start(); //等待200秒，让前面的任务都执行完了之后，再关闭调度器  Thread.sleep(200000); scheduler.shutdown(true); } }   JobBulider 用來建立JobDetail\n1 2 3 4 5 6 7 8  JobDetail jobDetail = JobBuilder.newJob(某個繼承了Job的類)... JobDetail jobDetail = JobBuilder.newJob(SayHello.class) .withIdentity(\u0026#34;job1\u0026#34;, \u0026#34;group1\u0026#34;) .usingJobData(\u0026#34;username\u0026#34;, \u0026#34;Hoxton\u0026#34;) .usingJobData(\u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;) .withDescription(\u0026#34;desc-demo\u0026#34;) .build();   TriggerBulider\n用於建立Trigger\nIdentity 當Job和Trgger在Quartz排程程式中註冊時，會獲得標示鍵，JobKey和TriggerKey置入group中，易於組織管理，其中name與group必須唯一\n為何要將Job和Trigger分開來?  While developing Quartz, we decided that it made sense to create a separation between the schedule and the work to be performed on that schedule. This has (in our opinion) many benefits.\nFor example, Jobs can be created and stored in the job scheduler independent of a trigger, and many triggers can be associated with the same job. Another benefit of this loose-coupling is the ability to configure jobs that remain in the scheduler after their associated triggers have expired, so that that it can be rescheduled later, without having to re-define it. It also allows you to modify or replace a trigger without having to re-define its associated job.\n Job與JobDetail的一些說明  Job是正在執行的作業，JobDetail則是作業的定義 一個Job可以創建多個JobDetail，擁有不同的JobDataMap  舉例來說，今天寫了一個定時寄送信件的Job，叫做SendEmailJob，我們希望這個Job可以寄給客戶，然後在cc給你的主管，所以需要創建兩個不同的JobDetail，比如說SendEmailToClient、SendEmailToAdministor，並透過JobDataMap綁定參數傳遞至JobDetail中，這兩個JobDetail擁有各自獨立的JobDataMap，實現起來會更靈活。\n參考 官方文檔\n任務排程框架Quartz快速入門\nQuartz教學基礎\n觸發器詳細定義\n","date":"2022-10-06T23:14:21+08:00","image":"https://i.imgur.com/9or5BzU.png","permalink":"https://hoxtonhsu.com/p/java%E5%85%A7%E7%9A%84%E6%8E%92%E7%A8%8B%E5%99%A8%E4%BB%8B%E7%B4%B9/","title":"Java內的排程器介紹"}]